
+--------------------------------------------+
| Dump tree for directory: D:\Projects\Remotion Couples Quiz\my-video\src |
+--------------------------------------------+
├── @Assets
│  ├── clock.mp4
│  └── whoosh.mp3
├── Composition.tsx
├── Preview.tsx
├── QuizVideo.tsx
├── Root.tsx
├── ScriptVideo.tsx
├── Video.tsx
├── components
│  ├── Audio
│  ├── Comparison.tsx
│  ├── ComparisonEditor.tsx
│  ├── ConfigMenu
│  │  └── ConfigMenu.tsx
│  ├── ImageSelector.tsx
│  ├── Layout
│  │  └── AppLayout.tsx
│  ├── QuizSetup.tsx
│  ├── ScriptEditor
│  │  ├── AudioComponentEditor.tsx
│  │  ├── CaptionEditor.tsx
│  │  ├── CaptionPositioningScreen.tsx
│  │  ├── CaptionTimeline.tsx
│  │  ├── ComparisonComponentEditor.tsx
│  │  ├── ComponentEditor.tsx
│  │  ├── ComponentEditors.tsx
│  │  ├── ComponentPalette.tsx
│  │  ├── CountdownComponentEditor.tsx
│  │  ├── DraggablePreview.tsx
│  │  ├── ImageComponentEditor.tsx
│  │  ├── PositioningScreen.tsx
│  │  ├── ScriptEditor.tsx
│  │  ├── TextComponentEditor.tsx
│  │  ├── Timeline.tsx
│  │  ├── TitleComponentEditor.tsx
│  │  ├── VideoComponentEditor.tsx
│  │  ├── VoiceComponent.tsx
│  │  ├── VoiceComponentEditor.tsx
│  │  └── VoiceOverEditor.tsx
│  ├── Settings
│  │  ├── BackgroundManager.tsx
│  │  ├── FontManager.tsx
│  │  └── PositioningPopup.tsx
│  ├── Setup
│  │  ├── ComparisonEditor.tsx
│  │  ├── ImagePicker.tsx
│  │  ├── ImageSelector.tsx
│  │  └── Setup.tsx
│  ├── SetupPage.tsx
│  ├── TemplateManager
│  │  └── TemplateManager.tsx
│  ├── Timer.tsx
│  ├── Video
│  │  ├── AudioComponent.tsx
│  │  ├── CaptionRenderer.tsx
│  │  ├── ComparisonComponent.tsx
│  │  ├── ComparisonSequence.tsx
│  │  ├── CountdownSequence.tsx
│  │  ├── ImageComponent.tsx
│  │  ├── QuizVideo.tsx
│  │  ├── RemotionSubtitleCaption.tsx
│  │  ├── ScriptVideo.tsx
│  │  ├── TextComponent.tsx
│  │  ├── TextSequence.tsx
│  │  ├── TikTokCaptions.tsx
│  │  ├── TitleSequence.tsx
│  │  ├── TransitionSequence.tsx
│  │  ├── VideoComponent.tsx
│  │  └── VideoPositioningScreen.tsx
│  └── common
│     ├── ColorPicker.tsx
│     ├── IconButton.tsx
│     ├── Modal.tsx
│     ├── Slider.tsx
│     └── Switch.tsx
├── components-dump.txt
├── data
│  └── quizData.ts
├── font_service.py
├── index.ts
├── pages
│  ├── _app.tsx
│  ├── api
│  │  ├── copy-background.ts
│  │  ├── get-path.ts
│  │  └── save-path.ts
│  └── index.tsx
├── preview-entry.ts
├── preview-entry.tsx
├── public
│  ├── audio
│  ├── backgrounds
│  └── fonts
│     ├── font_dictionary.json
│     └── tiktok.otf
├── remotion
│  ├── VideoRoot.tsx
│  └── index.ts
├── render.mjs
├── services
│  ├── audioService.ts
│  ├── elevenLabs.ts
│  ├── pexels.ts
│  ├── templateService.ts
│  └── videoService.ts
├── store
│  ├── apiKeysStore.ts
│  └── configStore.ts
├── styles
│  ├── commonStyles.ts
│  ├── globals.css
│  ├── theme.ts
│  └── timeline.css
├── types
│  ├── media.d.ts
│  ├── quiz.ts
│  ├── script.ts
│  └── template.ts
└── utils
   ├── animation.ts
   ├── componentFactory.ts
   └── fileUtils.ts



--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\Composition.tsx ---

export const MyComposition = () => {
  return null;
};



--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\Preview.tsx ---

import React, { useEffect, useState } from 'react';
import { Composition } from 'remotion';
import { ScriptVideo } from './components/Video/ScriptVideo';
import { Script } from './types/script';

interface CustomFont {
    name: string;
    url: string;
    format: 'truetype' | 'opentype';
}

export const Preview: React.FC = () => {
    const [fontsLoaded, setFontsLoaded] = useState(false);
    const [renderKey, setRenderKey] = useState(0);
    const searchParams = new URLSearchParams(window.location.search);
    const scriptData = searchParams.get('props');
    
    useEffect(() => {
        const loadFonts = async () => {
            setFontsLoaded(false);
            try {
                const response = await fetch('http://localhost:3003/fonts/dictionary');
                if (!response.ok) throw new Error('Failed to load font dictionary');
                const fontDict = await response.json();
                console.log('Font dictionary:', fontDict);

                if (!scriptData) return;
                const script: Script = JSON.parse(decodeURIComponent(scriptData));

                // Get unique font families used in components
                const usedFonts = new Set<string>();
                script.components.forEach(comp => {
                    if (comp.type === 'text' || comp.type === 'title') {
                        const textComp = comp as { style?: { fontFamily?: string } };
                        if (textComp.style?.fontFamily) {
                            usedFonts.add(textComp.style.fontFamily);
                            console.log('Found font:', textComp.style.fontFamily);
                        }
                    }
                });

                // Load each used font
                const fontLoadPromises = Array.from(usedFonts).map(async fontName => {
                    const fontData = fontDict[fontName];
                    if (fontData?.url) {
                        try {
                            console.log('Loading font:', fontName, 'from URL:', fontData.url);
                            const font = new FontFace(fontName, `url(${fontData.url})`);
                            const loadedFont = await font.load();
                            document.fonts.add(loadedFont);
                            console.log('Successfully loaded font:', fontName);
                            return true;
                        } catch (error) {
                            console.error('Error loading font:', fontName, error);
                            return false;
                        }
                    }
                    return false;
                });

                // Wait for all fonts to load
                await Promise.all(fontLoadPromises);
                setFontsLoaded(true);
                setRenderKey(prev => prev + 1);
                console.log('All fonts loaded, forcing re-render');
            } catch (error) {
                console.error('Error loading fonts:', error);
                setFontsLoaded(true);
            }
        };

        loadFonts();

        // Listen for font updates
        const handleFontsUpdated = () => {
            console.log('Fonts updated, reloading...');
            loadFonts();
        };

        window.addEventListener('fontsUpdated', handleFontsUpdated);
        return () => {
            window.removeEventListener('fontsUpdated', handleFontsUpdated);
        };
    }, [scriptData]);
    
    if (!scriptData) {
        console.error('No script data provided');
        return <div>Error: No script data provided</div>;
    }

    if (!fontsLoaded) {
        return <div>Loading fonts...</div>;
    }

    try {
        const script: Script = JSON.parse(decodeURIComponent(scriptData));
        console.log('Preview rendering with script:', script);

        if (!script || typeof script !== 'object') {
            throw new Error('Invalid script data format');
        }

        if (!script.id || !script.title || !Array.isArray(script.components) || !Array.isArray(script.captionTracks)) {
            throw new Error('Missing required script properties');
        }

        const totalDuration = Math.max(
            ...script.components.map(comp => {
                const start = comp.startFrame || 0;
                const duration = comp.durationInFrames || 150;
                return start + duration;
            }),
            300
        );

        return (
            <Composition
                key={renderKey}
                id="ScriptVideo"
                component={ScriptVideo}
                durationInFrames={totalDuration}
                fps={30}
                width={1080}
                height={1920}
                defaultProps={{ script }}
            />
        );
    } catch (error) {
        console.error('Error parsing preview props:', error);
        return <div>Error: Invalid script data - {(error as Error).message}</div>;
    }
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\QuizVideo.tsx ---

import {AbsoluteFill, useCurrentFrame, interpolate} from 'remotion';
import {Intro} from './components/Intro';
import {Comparison} from './components/Comparison';
import {Outro} from './components/Outro';
import {QUIZ_DATA} from './data/quizData';

export const QuizVideo: React.FC = () => {
	const frame = useCurrentFrame();
	const introEndFrame = 150; // 5 seconds
	const outroStartFrame = 1650; // 55 seconds

	return (
		<AbsoluteFill style={{
			backgroundColor: '#1a1a1a',
		}}>
			{/* Intro Section */}
			<Intro />

			{/* Comparisons Section */}
			{QUIZ_DATA.map((item, index) => (
				<Comparison
					key={index}
					data={item}
					startFrame={150 + index * 150} // Each comparison starts 5 seconds after the previous
				/>
			))}

			{/* Outro Section */}
			<Outro />
		</AbsoluteFill>
	);
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\Root.tsx ---

import React, { useState, useRef, useEffect } from 'react';
import { Composition } from 'remotion';
import { Player, PlayerRef } from '@remotion/player';
import { ScriptVideo, ScriptVideoProps } from './components/Video/ScriptVideo';
import { Script, ComponentType, ScriptComponent } from './types/script';
import { AppLayout } from './components/Layout/AppLayout';
import { ComponentPalette } from './components/ScriptEditor/ComponentPalette';
import { Timeline } from './components/ScriptEditor/Timeline';
import { CaptionTimeline } from './components/ScriptEditor/CaptionTimeline';
import { ComponentEditor } from './components/ScriptEditor/ComponentEditor';
import { Modal } from './components/common/Modal';
import { TemplateManager } from './components/TemplateManager/TemplateManager';
import { theme } from './styles/theme';
import { commonStyles } from './styles/commonStyles';
import { IconButton } from './components/common/IconButton';
import { findAccessibleUrl } from './utils/fileUtils';

// Create an isolated video preview component
const IsolatedVideoPreview: React.FC<{ script: Script }> = ({ script }) => {
	const playerRef = useRef<PlayerRef>(null);

	return (
		<div style={{
			position: 'relative',
			width: '100%',
			height: '100%',
		}}>
			<Player
				ref={playerRef}
				component={ScriptVideo}
				durationInFrames={Math.max(
					...script.components.map(comp => {
						const start = comp.startFrame || 0;
						const duration = comp.durationInFrames || 150;
						return start + duration;
					}),
					300 // Minimum 10 seconds
				)}
				fps={30}
				compositionWidth={1080}
				compositionHeight={1920}
				style={{
					width: '100%',
					height: '100%',
				}}
				controls
				autoPlay
				loop
				inputProps={{ script }}
			/>
		</div>
	);
};

// Add error boundary
class ErrorBoundary extends React.Component<{
	children: React.ReactNode;
	onError?: (error: Error) => void;
}, { hasError: boolean }> {
	constructor(props: { children: React.ReactNode; onError?: (error: Error) => void; }) {
		super(props);
		this.state = { hasError: false };
	}

	static getDerivedStateFromError() {
		return { hasError: true };
	}

	componentDidCatch(error: Error) {
		if (this.props.onError) {
			this.props.onError(error);
		}
	}

	render() {
		if (this.state.hasError) {
			return null;
		}
		return this.props.children;
	}
}

// Wrap the video components with error boundary
const SafeVideoPreview = ({ script }: { script: Script }) => {
	const [error, setError] = useState<Error | null>(null);
	const [previewUrl, setPreviewUrl] = useState('');
	const previewContainerRef = useRef<HTMLDivElement>(null);

	// Update preview URL when script changes
	useEffect(() => {
		console.log('Updating preview URL with script:', script);
		console.log('Background settings:', script.settings.background);

		// Pass the script directly to the preview
		const scriptData = encodeURIComponent(JSON.stringify(script));
		const newPreviewUrl = `http://localhost:3001/ScriptVideo?props=${scriptData}`;
		console.log('Setting preview URL:', newPreviewUrl);
		console.log('Decoded preview data:', JSON.parse(decodeURIComponent(scriptData)));
		setPreviewUrl(newPreviewUrl);
	}, [script]);

	if (error) {
		return (
			<div style={{
				width: '100%',
				height: '100%',
				display: 'flex',
				flexDirection: 'column',
				alignItems: 'center',
				justifyContent: 'center',
				backgroundColor: theme.colors.background.primary,
				color: theme.colors.text.primary,
				padding: theme.spacing.lg,
				textAlign: 'center',
				gap: theme.spacing.md,
			}}>
				<div style={{
					fontSize: theme.fontSizes.lg,
					fontWeight: 'bold',
					marginBottom: theme.spacing.sm,
				}}>
					Preview Unavailable
				</div>
				<div style={{
					fontSize: theme.fontSizes.sm,
					color: theme.colors.text.secondary,
					maxWidth: '80%',
				}}>
					{error.message || 'There was an error loading the preview.'}
				</div>
			</div>
		);
	}

	return (
		<div 
			ref={previewContainerRef}
			style={{
				position: 'relative',
				width: '100%',
				height: '100%',
				backgroundColor: '#000',
			}}
		>
			{previewUrl && (
				<iframe
					src={previewUrl}
					style={{
						width: '100%',
						height: '100%',
						border: 'none',
					}}
					title="Video Preview"
					key={previewUrl}
				/>
			)}
		</div>
	);
};

export const RemotionRoot: React.FC = () => {
	const [script, setScript] = useState<Script>({
		id: Date.now().toString(),
		title: 'New Quiz',
		components: [],
		captionTracks: [],
		settings: {
			defaultTextStyle: {
				fontSize: 40,
				color: 'white',
				fontFamily: 'Arial',
				textAlign: 'center',
			},
			defaultCaptionStyle: {
				fontSize: 24,
				color: 'white',
				fontFamily: 'Arial',
				textAlign: 'center',
			},
			background: {
				type: 'none',
			},
		},
	});

	const [currentFrame, setCurrentFrame] = useState(0);
	const [selectedComponentId, setSelectedComponentId] = useState<string | undefined>(undefined);
	const [isTemplateManagerOpen, setIsTemplateManagerOpen] = useState(false);
	const [timelineZoom, setTimelineZoom] = useState(1);
	const [editingTextPosition, setEditingTextPosition] = useState<string | null>(null);
	const [previewKey, setPreviewKey] = useState(0);
	const [previewUrl, setPreviewUrl] = useState('');
	const [error, setError] = useState<Error | null>(null);

	const playerRef = useRef<PlayerRef>(null);
	const previewContainerRef = useRef<HTMLDivElement>(null);

	// Calculate total duration, minimum 30 frames (1 second)
	const totalDuration = Math.max(
		...script.components.map(comp => {
			const start = comp.startFrame || 0;
			const duration = comp.durationInFrames || 150; // Default 5 seconds if not specified
			return start + duration;
		}),
		300 // Minimum 10 seconds
	);

	// Get selected component
	const selectedComponent = script.components.find(c => c.id === selectedComponentId);

	// Handle messages from preview iframe
	useEffect(() => {
		const handleMessage = (event: MessageEvent) => {
			if (event.origin === 'http://localhost:3001') {
				try {
					const data = JSON.parse(event.data);
					if (data.type === 'updateTextPosition' && data.componentId && data.position) {
						setScript(prev => ({
							...prev,
							components: prev.components.map(comp => {
								if (comp.id === data.componentId && comp.type === 'text') {
									return {
										...comp,
										style: {
											...comp.style,
											position: data.position
										}
									};
								}
								return comp;
							})
						}));
					}
				} catch (err) {
					console.error('Error processing message:', err);
				}
			}
		};

		window.addEventListener('message', handleMessage);
		return () => window.removeEventListener('message', handleMessage);
	}, []);

	const handleDragStart = (type: ComponentType) => {
		console.log('Dragging component:', type);
	};

	const handleComponentChange = (updated: Script['components'][0]) => {
		const newScript = {
			...script,
			components: script.components.map(c => 
				c.id === updated.id ? updated : c
			),
		};
		setScript(newScript);
		setPreviewKey(prev => prev + 1);
	};

	const handleComponentDelete = (id: string | undefined) => {
		const newScript = {
			...script,
			components: script.components.filter(c => c.id !== id),
		};
		setScript(newScript);
		setSelectedComponentId(undefined);
		setPreviewKey(prev => prev + 1);
	};

	const handleReorder = (components: ScriptComponent[]) => {
		setScript(prev => ({
			...prev,
			components,
		}));
	};

	const updatePreviewUrl = (script: Script) => {
		console.log('Updating preview URL with script:', script);
		console.log('Background settings:', script.settings?.background);

		// Get custom fonts from localStorage
		let customFonts = [];
		try {
			const savedFonts = localStorage.getItem('customFonts');
			if (savedFonts) {
				customFonts = JSON.parse(savedFonts);
			}
		} catch (error) {
			console.error('Error loading custom fonts:', error);
		}

		// Create preview data object with both script and fonts
		const previewData = {
			script,
			customFonts
		};

		// Update preview URL with combined data
		const previewUrl = `http://localhost:3001/ScriptVideo?props=${encodeURIComponent(JSON.stringify(previewData))}`;
		console.log('Setting preview URL:', previewUrl);
		console.log('Decoded preview data:', previewData);
		setPreviewUrl(previewUrl);
	};

	return (
		<>
			<ErrorBoundary>
				<Composition
					id="ScriptVideo"
					component={ScriptVideo}
					durationInFrames={totalDuration}
					fps={30}
					width={1080}
					height={1920}
					defaultProps={{
						script
					}}
				/>
			</ErrorBoundary>
			<AppLayout script={script} onScriptChange={(newScript) => {
				setScript(newScript);
				setPreviewKey(prev => prev + 1);
			}}>
				{/* Left Sidebar - Components Panel */}
				<div style={{
					display: 'flex',
					flexDirection: 'column',
					gap: theme.spacing.lg,
					backgroundColor: theme.colors.background.secondary,
					borderRadius: theme.borderRadius.lg,
					padding: theme.spacing.lg,
					boxShadow: theme.shadows.md,
					height: 'fit-content',
					position: 'sticky',
					top: theme.spacing.lg,
					width: '250px', // Fixed width for consistency
					minWidth: '250px', // Prevent shrinking
				}}>
					<div style={{
						display: 'flex',
						justifyContent: 'space-between',
						alignItems: 'center',
						padding: `${theme.spacing.sm} ${theme.spacing.md}`,
						backgroundColor: theme.colors.background.tertiary,
						borderRadius: theme.borderRadius.md,
					}}>
						<h2 style={{
							margin: 0,
							fontSize: theme.fontSizes.xl,
							fontFamily: theme.fonts.heading,
							color: theme.colors.text.primary,
						}}>Components</h2>
						<IconButton
							icon="📋"
							onClick={() => setIsTemplateManagerOpen(true)}
							tooltip="Templates"
							variant="ghost"
						/>
					</div>
					<ComponentPalette onDragStart={handleDragStart} />
				</div>

				{/* Center Content */}
				<div style={{
					display: 'flex',
					flexDirection: 'column',
					gap: theme.spacing.xl,
					width: '100%',
				}}>
					{/* Preview Section */}
					<div style={{
						backgroundColor: theme.colors.background.tertiary,
						borderRadius: theme.borderRadius.lg,
						overflow: 'hidden',
						padding: theme.spacing.lg,
						boxShadow: theme.shadows.lg,
						height: '65vh',
						minHeight: '500px',
					}}>
						<div style={{
							position: 'relative',
							width: '100%',
							height: '100%',
							backgroundColor: theme.colors.background.primary,
							borderRadius: theme.borderRadius.md,
							overflow: 'hidden',
							boxShadow: 'inset 0 0 10px rgba(0,0,0,0.1)',
						}}>
							<SafeVideoPreview key={previewKey} script={script} />
						</div>
					</div>

					{/* Timeline Section */}
					<div style={{
						backgroundColor: theme.colors.background.secondary,
						borderRadius: theme.borderRadius.lg,
						padding: theme.spacing.lg,
						boxShadow: theme.shadows.md,
					}}>
						{/* Timeline Controls */}
						<div style={{
							display: 'flex',
							justifyContent: 'space-between',
							alignItems: 'center',
							padding: `${theme.spacing.sm} ${theme.spacing.md}`,
							backgroundColor: theme.colors.background.tertiary,
							borderRadius: theme.borderRadius.md,
							marginBottom: theme.spacing.md,
						}}>
							<div style={{ display: 'flex', gap: theme.spacing.sm }}>
								<h3 style={{
									margin: 0,
									fontSize: theme.fontSizes.lg,
									fontFamily: theme.fonts.heading,
									color: theme.colors.text.primary,
									marginRight: theme.spacing.md,
								}}>Timeline</h3>
								<IconButton
									icon="⏮"
									onClick={() => playerRef.current?.seekTo(0)}
									tooltip="Go to Start"
									variant="ghost"
								/>
								<IconButton
									icon="⏪"
									onClick={() => {
										const frame = Math.max(0, currentFrame - 30);
										playerRef.current?.seekTo(frame);
										setCurrentFrame(frame);
									}}
									tooltip="Back 1 Second"
									variant="ghost"
								/>
								<IconButton
									icon="⏩"
									onClick={() => {
										const frame = Math.min(300, currentFrame + 30);
										playerRef.current?.seekTo(frame);
										setCurrentFrame(frame);
									}}
									tooltip="Forward 1 Second"
									variant="ghost"
								/>
							</div>
							<div style={{ display: 'flex', gap: theme.spacing.sm }}>
								<IconButton
									icon="🔍-"
									onClick={() => setTimelineZoom(prev => Math.max(0.5, prev - 0.1))}
									tooltip="Zoom Out"
									variant="ghost"
								/>
								<IconButton
									icon="🔍+"
									onClick={() => setTimelineZoom(prev => Math.min(2, prev + 0.1))}
									tooltip="Zoom In"
									variant="ghost"
								/>
							</div>
						</div>

						{/* Main Timeline */}
						<Timeline
							script={script}
							onReorder={handleReorder}
							onSelect={setSelectedComponentId}
							selectedId={selectedComponentId}
							onDelete={handleComponentDelete}
						/>

						{/* Captions Timeline */}
						<CaptionTimeline
							script={script}
							onScriptChange={setScript}
						/>
					</div>
				</div>

				{/* Right Sidebar - Properties Panel */}
				<div style={{
					backgroundColor: theme.colors.background.secondary,
					borderRadius: theme.borderRadius.lg,
					padding: theme.spacing.lg,
					boxShadow: theme.shadows.md,
					height: 'fit-content',
					maxHeight: 'calc(100vh - 40px)',
					position: 'sticky',
					top: theme.spacing.lg,
					overflow: 'auto',
					width: '300px', // Fixed width for consistency
					minWidth: '300px', // Prevent shrinking
				}}>
					<div style={{
						padding: `${theme.spacing.sm} ${theme.spacing.md}`,
						backgroundColor: theme.colors.background.tertiary,
						borderRadius: theme.borderRadius.md,
						marginBottom: theme.spacing.lg,
					}}>
						<h2 style={{
							margin: 0,
							fontSize: theme.fontSizes.xl,
							fontFamily: theme.fonts.heading,
							color: theme.colors.text.primary,
						}}>Properties</h2>
					</div>
					{selectedComponent && (
						<ComponentEditor
							component={selectedComponent}
							onChange={handleComponentChange}
							onDelete={() => handleComponentDelete(selectedComponent.id)}
							onEditPosition={setEditingTextPosition}
						/>
					)}
				</div>
			</AppLayout>

			{/* Template Manager Modal */}
			<Modal
				isOpen={isTemplateManagerOpen}
				onClose={() => setIsTemplateManagerOpen(false)}
				title={
					<h2 style={{
						...commonStyles.heading,
						margin: 0,
						display: 'flex',
						alignItems: 'center',
						gap: theme.spacing.sm,
						color: theme.colors.text.primary,
						fontSize: theme.fontSizes.xl,
						fontFamily: theme.fonts.heading,
					}}>
						 Templates
					</h2>
				}
			>
				<TemplateManager
					currentScript={script}
					onTemplateSelect={(newScript) => {
						setScript(newScript);
						setIsTemplateManagerOpen(false);
					}}
				/>
			</Modal>

			{/* Component Editor Modal (for mobile/tablet) */}
			<Modal
				isOpen={!!selectedComponentId && window.innerWidth < 1024}
				onClose={() => setSelectedComponentId(undefined)}
				title={
					selectedComponent && (
						<h2 style={{
							...commonStyles.heading,
							margin: 0,
							display: 'flex',
							alignItems: 'center',
							gap: theme.spacing.sm,
							color: theme.colors.text.primary,
							fontSize: theme.fontSizes.xl,
							fontFamily: theme.fonts.heading,
						}}>
							<span style={{ fontSize: '1.2em' }}>
								{selectedComponent.type === 'title' && '📑'}
								{selectedComponent.type === 'text' && '📝'}
								{selectedComponent.type === 'comparison' && '⚖️'}
								{selectedComponent.type === 'countdown' && '⏲️'}
								{selectedComponent.type === 'transition' && '🔄'}
								{selectedComponent.type === 'voice' && '🎙️'}
							</span>
							Edit {selectedComponent.type.charAt(0).toUpperCase() + selectedComponent.type.slice(1)}
						</h2>
					)
				}
			>
				{selectedComponent && (
					<ComponentEditor
						component={selectedComponent}
						onChange={handleComponentChange}
						onDelete={() => handleComponentDelete(selectedComponent.id)}
					/>
				)}
			</Modal>
		</>
	);
};



--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\ScriptVideo.tsx ---

import {AbsoluteFill} from 'remotion';
import {loadFont} from '@remotion/google-fonts/Roboto';
import React, {useEffect} from 'react';
import {Script} from './types/script';

const {fontFamily} = loadFont();

export const ScriptVideo: React.FC<{
  script: Script;
}> = ({script}) => {
  // Ensure script has required properties
  if (!script?.components) {
    console.error('Script is missing components array:', script);
    return (
      <AbsoluteFill style={{
        backgroundColor: '#000000',
        color: '#ffffff',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        fontFamily
      }}>
        No components to render
      </AbsoluteFill>
    );
  }

  // Preload fonts
  useEffect(() => {
    const fonts = [fontFamily];
    if (script.settings?.font) {
      fonts.push(script.settings.font);
    }
    
    // Force font loading before render
    const preloadFonts = async () => {
      await Promise.all(
        fonts.map((font) => 
          document.fonts.load(`16px "${font}"`)
        )
      );
    };
    
    preloadFonts();
  }, [script.settings?.font]);

  const components = script.components || [];

  return (
    <AbsoluteFill
      style={{
        backgroundColor: script.settings?.backgroundColor || '#000000',
        fontFamily: script.settings?.font || fontFamily,
        color: script.settings?.textColor || '#ffffff',
      }}
    >
      {components.map((component) => (
        // Render your components here
        <div key={component.id}>
          {/* Component rendering logic */}
        </div>
      ))}
    </AbsoluteFill>
  );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\Video.tsx ---

import {Composition} from 'remotion';
import {QuizVideo} from './QuizVideo';

export const RemotionVideo: React.FC = () => {
	return (
		<Composition
			id="QuizVideo"
			component={QuizVideo}
			durationInFrames={1800} // 60 seconds at 30fps
			fps={30}
			width={1080}
			height={1920} // 9:16 aspect ratio for vertical video
			defaultProps={{
				quizConfig: {
					comparisons: []
				}
			}}
		/>
	);
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Comparison.tsx ---

import {
	AbsoluteFill,
	useCurrentFrame,
	interpolate,
	spring,
	useVideoConfig,
} from 'remotion';
import {Timer} from './Timer';
import {QuizItem} from '../data/quizData';

interface ComparisonProps {
	data: QuizItem;
	startFrame: number;
}

export const Comparison: React.FC<ComparisonProps> = ({data, startFrame}) => {
	const frame = useCurrentFrame();
	const {fps} = useVideoConfig();
	const relativeFrame = frame - startFrame;
	
	const opacity = spring({
		frame: relativeFrame,
		fps,
		config: {
			damping: 200,
		},
	});

	if (relativeFrame < 0 || relativeFrame > 150) return null;

	return (
		<AbsoluteFill>
			<div style={{
				opacity,
				display: 'flex',
				flexDirection: 'column',
				alignItems: 'center',
				padding: 40,
			}}>
				<h1 style={{
					fontSize: 60,
					color: 'white',
					textAlign: 'center',
					marginBottom: 40,
				}}>
					{data.question}
				</h1>
				
				<div style={{
					display: 'flex',
					width: '100%',
					justifyContent: 'space-between',
				}}>
					{/* Left Option */}
					<div style={{flex: 1, padding: 20}}>
						<img
							src={data.leftOption.image}
							style={{
								width: '100%',
								height: 'auto',
								borderRadius: 20,
							}}
						/>
						<h2 style={{
							color: 'white',
							textAlign: 'center',
							fontSize: 40,
						}}>
							{data.leftOption.text}
						</h2>
					</div>

					{/* Right Option */}
					<div style={{flex: 1, padding: 20}}>
						<img
							src={data.rightOption.image}
							style={{
								width: '100%',
								height: 'auto',
								borderRadius: 20,
							}}
						/>
						<h2 style={{
							color: 'white',
							textAlign: 'center',
							fontSize: 40,
						}}>
							{data.rightOption.text}
						</h2>
					</div>
				</div>

				<Timer startFrame={startFrame} />
			</div>
		</AbsoluteFill>
	);
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ComparisonEditor.tsx ---

import React from 'react';
import {Comparison} from '../types/quiz';
import { ImageSelector } from './ImageSelector';

interface ComparisonEditorProps {
	comparison: Comparison;
	onChange: (updatedComparison: Comparison) => void;
	onDelete: () => void;
}

export const ComparisonEditor: React.FC<ComparisonEditorProps> = ({
	comparison,
	onChange,
	onDelete,
}) => {
	return (
		<div style={{
			padding: '20px',
			border: '1px solid #ccc',
			borderRadius: '8px',
			backgroundColor: '#f8f9fa',
		}}>
			{/* Question Section */}
			<div style={{marginBottom: '20px'}}>
				<label style={{display: 'block', marginBottom: '8px', fontWeight: 'bold'}}>
					Question:
				</label>
				<input
					type="text"
					value={comparison.question}
					onChange={(e) => {
						onChange({
							...comparison,
							question: e.target.value,
						});
					}}
					style={{
						width: '100%',
						padding: '8px',
						fontSize: '16px',
						borderRadius: '4px',
						border: '1px solid #ddd',
					}}
					placeholder="Enter your question..."
				/>
			</div>

			{/* Options Section */}
			<div style={{
				display: 'grid',
				gridTemplateColumns: '1fr 1fr',
				gap: '20px',
			}}>
				{/* Left Option */}
				<div>
					<label style={{display: 'block', marginBottom: '8px', fontWeight: 'bold'}}>
						Left Option:
					</label>
					<input
						type="text"
						value={comparison.leftOption.text}
						onChange={(e) => {
							onChange({
								...comparison,
								leftOption: {
									...comparison.leftOption,
									text: e.target.value,
								},
							});
						}}
						style={{
							width: '100%',
							padding: '8px',
							fontSize: '16px',
							borderRadius: '4px',
							border: '1px solid #ddd',
							marginBottom: '10px',
						}}
						placeholder="Enter left option..."
					/>
					{/* Left Option Image Selection */}
					<ImageSelector
						searchTerm={comparison.leftOption.text}
						onSelect={(imageUrl) => {
							onChange({
								...comparison,
								leftOption: {
									...comparison.leftOption,
									imageUrl,
								},
							});
						}}
						currentImageUrl={comparison.leftOption.imageUrl}
					/>
				</div>

				{/* Right Option */}
				<div>
					<label style={{display: 'block', marginBottom: '8px', fontWeight: 'bold'}}>
						Right Option:
					</label>
					<input
						type="text"
						value={comparison.rightOption.text}
						onChange={(e) => {
							onChange({
								...comparison,
								rightOption: {
									...comparison.rightOption,
									text: e.target.value,
								},
							});
						}}
						style={{
							width: '100%',
							padding: '8px',
							fontSize: '16px',
							borderRadius: '4px',
							border: '1px solid #ddd',
							marginBottom: '10px',
						}}
						placeholder="Enter right option..."
					/>
					{/* Right Option Image Selection */}
					<ImageSelector
						searchTerm={comparison.rightOption.text}
						onSelect={(imageUrl) => {
							onChange({
								...comparison,
								rightOption: {
									...comparison.rightOption,
									imageUrl,
								},
							});
						}}
						currentImageUrl={comparison.rightOption.imageUrl}
					/>
				</div>
			</div>

			{/* Delete Button */}
			<button
				onClick={onDelete}
				style={{
					marginTop: '20px',
					padding: '8px 16px',
					backgroundColor: '#dc3545',
					color: 'white',
					border: 'none',
					borderRadius: '4px',
					cursor: 'pointer',
				}}
			>
				Delete Comparison
			</button>
		</div>
	);
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ConfigMenu\ConfigMenu.tsx ---

import React, { useState, useEffect } from 'react';
import { Modal } from '../common/Modal';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';
import { ImageSelector } from '../Setup/ImageSelector';
import { Script } from '../../types/script';
import { useConfigStore } from '../../store/configStore';
import { useVideoConfig } from 'remotion';
import { useApiKeys } from '../../store/apiKeysStore';
import { FontManager } from '../Settings/FontManager';
import { BackgroundManager } from '../Settings/BackgroundManager';

interface ConfigMenuProps {
    isOpen: boolean;
    onClose: () => void;
    script: Script;
    onScriptChange: (script: Script) => void;
}

interface ExportSettings {
    fps: number;
    width: number;
    height: number;
    codec: 'h264' | 'h265' | 'vp8' | 'vp9';
    quality: number;
}

export const ConfigMenu: React.FC<ConfigMenuProps> = ({
    isOpen,
    onClose,
    script,
    onScriptChange,
}) => {
    const fps = 30;
    const { 
        elevenLabsApiKey, 
        pexelsApiKey, 
        setElevenLabsApiKey,
        setPexelsApiKey,
    } = useApiKeys();

    const [localElevenLabsKey, setLocalElevenLabsKey] = useState(elevenLabsApiKey);
    const [localPexelsKey, setLocalPexelsKey] = useState(pexelsApiKey);
    const [showKeys, setShowKeys] = useState(false);
    const [isFontManagerOpen, setIsFontManagerOpen] = useState(false);
    const [showBackgroundManager, setShowBackgroundManager] = useState(false);
    const [saving, setSaving] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [exportSettings, setExportSettings] = useState<ExportSettings>({
        fps: 30,
        width: 1920,
        height: 1080,
        codec: 'h264',
        quality: 100
    });

    useEffect(() => {
        // Load initial config
        fetch('http://localhost:5003/config')
            .then(res => res.json())
            .then(data => {
                setLocalPexelsKey(data.pexels_api_key || '');
            })
            .catch(err => {
                console.error('Failed to load config:', err);
                setError('Failed to load configuration');
            });
    }, []);

    const handleSave = () => {
        setElevenLabsApiKey(localElevenLabsKey);
        setPexelsApiKey(localPexelsKey);
        
        // Also update the image service config
        fetch('http://localhost:5003/config', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                pexels_api_key: localPexelsKey,
            }),
        }).catch(err => {
            console.error('Failed to update image service config:', err);
        });
        
        onClose();
    };

    const handleBackgroundChange = () => {
        // Create a file input
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*,video/*';
        
        // Handle file selection
        input.onchange = async (e: Event) => {
            const file = (e.target as HTMLInputElement).files?.[0];
            if (!file) return;

            console.log('Selected file:', file.name, file.type);

            // Create form data
            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('http://localhost:3002/set_background', {
                    method: 'POST',
                    body: formData,
                });

                if (!response.ok) {
                    throw new Error('Failed to upload background');
                }

                const { filePath } = await response.json();

                // Update script with new background settings
                const backgroundType = file.type.startsWith('video/') ? 'video' as const : 'image' as const;
                const updatedScript = {
                    ...script,
                    settings: {
                        ...script.settings,
                        background: {
                            type: backgroundType,
                            url: filePath,
                            filePath: file.name,
                            ...(backgroundType === 'video' ? { durationInFrames: 300 } : {})
                        }
                    }
                };

                onScriptChange(updatedScript);
            } catch (error) {
                console.error('Error uploading background:', error);
            }
        };

        // Trigger file selection
        input.click();
    };

    const handleSaveConfig = async () => {
        setSaving(true);
        setError(null);

        try {
            const response = await fetch('http://localhost:5003/config', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    pexels_api_key: pexelsApiKey,
                }),
            });

            if (!response.ok) {
                throw new Error('Failed to save configuration');
            }

            // Show success message or update UI as needed
        } catch (err) {
            console.error('Failed to save config:', err);
            setError(err instanceof Error ? err.message : 'Failed to save configuration');
        } finally {
            setSaving(false);
        }
    };

    return (
        <>
            <Modal
                isOpen={isOpen}
                onClose={onClose}
                title={
                    <h2 style={{
                        ...commonStyles.heading,
                        margin: 0,
                        display: 'flex',
                        alignItems: 'center',
                        gap: theme.spacing.sm,
                        color: theme.colors.text.primary,
                        fontSize: '20px',
                    }}>
                        ⚙️ Settings
                    </h2>
                }
            >
                <div style={{
                    display: 'flex',
                    flexDirection: 'column',
                    gap: theme.spacing.md,
                }}>
                    {/* API Key Settings */}
                    <div>
                        <h3 style={commonStyles.heading}>API Keys</h3>
                        <div style={{
                            display: 'flex',
                            justifyContent: 'space-between',
                            alignItems: 'center',
                            marginBottom: '10px',
                        }}>
                            <label style={{ color: theme.colors.text.primary }}>Show API Keys:</label>
                            <input
                                type="checkbox"
                                checked={showKeys}
                                onChange={(e) => setShowKeys(e.target.checked)}
                            />
                        </div>

                        <div style={{ marginBottom: '16px' }}>
                            <label style={{
                                display: 'block',
                                color: theme.colors.text.primary,
                                marginBottom: '8px',
                            }}>
                                ElevenLabs API Key:
                            </label>
                            <input
                                type={showKeys ? 'text' : 'password'}
                                value={localElevenLabsKey}
                                onChange={(e) => setLocalElevenLabsKey(e.target.value)}
                                style={{
                                    width: '100%',
                                    padding: '8px',
                                    backgroundColor: theme.colors.background.secondary,
                                    border: `1px solid ${theme.colors.border}`,
                                    borderRadius: theme.borderRadius.sm,
                                    color: theme.colors.text.primary,
                                }}
                                placeholder="Enter your ElevenLabs API key"
                            />
                        </div>

                        <div style={{ marginBottom: '16px' }}>
                            <label style={{
                                display: 'block',
                                color: theme.colors.text.primary,
                                marginBottom: '8px',
                            }}>
                                Pexels API Key:
                            </label>
                            <input
                                type={showKeys ? 'text' : 'password'}
                                value={localPexelsKey}
                                onChange={(e) => setLocalPexelsKey(e.target.value)}
                                style={{
                                    width: '100%',
                                    padding: '8px',
                                    backgroundColor: theme.colors.background.secondary,
                                    border: `1px solid ${theme.colors.border}`,
                                    borderRadius: theme.borderRadius.sm,
                                    color: theme.colors.text.primary,
                                }}
                                placeholder="Enter your Pexels API key"
                            />
                        </div>
                    </div>

                    {/* Background Settings */}
                    <div>
                        <h3 style={commonStyles.heading}>Background</h3>
                        <div style={{
                            display: 'flex',
                            flexDirection: 'column',
                            gap: theme.spacing.sm,
                        }}>
                            <button
                                onClick={() => setShowBackgroundManager(true)}
                                style={commonStyles.button.secondary}
                            >
                                Manage Backgrounds
                            </button>
                            {script.settings.background?.url && (
                                <button
                                    onClick={() => onScriptChange({
                                        ...script,
                                        settings: {
                                            ...script.settings,
                                            background: {
                                                type: 'none',
                                            },
                                        },
                                    })}
                                    style={{
                                        ...commonStyles.button.secondary,
                                        color: theme.colors.error,
                                    }}
                                >
                                    Reset to Default
                                </button>
                            )}
                            {script.settings.background?.type === 'video' && (
                                <div style={{
                                    color: theme.colors.text.secondary,
                                    fontSize: '0.9em',
                                    marginTop: theme.spacing.sm,
                                }}>
                                    Note: Video will loop if timeline exceeds video length
                                </div>
                            )}
                        </div>
                    </div>

                    {/* Font Manager Button */}
                    <div>
                        <button
                            onClick={() => setIsFontManagerOpen(true)}
                            style={{
                                ...commonStyles.button,
                                width: '100%',
                                padding: theme.spacing.md,
                                backgroundColor: theme.colors.primary,
                                color: theme.colors.text.primary,
                            }}
                        >
                            Manage Custom Fonts
                        </button>
                    </div>

                    {/* Export Settings */}
                    <div>
                        <h3 style={commonStyles.heading}>Export Settings</h3>
                        <div style={{
                            display: 'grid',
                            gridTemplateColumns: '1fr 1fr',
                            gap: theme.spacing.sm,
                        }}>
                            <div>
                                <label style={styles.label}>FPS:</label>
                                <input
                                    type="number"
                                    value={exportSettings.fps}
                                    onChange={(e) => setExportSettings({
                                        ...exportSettings,
                                        fps: Number(e.target.value)
                                    })}
                                    min={1}
                                    max={60}
                                    style={styles.input}
                                />
                            </div>
                            <div>
                                <label style={styles.label}>Quality (%):</label>
                                <input
                                    type="number"
                                    value={exportSettings.quality}
                                    onChange={(e) => setExportSettings({
                                        ...exportSettings,
                                        quality: Number(e.target.value)
                                    })}
                                    min={1}
                                    max={100}
                                    style={styles.input}
                                />
                            </div>
                            <div>
                                <label style={styles.label}>Width:</label>
                                <input
                                    type="number"
                                    value={exportSettings.width}
                                    onChange={(e) => setExportSettings({
                                        ...exportSettings,
                                        width: Number(e.target.value)
                                    })}
                                    min={100}
                                    max={3840}
                                    step={2}
                                    style={styles.input}
                                />
                            </div>
                            <div>
                                <label style={styles.label}>Height:</label>
                                <input
                                    type="number"
                                    value={exportSettings.height}
                                    onChange={(e) => setExportSettings({
                                        ...exportSettings,
                                        height: Number(e.target.value)
                                    })}
                                    min={100}
                                    max={2160}
                                    step={2}
                                    style={styles.input}
                                />
                            </div>
                            <div style={{ gridColumn: '1 / -1' }}>
                                <label style={styles.label}>Codec:</label>
                                <select
                                    value={exportSettings.codec}
                                    onChange={(e) => setExportSettings({
                                        ...exportSettings,
                                        codec: e.target.value as ExportSettings['codec']
                                    })}
                                    style={styles.select}
                                >
                                    <option value="h264">H.264</option>
                                    <option value="h265">H.265 (HEVC)</option>
                                    <option value="vp8">VP8</option>
                                    <option value="vp9">VP9</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    {/* Save Button */}
                    <div style={{
                        display: 'flex',
                        justifyContent: 'flex-end',
                        gap: theme.spacing.sm,
                        marginTop: theme.spacing.md,
                    }}>
                        <button
                            onClick={onClose}
                            style={commonStyles.button.secondary}
                        >
                            Cancel
                        </button>
                        <button
                            onClick={handleSave}
                            style={commonStyles.button.primary}
                        >
                            Save
                        </button>
                    </div>
                </div>
            </Modal>

            {/* Background Manager Modal */}
            {showBackgroundManager && (
                <Modal
                    isOpen={showBackgroundManager}
                    onClose={() => setShowBackgroundManager(false)}
                    title="Background Manager"
                >
                    <BackgroundManager
                        onSelectBackground={(background) => {
                            onScriptChange({
                                ...script,
                                settings: {
                                    ...script.settings,
                                    background: background
                                }
                            });
                            setShowBackgroundManager(false);
                        }}
                    />
                </Modal>
            )}

            {/* Font Manager Modal */}
            {isFontManagerOpen && (
                <FontManager onClose={() => setIsFontManagerOpen(false)} />
            )}
        </>
    );
};

const styles = {
    label: {
        display: 'block',
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
        marginBottom: theme.spacing.xs,
    },
    input: {
        width: '100%',
        padding: theme.spacing.sm,
        backgroundColor: theme.colors.background.secondary,
        border: `1px solid ${theme.colors.border}`,
        borderRadius: theme.borderRadius.sm,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
    },
    select: {
        width: '100%',
        padding: theme.spacing.sm,
        backgroundColor: theme.colors.background.secondary,
        border: `1px solid ${theme.colors.border}`,
        borderRadius: theme.borderRadius.sm,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ImageSelector.tsx ---

import React, { useState, useEffect } from 'react';
import { createClient, Photo } from 'pexels';
import { theme } from '../styles/theme';

const client = createClient('rXEDE5m6pUxOXZPawHmzKj04Z29WlV2y0Us44ld2TmXwdZstXtHUIh2F');

interface ImageSelectorProps {
    searchTerm: string;
    onSelect: (imageUrl: string) => void;
    currentImageUrl?: string;
    orientation?: 'portrait' | 'landscape' | 'square';
}

export const ImageSelector: React.FC<ImageSelectorProps> = ({
    searchTerm,
    onSelect,
    currentImageUrl,
    orientation = 'landscape'
}) => {
    const [images, setImages] = useState<Photo[]>([]);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [page, setPage] = useState(1);
    const [totalPages, setTotalPages] = useState(1);
    const perPage = 6;

    useEffect(() => {
        if (!searchTerm) return;

        const searchImages = async () => {
            setLoading(true);
            setError(null);
            try {
                const result = await client.photos.search({
                    query: searchTerm,
                    per_page: perPage,
                    page,
                    orientation
                });
                setImages(result.photos || []);
                setTotalPages(Math.ceil((result.total_results || 0) / perPage));
            } catch (err) {
                setError('Failed to load images');
                console.error(err);
            } finally {
                setLoading(false);
            }
        };

        searchImages();
    }, [searchTerm, page, orientation]);

    return (
        <div style={styles.container}>
            {loading && <div style={styles.loading}>Loading images...</div>}
            {error && <div style={styles.error}>{error}</div>}
            
            <div style={styles.grid}>
                {images.map((photo) => (
                    <div
                        key={photo.id}
                        style={{
                            ...styles.imageContainer,
                            border: currentImageUrl === photo.src.medium ? `3px solid ${theme.colors.primary}` : '1px solid #ddd',
                        }}
                        onClick={() => onSelect(photo.src.medium)}
                    >
                        <img
                            src={photo.src.medium}
                            alt={photo.alt || 'Option image'}
                            style={styles.image}
                        />
                        <div style={styles.imageOverlay}>
                            <span>Select</span>
                        </div>
                    </div>
                ))}
            </div>

            {totalPages > 1 && (
                <div style={styles.pagination}>
                    <button
                        onClick={() => setPage(p => Math.max(1, p - 1))}
                        disabled={page === 1}
                        style={{
                            ...styles.button,
                            opacity: page === 1 ? 0.5 : 1
                        }}
                    >
                        Previous
                    </button>
                    <span style={styles.pageInfo}>
                        Page {page} of {totalPages}
                    </span>
                    <button
                        onClick={() => setPage(p => Math.min(totalPages, p + 1))}
                        disabled={page === totalPages}
                        style={{
                            ...styles.button,
                            opacity: page === totalPages ? 0.5 : 1
                        }}
                    >
                        Next
                    </button>
                </div>
            )}
        </div>
    );
};

const styles = {
    container: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.md,
    },
    loading: {
        textAlign: 'center' as const,
        padding: theme.spacing.md,
        color: theme.colors.text.secondary,
    },
    error: {
        textAlign: 'center' as const,
        padding: theme.spacing.md,
        color: theme.colors.error,
    },
    grid: {
        display: 'grid',
        gridTemplateColumns: 'repeat(2, 1fr)',
        gap: theme.spacing.md,
    },
    imageContainer: {
        position: 'relative' as const,
        cursor: 'pointer',
        borderRadius: theme.borderRadius.md,
        overflow: 'hidden',
        aspectRatio: '16/9',
        transition: 'transform 0.2s ease-in-out',
        '&:hover': {
            transform: 'scale(1.02)',
        },
    },
    image: {
        width: '100%',
        height: '100%',
        objectFit: 'cover' as const,
    },
    imageOverlay: {
        position: 'absolute' as const,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        background: 'rgba(0, 0, 0, 0.5)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        color: '#fff',
        opacity: 0,
        transition: 'opacity 0.2s ease-in-out',
        '&:hover': {
            opacity: 1,
        },
    },
    pagination: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        gap: theme.spacing.md,
        marginTop: theme.spacing.md,
    },
    pageInfo: {
        color: theme.colors.text.secondary,
    },
    button: {
        padding: `${theme.spacing.sm} ${theme.spacing.md}`,
        backgroundColor: theme.colors.primary,
        color: '#fff',
        border: 'none',
        borderRadius: theme.borderRadius.sm,
        cursor: 'pointer',
        '&:disabled': {
            cursor: 'not-allowed',
        },
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Layout\AppLayout.tsx ---

import React, { useState } from 'react';
import { theme } from '../../styles/theme';
import { ConfigMenu } from '../ConfigMenu/ConfigMenu';
import { Script } from '../../types/script';
import { exportVideo } from '../../services/videoService';

interface AppLayoutProps {
    children: [React.ReactNode, React.ReactNode, React.ReactNode]; // Left, Center, Right content
    script: Script;
    onScriptChange: (script: Script) => void;
}

export const AppLayout: React.FC<AppLayoutProps> = ({ 
    children: [leftContent, centerContent, rightContent],
    script,
    onScriptChange,
}) => {
    const [isConfigOpen, setIsConfigOpen] = useState(false);
    const [isExporting, setIsExporting] = useState(false);

    const handleExportVideo = async () => {
        try {
            console.log('Starting video export...');
            console.log('Script data:', script);
            setIsExporting(true);
            const outputLocation = await exportVideo(script, {
                fps: 30,
                width: 1080,
                height: 1920,
                codec: 'h264',
                quality: 100
            });
            console.log('Video exported successfully to:', outputLocation);
            alert(`Video exported successfully to: ${outputLocation}`);
        } catch (error) {
            console.error('Error exporting video:', error);
            alert('Failed to export video. Check console for details.');
        } finally {
            setIsExporting(false);
        }
    };

    return (
        <div style={{
            minHeight: '100vh',
            backgroundColor: theme.colors.background.primary,
            color: theme.colors.text.primary,
            display: 'grid',
            gridTemplateRows: 'auto 1fr',
            overflowX: 'hidden',
        }}>
            {/* Header */}
            <header style={{
                backgroundColor: theme.colors.background.secondary,
                borderBottom: `1px solid ${theme.colors.border}`,
                padding: `${theme.spacing.md} ${theme.spacing.xl}`,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between',
                boxShadow: theme.shadows.md,
                position: 'sticky',
                top: 0,
                zIndex: 100,
            }}>
                <div style={{ display: 'flex', alignItems: 'center', gap: theme.spacing.md }}>
                    <h1 style={{ 
                        margin: 0, 
                        fontSize: '24px',
                        background: `linear-gradient(135deg, ${theme.colors.primary}, ${theme.colors.secondary})`,
                        WebkitBackgroundClip: 'text',
                        WebkitTextFillColor: 'transparent',
                        fontWeight: 'bold',
                    }}>
                        Couples Quiz Creator
                    </h1>
                </div>
                <nav style={{
                    display: 'flex',
                    gap: theme.spacing.lg,
                }}>
                    <button style={{
                        ...commonButtonStyle,
                        backgroundColor: 'transparent',
                        color: theme.colors.text.primary,
                    }}
                    onClick={() => setIsConfigOpen(true)}
                    >
                        ⚙️ Settings
                    </button>
                    <button style={{
                        ...commonButtonStyle,
                        backgroundColor: theme.colors.primary,
                        color: theme.colors.text.primary,
                        opacity: isExporting ? 0.7 : 1,
                        cursor: isExporting ? 'not-allowed' : 'pointer',
                    }}
                    onClick={handleExportVideo}
                    disabled={isExporting}
                    >
                        {isExporting ? 'Exporting...' : 'Export Video'}
                    </button>
                </nav>
            </header>

            {/* Main Content */}
            <main style={{
                padding: `${theme.spacing.lg} ${theme.spacing.lg}`,
                display: 'grid',
                gridTemplateColumns: '280px 1fr minmax(500px, 800px)',
                gap: theme.spacing.lg,
                height: 'calc(100vh - 80px)', // Subtract header height
                position: 'relative',
                overflow: 'hidden', // Prevent content from expanding outside
            }}>
                {/* Left Sidebar - Component Palette */}
                <aside style={{
                    backgroundColor: theme.colors.background.secondary,
                    borderRadius: theme.borderRadius.lg,
                    padding: theme.spacing.md,
                    boxShadow: theme.shadows.md,
                    border: `1px solid ${theme.colors.border}`,
                    position: 'sticky',
                    top: '80px',
                    height: 'fit-content',
                    maxHeight: 'calc(100vh - 100px)',
                    overflowY: 'auto',
                }}>
                    {leftContent}
                </aside>

                {/* Center Content - Preview */}
                <div style={{
                    backgroundColor: theme.colors.background.secondary,
                    borderRadius: theme.borderRadius.lg,
                    padding: theme.spacing.md,
                    boxShadow: theme.shadows.md,
                    border: `1px solid ${theme.colors.border}`,
                    display: 'flex',
                    flexDirection: 'column',
                    gap: theme.spacing.md,
                    overflowY: 'auto',
                }}>
                    {centerContent}
                </div>

                {/* Right Sidebar - Properties */}
                <aside style={{
                    backgroundColor: theme.colors.background.secondary,
                    borderRadius: theme.borderRadius.lg,
                    padding: theme.spacing.md,
                    boxShadow: theme.shadows.md,
                    border: `1px solid ${theme.colors.border}`,
                    position: 'sticky',
                    top: '80px',
                    height: 'calc(100vh - 100px)',
                    overflowY: 'auto',
                }}>
                    {rightContent}
                </aside>
            </main>

            {/* Config Menu */}
            <ConfigMenu
                isOpen={isConfigOpen}
                onClose={() => setIsConfigOpen(false)}
                script={script}
                onScriptChange={onScriptChange}
            />
        </div>
    );
};

// Common styles
const commonButtonStyle = {
    padding: `${theme.spacing.sm} ${theme.spacing.lg}`,
    borderRadius: theme.borderRadius.md,
    border: 'none',
    cursor: 'pointer',
    fontWeight: 'bold',
    transition: 'all 0.2s ease',
    '&:hover': {
        opacity: 0.9,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\QuizSetup.tsx ---

import React from 'react';
import { Photo } from 'pexels';
import { ImageSelector } from './ImageSelector';
import { QuizItem } from '../data/quizData';

interface QuizSetupProps {
  onSave: (quizData: QuizItem[]) => void;
}

export const QuizSetup: React.FC<QuizSetupProps> = ({ onSave }) => {
  const [quizItems, setQuizItems] = React.useState<QuizItem[]>([]);
  const [currentItem, setCurrentItem] = React.useState(0);
  const [selectingFor, setSelectingFor] = React.useState<'left' | 'right' | null>(null);

  const handleImageSelect = (photo: Photo) => {
    if (!selectingFor) return;

    setQuizItems((prev) => {
      const updated = [...prev];
      updated[currentItem] = {
        ...updated[currentItem],
        [selectingFor === 'left' ? 'leftOption' : 'rightOption']: {
          ...updated[currentItem][selectingFor === 'left' ? 'leftOption' : 'rightOption'],
          image: photo.src.large,
          pexelsPhoto: photo,
        },
      };
      return updated;
    });

    setSelectingFor(null);
  };

  return (
    <div>
      {selectingFor && (
        <ImageSelector
          onSelect={handleImageSelect}
          searchQuery={
            selectingFor === 'left'
              ? quizItems[currentItem].leftOption.text
              : quizItems[currentItem].rightOption.text
          }
        />
      )}
      
      {/* Add your UI controls for managing quiz items here */}
    </div>
  );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\AudioComponentEditor.tsx ---

import React, { useRef, useState, useEffect } from 'react';
import { AudioComponent } from '../../types/script';
import { theme } from '../../styles/theme';

interface AudioEffect {
    name: string;
    url: string;
}

interface AudioComponentEditorProps {
    component: AudioComponent;
    onChange: (component: AudioComponent) => void;
    onDelete: () => void;
}

export const AudioComponentEditor: React.FC<AudioComponentEditorProps> = ({
    component,
    onChange,
    onDelete,
}) => {
    const fileInputRef = useRef<HTMLInputElement>(null);
    const [effects, setEffects] = useState<AudioEffect[]>([]);
    const [isLoading, setIsLoading] = useState(false);

    // Fetch available effects on mount
    useEffect(() => {
        fetchEffects();
    }, []);

    const fetchEffects = async () => {
        try {
            console.log('Fetching available audio effects...');
            const response = await fetch('http://localhost:3005/effects/dictionary');
            if (!response.ok) throw new Error('Failed to fetch effects');
            const data = await response.json();
            console.log('Available effects:', data);
            setEffects(Object.entries(data).map(([name, url]) => ({ name, url: url as string })));
        } catch (error) {
            console.error('Error fetching effects:', error);
        }
    };

    const handleStyleChange = (key: string, value: number | boolean | undefined) => {
        onChange({
            ...component,
            style: {
                ...component.style,
                [key]: value,
            },
        });
    };

    const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (!file) return;

        setIsLoading(true);
        try {
            console.log('Uploading audio file:', file.name);
            const formData = new FormData();
            formData.append('file', file);

            const response = await fetch('http://localhost:3005/effects/upload', {
                method: 'POST',
                body: formData,
            });

            if (!response.ok) throw new Error('Failed to upload audio file');
            const data = await response.json();
            console.log('Upload successful:', data);

            onChange({
                ...component,
                audioUrl: data.url,
            });

            // Refresh effects list after upload
            await fetchEffects();
        } catch (error) {
            console.error('Error uploading audio file:', error);
            alert('Failed to upload audio file. Please try again.');
        } finally {
            setIsLoading(false);
        }
    };

    const handleEffectSelect = (effect: AudioEffect) => {
        console.log('Selected effect:', effect);
        onChange({
            ...component,
            audioUrl: effect.url,
        });
    };

    const handleEffectDelete = async (effectName: string) => {
        try {
            console.log('Deleting effect:', effectName);
            const response = await fetch('http://localhost:3005/effects/delete', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ name: effectName }),
            });

            if (!response.ok) throw new Error('Failed to delete effect');
            console.log('Effect deleted successfully');
            
            // Refresh effects list after deletion
            await fetchEffects();
        } catch (error) {
            console.error('Error deleting effect:', error);
            alert('Failed to delete effect. Please try again.');
        }
    };

    return (
        <div style={{ display: 'flex', flexDirection: 'column', gap: theme.spacing.md }}>
            <div style={{
                padding: theme.spacing.md,
                backgroundColor: theme.colors.background.tertiary,
                borderRadius: theme.borderRadius.md,
            }}>
                <h3 style={{
                    margin: 0,
                    marginBottom: theme.spacing.sm,
                    fontSize: theme.fontSizes.lg,
                    color: theme.colors.text.primary,
                }}>Audio Settings</h3>

                {/* Audio Source Selection */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <label style={{
                        display: 'block',
                        marginBottom: theme.spacing.xs,
                        color: theme.colors.text.secondary,
                    }}>
                        Audio Source
                    </label>
                    <div style={{ display: 'flex', gap: theme.spacing.sm }}>
                        <button
                            onClick={() => fileInputRef.current?.click()}
                            style={{
                                padding: theme.spacing.sm,
                                backgroundColor: theme.colors.primary,
                                color: theme.colors.text.primary,
                                border: 'none',
                                borderRadius: theme.borderRadius.sm,
                                cursor: 'pointer',
                            }}
                            disabled={isLoading}
                        >
                            {isLoading ? 'Uploading...' : 'Upload Audio File'}
                        </button>
                        <input
                            ref={fileInputRef}
                            type="file"
                            accept="audio/*"
                            onChange={handleFileUpload}
                            style={{ display: 'none' }}
                        />
                    </div>

                    {/* Available Effects */}
                    {effects.length > 0 && (
                        <div style={{ 
                            marginTop: theme.spacing.md,
                            padding: theme.spacing.sm,
                            backgroundColor: theme.colors.background.secondary,
                            borderRadius: theme.borderRadius.sm,
                        }}>
                            <h4 style={{
                                margin: 0,
                                marginBottom: theme.spacing.sm,
                                color: theme.colors.text.primary,
                            }}>Available Effects</h4>
                            <div style={{ display: 'flex', flexDirection: 'column', gap: theme.spacing.xs }}>
                                {effects.map((effect) => (
                                    <div key={effect.name} style={{
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'space-between',
                                        padding: theme.spacing.xs,
                                        backgroundColor: component.audioUrl === effect.url ? theme.colors.primary : 'transparent',
                                        borderRadius: theme.borderRadius.sm,
                                        cursor: 'pointer',
                                    }}>
                                        <span
                                            onClick={() => handleEffectSelect(effect)}
                                            style={{
                                                flex: 1,
                                                color: theme.colors.text.primary,
                                            }}
                                        >
                                            {effect.name}
                                        </span>
                                        <button
                                            onClick={() => handleEffectDelete(effect.name)}
                                            style={{
                                                padding: `${theme.spacing.xs} ${theme.spacing.sm}`,
                                                backgroundColor: theme.colors.warning,
                                                color: theme.colors.text.primary,
                                                border: 'none',
                                                borderRadius: theme.borderRadius.sm,
                                                cursor: 'pointer',
                                                fontSize: '0.8em',
                                            }}
                                        >
                                            Delete
                                        </button>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}

                    {/* URL Input */}
                    <input
                        type="text"
                        value={component.audioUrl}
                        onChange={(e) => onChange({ ...component, audioUrl: e.target.value })}
                        placeholder="Or enter audio URL"
                        style={{
                            width: '100%',
                            marginTop: theme.spacing.sm,
                            padding: theme.spacing.sm,
                            borderRadius: theme.borderRadius.sm,
                            border: `1px solid ${theme.colors.border}`,
                            backgroundColor: theme.colors.background.secondary,
                            color: theme.colors.text.primary,
                        }}
                    />
                </div>

                {/* Volume Control */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <label style={{
                        display: 'block',
                        marginBottom: theme.spacing.xs,
                        color: theme.colors.text.secondary,
                    }}>
                        Volume
                    </label>
                    <input
                        type="range"
                        min="0"
                        max="1"
                        step="0.1"
                        value={component.style?.volume ?? 1}
                        onChange={(e) => handleStyleChange('volume', parseFloat(e.target.value))}
                        style={{ width: '100%' }}
                    />
                </div>

                {/* Start Time */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <label style={{
                        display: 'block',
                        marginBottom: theme.spacing.xs,
                        color: theme.colors.text.secondary,
                    }}>
                        Start Time (seconds)
                    </label>
                    <input
                        type="number"
                        min="0"
                        step="0.1"
                        value={component.style?.startTime ?? 0}
                        onChange={(e) => handleStyleChange('startTime', parseFloat(e.target.value))}
                        style={{
                            width: '100%',
                            padding: theme.spacing.sm,
                            borderRadius: theme.borderRadius.sm,
                            border: `1px solid ${theme.colors.border}`,
                            backgroundColor: theme.colors.background.secondary,
                            color: theme.colors.text.primary,
                        }}
                    />
                </div>

                {/* Duration */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <label style={{
                        display: 'block',
                        marginBottom: theme.spacing.xs,
                        color: theme.colors.text.secondary,
                    }}>
                        Duration (seconds, leave empty for full duration)
                    </label>
                    <input
                        type="number"
                        min="0"
                        step="0.1"
                        value={component.style?.duration ?? ''}
                        onChange={(e) => handleStyleChange('duration', e.target.value ? parseFloat(e.target.value) : undefined)}
                        style={{
                            width: '100%',
                            padding: theme.spacing.sm,
                            borderRadius: theme.borderRadius.sm,
                            border: `1px solid ${theme.colors.border}`,
                            backgroundColor: theme.colors.background.secondary,
                            color: theme.colors.text.primary,
                        }}
                    />
                </div>

                {/* Loop Toggle */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <label style={{
                        display: 'flex',
                        alignItems: 'center',
                        gap: theme.spacing.sm,
                        color: theme.colors.text.secondary,
                        cursor: 'pointer',
                    }}>
                        <input
                            type="checkbox"
                            checked={component.style?.loop ?? false}
                            onChange={(e) => handleStyleChange('loop', e.target.checked)}
                        />
                        Loop Audio
                    </label>
                </div>
            </div>

            {/* Delete Button */}
            <button
                onClick={onDelete}
                style={{
                    padding: theme.spacing.sm,
                    backgroundColor: theme.colors.warning,
                    color: theme.colors.text.primary,
                    border: 'none',
                    borderRadius: theme.borderRadius.sm,
                    cursor: 'pointer',
                    fontWeight: 'bold',
                }}
            >
                Delete
            </button>

            {/* Audio Preview */}
            {component.audioUrl && (
                <div style={{
                    marginTop: theme.spacing.md,
                    padding: theme.spacing.md,
                    backgroundColor: theme.colors.background.tertiary,
                    borderRadius: theme.borderRadius.md,
                }}>
                    <h4 style={{
                        margin: 0,
                        marginBottom: theme.spacing.sm,
                        color: theme.colors.text.primary,
                    }}>Preview</h4>
                    <audio
                        controls
                        src={component.audioUrl}
                        style={{ width: '100%' }}
                    />
                </div>
            )}
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\CaptionEditor.tsx ---

import React, { useState } from 'react';
import { WordTiming } from '../../types/script';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';

interface CaptionEditorProps {
    wordTimings: WordTiming[];
    onWordTimingsChange: (newTimings: WordTiming[]) => void;
    onClose: () => void;
}

export const CaptionEditor: React.FC<CaptionEditorProps> = ({
    wordTimings,
    onWordTimingsChange,
    onClose,
}) => {
    const [editingWord, setEditingWord] = useState<number | null>(null);
    const [localTimings, setLocalTimings] = useState<WordTiming[]>(wordTimings);

    const handleWordChange = (index: number, field: keyof WordTiming, value: string | number) => {
        const newTimings = [...localTimings];
        newTimings[index] = {
            ...newTimings[index],
            [field]: field === 'word' ? value : Number(value),
        };
        setLocalTimings(newTimings);
    };

    const handleSave = () => {
        onWordTimingsChange(localTimings);
        onClose();
    };

    return (
        <div style={{
            padding: theme.spacing.md,
            display: 'flex',
            flexDirection: 'column',
            gap: theme.spacing.md,
            maxHeight: '80vh',
            overflow: 'auto',
        }}>
            <div style={{
                display: 'flex',
                flexDirection: 'column',
                gap: theme.spacing.sm,
            }}>
                {localTimings.map((timing, index) => (
                    <div
                        key={index}
                        style={{
                            display: 'flex',
                            gap: theme.spacing.md,
                            alignItems: 'center',
                            padding: theme.spacing.sm,
                            backgroundColor: theme.colors.background.secondary,
                            borderRadius: theme.borderRadius.sm,
                        }}
                    >
                        <input
                            value={timing.word}
                            onChange={(e) => handleWordChange(index, 'word', e.target.value)}
                            style={{
                                flex: 2,
                                padding: '4px 8px',
                                borderRadius: theme.borderRadius.sm,
                                border: `1px solid ${theme.colors.border}`,
                                backgroundColor: theme.colors.background.tertiary,
                                color: theme.colors.text.primary,
                            }}
                        />
                        <div style={{ display: 'flex', gap: theme.spacing.sm, alignItems: 'center' }}>
                            <label>Start:</label>
                            <input
                                type="number"
                                step="0.1"
                                value={timing.start}
                                onChange={(e) => handleWordChange(index, 'start', e.target.value)}
                                style={{
                                    width: '80px',
                                    padding: '4px 8px',
                                    borderRadius: theme.borderRadius.sm,
                                    border: `1px solid ${theme.colors.border}`,
                                    backgroundColor: theme.colors.background.tertiary,
                                    color: theme.colors.text.primary,
                                }}
                            />
                        </div>
                        <div style={{ display: 'flex', gap: theme.spacing.sm, alignItems: 'center' }}>
                            <label>End:</label>
                            <input
                                type="number"
                                step="0.1"
                                value={timing.end}
                                onChange={(e) => handleWordChange(index, 'end', e.target.value)}
                                style={{
                                    width: '80px',
                                    padding: '4px 8px',
                                    borderRadius: theme.borderRadius.sm,
                                    border: `1px solid ${theme.colors.border}`,
                                    backgroundColor: theme.colors.background.tertiary,
                                    color: theme.colors.text.primary,
                                }}
                            />
                        </div>
                    </div>
                ))}
            </div>

            <div style={{
                display: 'flex',
                justifyContent: 'flex-end',
                gap: theme.spacing.md,
                marginTop: theme.spacing.md,
            }}>
                <button
                    onClick={onClose}
                    style={commonStyles.button.secondary}
                >
                    Cancel
                </button>
                <button
                    onClick={handleSave}
                    style={commonStyles.button.primary}
                >
                    Save Changes
                </button>
            </div>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\CaptionPositioningScreen.tsx ---

import React, { useState } from 'react';
import { CaptionStyleOptions } from '../../types/script';
import { theme } from '../../styles/theme';

interface CaptionPositioningScreenProps {
    style: CaptionStyleOptions;
    onChange: (style: CaptionStyleOptions) => void;
}

export const CaptionPositioningScreen: React.FC<CaptionPositioningScreenProps> = ({
    style,
    onChange,
}) => {
    const [isDragging, setIsDragging] = useState(false);
    const [startPos, setStartPos] = useState({ x: 0, y: 0 });

    const handleMouseDown = (e: React.MouseEvent) => {
        setIsDragging(true);
        setStartPos({
            x: e.clientX - (style.x || 0),
            y: e.clientY - (style.y || 0),
        });
    };

    const handleMouseMove = (e: React.MouseEvent) => {
        if (!isDragging) return;

        const newX = e.clientX - startPos.x;
        const newY = e.clientY - startPos.y;

        onChange({
            ...style,
            x: newX,
            y: newY,
        });
    };

    const handleMouseUp = () => {
        setIsDragging(false);
    };

    return (
        <div style={styles.container}>
            <div style={styles.header}>
                <h3>Caption Positioning</h3>
                <p>Drag to position the captions or use the controls below</p>
            </div>

            <div 
                style={styles.previewArea}
                onMouseMove={handleMouseMove}
                onMouseUp={handleMouseUp}
                onMouseLeave={handleMouseUp}
            >
                <div
                    style={{
                        ...styles.captionPreview,
                        transform: `translate(${style.x || 0}px, ${style.y || 0}px) scale(${style.scale || 1}) rotate(${style.rotation || 0}deg)`,
                        cursor: isDragging ? 'grabbing' : 'grab',
                        fontSize: style.fontSize,
                        color: style.color,
                        backgroundColor: style.backgroundColor,
                        fontFamily: style.fontFamily,
                        fontWeight: style.fontWeight,
                        fontStyle: style.fontStyle,
                        textDecoration: style.textDecoration,
                        padding: style.padding,
                        margin: style.margin,
                        borderRadius: style.borderRadius,
                        border: style.border,
                        boxShadow: style.boxShadow,
                        opacity: style.opacity,
                    }}
                    onMouseDown={handleMouseDown}
                >
                    Sample Caption Text
                </div>
            </div>

            <div style={styles.controls}>
                <div style={styles.controlGroup}>
                    <label>Position X:</label>
                    <input
                        type="number"
                        value={style.x || 0}
                        onChange={(e) => onChange({ ...style, x: Number(e.target.value) })}
                    />
                </div>

                <div style={styles.controlGroup}>
                    <label>Position Y:</label>
                    <input
                        type="number"
                        value={style.y || 0}
                        onChange={(e) => onChange({ ...style, y: Number(e.target.value) })}
                    />
                </div>

                <div style={styles.controlGroup}>
                    <label>Scale:</label>
                    <input
                        type="range"
                        min="0.1"
                        max="2"
                        step="0.1"
                        value={style.scale || 1}
                        onChange={(e) => onChange({ ...style, scale: Number(e.target.value) })}
                    />
                </div>

                <div style={styles.controlGroup}>
                    <label>Rotation:</label>
                    <input
                        type="range"
                        min="-180"
                        max="180"
                        value={style.rotation || 0}
                        onChange={(e) => onChange({ ...style, rotation: Number(e.target.value) })}
                    />
                </div>
            </div>
        </div>
    );
};

const styles = {
    container: {
        padding: theme.spacing.md,
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.md,
    },
    header: {
        textAlign: 'center' as const,
    },
    previewArea: {
        width: '100%',
        height: '300px',
        backgroundColor: '#f0f0f0',
        position: 'relative' as const,
        overflow: 'hidden',
        border: '1px solid #ccc',
        borderRadius: theme.borderRadius.md,
    },
    captionPreview: {
        position: 'absolute' as const,
        userSelect: 'none' as const,
        padding: '10px 20px',
        borderRadius: '5px',
        transition: 'transform 0.1s ease-out',
    },
    controls: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.sm,
    },
    controlGroup: {
        display: 'flex',
        alignItems: 'center',
        gap: theme.spacing.sm,
        '& label': {
            minWidth: '100px',
        },
        '& input': {
            flex: 1,
            padding: theme.spacing.sm,
            borderRadius: theme.borderRadius.sm,
            border: '1px solid #ccc',
        },
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\CaptionTimeline.tsx ---

import React, { useState, useRef, useEffect } from 'react';
import { CaptionTrack, Script, VoiceComponent, WordTiming } from '../../types/script';
import { theme } from '../../styles/theme';
import { Modal } from '../common/Modal';
import { CaptionEditor } from './CaptionEditor';

interface CaptionTimelineProps {
    script: Script;
    onScriptChange: (script: Script) => void;
}

const TRACK_HEIGHT = 40;
const PIXELS_PER_SECOND = 100;
const FRAMES_PER_SECOND = 30;

export const CaptionTimeline: React.FC<CaptionTimelineProps> = ({
    script,
    onScriptChange,
}) => {
    const [draggingId, setDraggingId] = useState<string | null>(null);
    const [dragOffset, setDragOffset] = useState(0);
    const [editingCaption, setEditingCaption] = useState<string | null>(null);
    const [editingWordTimings, setEditingWordTimings] = useState<{id: string, isTrack: boolean} | null>(null);
    const containerRef = useRef<HTMLDivElement>(null);

    // Calculate timeline width based on all components and caption tracks
    const timelineWidth = Math.max(
        ...script.components
            .filter(c => c.type === 'voice')
            .map(c => {
                const start = c.startFrame || 0;
                const duration = c.durationInFrames || 150;
                return (start + duration) / FRAMES_PER_SECOND * PIXELS_PER_SECOND;
            }),
        ...(script.captionTracks || []).map(track => {
            const start = track.startFrame;
            const lastWord = track.wordTimings[track.wordTimings.length - 1];
            const duration = lastWord ? (lastWord.end * FRAMES_PER_SECOND) : 150;
            return (start + duration) / FRAMES_PER_SECOND * PIXELS_PER_SECOND;
        }),
        PIXELS_PER_SECOND * 10 // Minimum width of 10 seconds
    );

    const handleUnlink = (componentId: string) => {
        // Find the voice component
        const component = script.components.find(
            c => c.id === componentId && c.type === 'voice'
        ) as VoiceComponent | undefined;

        if (!component?.wordTimings) return;

        // Create a new caption track
        const newTrack: CaptionTrack = {
            id: `caption_${Date.now()}`,
            originalComponentId: componentId,
            isLinked: false,
            wordTimings: component.wordTimings,
            startFrame: component.startFrame || 0,
            text: component.text,
        };

        // Add to caption tracks
        onScriptChange({
            ...script,
            captionTracks: [...(script.captionTracks || []), newTrack],
        });
    };

    const handleRelink = (trackId: string) => {
        const track = script.captionTracks?.find(t => t.id === trackId);
        if (!track?.originalComponentId) return;

        // Update the original component with the track's timings
        const updatedComponents = script.components.map(comp => {
            if (comp.id === track.originalComponentId && comp.type === 'voice') {
                return {
                    ...comp,
                    wordTimings: track.wordTimings,
                    startFrame: track.startFrame,
                };
            }
            return comp;
        });

        // Remove this track from caption tracks
        onScriptChange({
            ...script,
            components: updatedComponents,
            captionTracks: script.captionTracks?.filter(t => t.id !== trackId) || [],
        });
    };

    const handleDragStart = (e: React.DragEvent, track: CaptionTrack) => {
        const rect = e.currentTarget.getBoundingClientRect();
        const offsetX = e.clientX - rect.left;
        setDragOffset(Math.round((offsetX / PIXELS_PER_SECOND) * FRAMES_PER_SECOND));
        setDraggingId(track.id);
    };

    const handleDrag = (e: React.DragEvent) => {
        if (!draggingId) return;

        const rect = e.currentTarget.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const newStartFrame = Math.max(0, Math.round((x / PIXELS_PER_SECOND) * FRAMES_PER_SECOND) - dragOffset);

        const updatedTracks = script.captionTracks?.map(track => 
            track.id === draggingId ? { ...track, startFrame: newStartFrame } : track
        );

        onScriptChange({
            ...script,
            captionTracks: updatedTracks || [],
        });
    };

    const handleEditText = (trackId: string, newText: string) => {
        const updatedTracks = script.captionTracks?.map(track => 
            track.id === trackId ? { ...track, text: newText } : track
        );

        onScriptChange({
            ...script,
            captionTracks: updatedTracks || [],
        });
    };

    const handleWordTimingsChange = (id: string, isTrack: boolean, newTimings: WordTiming[]) => {
        if (isTrack) {
            // Update caption track
            const updatedTracks = script.captionTracks?.map(track => 
                track.id === id ? { ...track, wordTimings: newTimings } : track
            );
            onScriptChange({
                ...script,
                captionTracks: updatedTracks || [],
            });
        } else {
            // Update voice component
            const updatedComponents = script.components.map(comp => 
                comp.id === id && comp.type === 'voice'
                    ? { ...comp, wordTimings: newTimings }
                    : comp
            );
            onScriptChange({
                ...script,
                components: updatedComponents,
            });
        }
    };

    return (
        <>
            <div style={{
                backgroundColor: theme.colors.background.secondary,
                padding: theme.spacing.lg,
                borderRadius: theme.borderRadius.md,
                marginTop: theme.spacing.xl,
                borderTop: `2px solid ${theme.colors.border}`,
            }}>
                <div style={{
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    marginBottom: theme.spacing.lg,
                }}>
                    <h3 style={{ 
                        color: theme.colors.text.primary, 
                        margin: 0,
                        fontSize: '16px',
                        fontWeight: 'bold',
                    }}>
                        Captions Timeline
                    </h3>
                </div>

                <div 
                    ref={containerRef}
                    style={{
                        backgroundColor: theme.colors.background.tertiary,
                        borderRadius: theme.borderRadius.sm,
                        padding: theme.spacing.sm,
                    }}
                >
                    <div style={{
                        width: `${timelineWidth}px`,
                        position: 'relative',
                    }}>
                        {/* Time markers */}
                        <div style={{
                            height: '30px',
                            borderBottom: `1px solid ${theme.colors.border}`,
                            position: 'relative',
                            marginBottom: theme.spacing.sm,
                        }}>
                            {Array.from({ length: Math.ceil(timelineWidth / PIXELS_PER_SECOND) }).map((_, i) => (
                                <div
                                    key={i}
                                    style={{
                                        position: 'absolute',
                                        left: `${i * PIXELS_PER_SECOND}px`,
                                        width: '1px',
                                        height: '15px',
                                        backgroundColor: theme.colors.border,
                                    }}
                                >
                                    <span style={{
                                        position: 'absolute',
                                        top: '-20px',
                                        left: '2px',
                                        fontSize: '12px',
                                        color: theme.colors.text.secondary,
                                        fontFamily: 'monospace',
                                    }}>
                                        {i}s
                                    </span>
                                </div>
                            ))}
                        </div>

                        {/* Empty tracks */}
                        {Array.from({ length: 3 }).map((_, index) => (
                            <div
                                key={`empty-track-${index}`}
                                style={{
                                    height: TRACK_HEIGHT,
                                    borderBottom: `1px solid ${theme.colors.border}`,
                                    position: 'relative',
                                    backgroundColor: index % 2 === 0 ? theme.colors.background.secondary : 'transparent',
                                    marginBottom: theme.spacing.sm,
                                }}
                            />
                        ))}

                        {/* Voice components with captions */}
                        {script.components
                            .filter(c => c.type === 'voice' && (c as VoiceComponent).wordTimings)
                            .map((component) => {
                                const voiceComponent = component as VoiceComponent;
                                const isUnlinked = script.captionTracks?.some(
                                    t => t.originalComponentId === component.id
                                );

                                return (
                                    <div
                                        key={component.id}
                                        style={{
                                            height: TRACK_HEIGHT,
                                            borderBottom: `1px solid ${theme.colors.border}`,
                                            position: 'relative',
                                            backgroundColor: theme.colors.background.secondary,
                                            marginBottom: theme.spacing.sm,
                                        }}
                                    >
                                        <div style={{
                                            position: 'absolute',
                                            left: `${((component.startFrame || 0) / FRAMES_PER_SECOND) * PIXELS_PER_SECOND}px`,
                                            height: TRACK_HEIGHT,
                                            backgroundColor: isUnlinked ? theme.colors.background.tertiary : theme.colors.primary,
                                            padding: '0 8px',
                                            display: 'flex',
                                            alignItems: 'center',
                                            borderRadius: theme.borderRadius.sm,
                                            cursor: 'pointer',
                                            whiteSpace: 'nowrap',
                                            overflow: 'hidden',
                                            textOverflow: 'ellipsis',
                                            minWidth: '100px',
                                        }}>
                                            <span style={{ marginRight: '8px' }}>
                                                {voiceComponent.text.substring(0, 30)}...
                                            </span>
                                            {!isUnlinked && (
                                                <button
                                                    onClick={() => handleUnlink(component.id)}
                                                    style={{
                                                        padding: '4px 8px',
                                                        backgroundColor: theme.colors.secondary,
                                                        border: 'none',
                                                        borderRadius: theme.borderRadius.sm,
                                                        cursor: 'pointer',
                                                        color: 'white',
                                                        whiteSpace: 'nowrap',
                                                    }}
                                                >
                                                    Unlink
                                                </button>
                                            )}
                                        </div>
                                    </div>
                                );
                            })}

                        {/* Caption tracks */}
                        {script.captionTracks?.map((track, index) => (
                            <div
                                key={track.id}
                                style={{
                                    height: TRACK_HEIGHT,
                                    borderBottom: `1px solid ${theme.colors.border}`,
                                    position: 'relative',
                                    backgroundColor: index % 2 === 0 ? theme.colors.background.secondary : 'transparent',
                                    marginBottom: theme.spacing.sm,
                                }}
                                onDragOver={(e) => e.preventDefault()}
                                onDrop={(e) => {
                                    e.preventDefault();
                                    setDraggingId(null);
                                }}
                            >
                                <div
                                    draggable
                                    onDragStart={(e) => handleDragStart(e, track)}
                                    onDrag={handleDrag}
                                    onDragEnd={() => setDraggingId(null)}
                                    style={{
                                        position: 'absolute',
                                        left: `${(track.startFrame / FRAMES_PER_SECOND) * PIXELS_PER_SECOND}px`,
                                        height: TRACK_HEIGHT,
                                        backgroundColor: theme.colors.secondary,
                                        padding: '0 8px',
                                        display: 'flex',
                                        alignItems: 'center',
                                        borderRadius: theme.borderRadius.sm,
                                        cursor: 'grab',
                                    }}
                                >
                                    {editingCaption === track.id ? (
                                        <input
                                            value={track.text}
                                            onChange={(e) => handleEditText(track.id, e.target.value)}
                                            onBlur={() => setEditingCaption(null)}
                                            autoFocus
                                            style={{
                                                width: '200px',
                                                padding: '4px',
                                                border: 'none',
                                                borderRadius: theme.borderRadius.sm,
                                            }}
                                        />
                                    ) : (
                                        <>
                                            <span
                                                onClick={() => setEditingCaption(track.id)}
                                                style={{ marginRight: '8px', cursor: 'text' }}
                                            >
                                                {track.text.substring(0, 20)}...
                                            </span>
                                            <button
                                                onClick={() => handleRelink(track.id)}
                                                style={{
                                                    padding: '4px 8px',
                                                    backgroundColor: theme.colors.primary,
                                                    border: 'none',
                                                    borderRadius: theme.borderRadius.sm,
                                                    cursor: 'pointer',
                                                    color: 'white',
                                                }}
                                            >
                                                Relink
                                            </button>
                                        </>
                                    )}
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            </div>

            {/* Caption Editor Modal */}
            {editingWordTimings && (
                <Modal
                    isOpen={true}
                    onClose={() => setEditingWordTimings(null)}
                    title="Edit Captions"
                >
                    <CaptionEditor
                        wordTimings={
                            editingWordTimings.isTrack
                                ? script.captionTracks?.find(t => t.id === editingWordTimings.id)?.wordTimings || []
                                : (script.components.find(c => c.id === editingWordTimings.id) as VoiceComponent)?.wordTimings || []
                        }
                        onWordTimingsChange={(newTimings) => 
                            handleWordTimingsChange(editingWordTimings.id, editingWordTimings.isTrack, newTimings)
                        }
                        onClose={() => setEditingWordTimings(null)}
                    />
                </Modal>
            )}
        </>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\ComparisonComponentEditor.tsx ---

import React from 'react';
import { ComparisonComponent, AnimationOptions } from '../../types/script';
import { ImageSelector } from '../ImageSelector';
import { theme } from '../../styles/theme';

interface ComparisonComponentEditorProps {
    component: ComparisonComponent;
    onChange: (updated: ComparisonComponent) => void;
}

export const ComparisonComponentEditor: React.FC<ComparisonComponentEditorProps> = ({
    component,
    onChange,
}) => {
    const handleStyleChange = (updated: Partial<ComparisonComponent['style']>) => {
        onChange({
            ...component,
            style: {
                ...component.style,
                ...updated
            }
        });
    };

    const handleAnimationChange = (updates: Partial<AnimationOptions>) => {
        const currentAnimation = component.style?.animation || {
            type: 'none',
            direction: 'in',
            easing: 'easeInOut',
            duration: 30,
            delay: 0,
            stagger: 0
        };
        handleStyleChange({
            animation: {
                ...currentAnimation,
                ...updates,
            }
        });
    };

    const handleBorderChange = (updates: Partial<NonNullable<ComparisonComponent['style']>['imageBorder']>) => {
        const currentBorder = component.style?.imageBorder || { enabled: false, color: '#000000', width: 1 };
        handleStyleChange({
            imageBorder: {
                ...currentBorder,
                ...updates,
            }
        });
    };

    const handleShadowChange = (updates: Partial<NonNullable<ComparisonComponent['style']>['imageDropShadow']>) => {
        const currentShadow = component.style?.imageDropShadow || { enabled: false, color: '#000000', blur: 10, spread: 0, x: 0, y: 4 };
        handleStyleChange({
            imageDropShadow: {
                ...currentShadow,
                ...updates,
            }
        });
    };

    const handlePositionChange = (updates: Partial<{ x: number; y: number }>) => {
        const currentPosition = component.style?.imagePosition || { x: 0, y: 0 };
        handleStyleChange({
            imagePosition: {
                ...currentPosition,
                ...updates
            }
        });
    };

    return (
        <div style={styles.container}>
            {/* Question */}
            <div style={styles.section}>
                <label style={styles.label}>
                    Question:
                </label>
                <input
                    type="text"
                    value={component.question}
                    onChange={(e) => {
                        onChange({
                            ...component,
                            question: e.target.value || '',
                        });
                    }}
                    style={styles.input}
                    placeholder="Enter your question..."
                />
            </div>

            {/* Settings */}
            <div style={styles.section}>
                <h4 style={styles.sectionTitle}>Settings</h4>
                <div style={styles.settingsGrid}>
                    <div>
                        <label style={styles.label}>Orientation:</label>
                        <select
                            value={component.orientation || 'horizontal'}
                            onChange={(e) => {
                                onChange({
                                    ...component,
                                    orientation: e.target.value as 'horizontal' | 'vertical'
                                });
                            }}
                            style={styles.input}
                        >
                            <option value="horizontal">Side by Side</option>
                            <option value="vertical">Top and Bottom</option>
                        </select>
                    </div>

                    <div>
                        <label style={styles.label}>Duration (frames):</label>
                        <input
                            type="number"
                            min="1"
                            value={component.durationInFrames || 150}
                            onChange={(e) => {
                                onChange({
                                    ...component,
                                    durationInFrames: parseInt(e.target.value)
                                });
                            }}
                            style={styles.input}
                        />
                    </div>
                </div>

                <div style={{ marginTop: theme.spacing.md }}>
                    <label style={{
                        ...styles.label,
                        display: 'flex',
                        alignItems: 'center',
                        gap: theme.spacing.sm,
                    }}>
                        <input
                            type="checkbox"
                            checked={component.style?.showText !== false}
                            onChange={(e) => {
                                onChange({
                                    ...component,
                                    style: {
                                        ...component.style,
                                        showText: e.target.checked
                                    }
                                });
                            }}
                        />
                        Show Text Labels
                    </label>
                </div>

                {component.style?.showText !== false && (
                    <div style={{ marginTop: theme.spacing.md }}>
                        <div style={styles.settingsGrid}>
                            <div>
                                <label style={styles.label}>Font Size:</label>
                                <input
                                    type="number"
                                    value={component.style?.fontSize || 32}
                                    onChange={(e) => {
                                        onChange({
                                            ...component,
                                            style: {
                                                ...component.style,
                                                fontSize: parseInt(e.target.value)
                                            }
                                        });
                                    }}
                                    style={styles.input}
                                />
                            </div>

                            <div>
                                <label style={styles.label}>Text Color:</label>
                                <input
                                    type="color"
                                    value={component.style?.textColor || '#ffffff'}
                                    onChange={(e) => {
                                        onChange({
                                            ...component,
                                            style: {
                                                ...component.style,
                                                textColor: e.target.value
                                            }
                                        });
                                    }}
                                    style={styles.input}
                                />
                            </div>
                        </div>
                    </div>
                )}
            </div>

            {/* Image Style Settings */}
            <div style={{ marginTop: theme.spacing.md }}>
                <h4 style={styles.sectionTitle}>Image Styles</h4>
                
                {/* Border Settings */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <div style={styles.row}>
                        <input
                            type="checkbox"
                            checked={component.style?.imageBorder?.enabled ?? false}
                            onChange={(e) => handleBorderChange({ enabled: e.target.checked })}
                            style={styles.checkbox}
                        />
                        <label style={styles.label}>Enable Border</label>
                    </div>
                    {component.style?.imageBorder?.enabled && (
                        <div style={styles.row}>
                            <input
                                type="color"
                                value={component.style.imageBorder.color ?? '#000000'}
                                onChange={(e) => handleBorderChange({ color: e.target.value })}
                                style={styles.input}
                            />
                            <input
                                type="number"
                                value={component.style.imageBorder.width ?? 1}
                                onChange={(e) => handleBorderChange({ width: Number(e.target.value) })}
                                placeholder="Width"
                                min="1"
                                max="20"
                                style={styles.input}
                            />
                        </div>
                    )}
                </div>

                {/* Drop Shadow Settings */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <div style={styles.row}>
                        <input
                            type="checkbox"
                            checked={component.style?.imageDropShadow?.enabled ?? false}
                            onChange={(e) => handleShadowChange({ enabled: e.target.checked })}
                            style={styles.checkbox}
                        />
                        <label style={styles.label}>Enable Drop Shadow</label>
                    </div>
                    {component.style?.imageDropShadow?.enabled && (
                        <>
                            <div style={styles.row}>
                                <input
                                    type="color"
                                    value={component.style.imageDropShadow.color ?? '#000000'}
                                    onChange={(e) => handleShadowChange({ color: e.target.value })}
                                    style={styles.input}
                                />
                                <input
                                    type="number"
                                    value={component.style.imageDropShadow.blur ?? 10}
                                    onChange={(e) => handleShadowChange({ blur: Number(e.target.value) })}
                                    placeholder="Blur"
                                    min="0"
                                    max="50"
                                    style={styles.input}
                                />
                            </div>
                            <div style={styles.row}>
                                <input
                                    type="number"
                                    value={component.style.imageDropShadow.x ?? 0}
                                    onChange={(e) => handleShadowChange({ x: Number(e.target.value) })}
                                    placeholder="X Offset"
                                    style={styles.input}
                                />
                                <input
                                    type="number"
                                    value={component.style.imageDropShadow.y ?? 0}
                                    onChange={(e) => handleShadowChange({ y: Number(e.target.value) })}
                                    placeholder="Y Offset"
                                    style={styles.input}
                                />
                                <input
                                    type="number"
                                    value={component.style.imageDropShadow.spread ?? 0}
                                    onChange={(e) => handleShadowChange({ spread: Number(e.target.value) })}
                                    placeholder="Spread"
                                    style={styles.input}
                                />
                            </div>
                        </>
                    )}
                </div>

                {/* Layout Settings */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <h4 style={styles.sectionTitle}>Layout</h4>
                    <div style={styles.settingsGrid}>
                        <div>
                            <label style={styles.label}>Image Size (%):</label>
                            <input
                                type="number"
                                min="10"
                                max="500"
                                value={component.style?.imageSize || 100}
                                onChange={(e) => {
                                    const size = Math.max(10, Math.min(500, parseInt(e.target.value) || 100));
                                    handleStyleChange({
                                        imageSize: size
                                    });
                                }}
                                style={styles.input}
                            />
                        </div>
                        <div>
                            <label style={styles.label}>Gap Between Images (px):</label>
                            <input
                                type="number"
                                min="0"
                                max="200"
                                value={component.style?.imageGap || 20}
                                onChange={(e) => {
                                    const gap = Math.max(0, Math.min(200, parseInt(e.target.value) || 20));
                                    handleStyleChange({
                                        imageGap: gap
                                    });
                                }}
                                style={styles.input}
                            />
                        </div>
                    </div>

                    <div style={styles.row}>
                        <input
                            type="checkbox"
                            checked={component.style?.forceSameSize ?? true}
                            onChange={(e) => handleStyleChange({ forceSameSize: e.target.checked })}
                            style={styles.checkbox}
                        />
                        <label style={styles.label}>Force Images to Same Size</label>
                    </div>

                    <div style={styles.settingsGrid}>
                        <div>
                            <label style={styles.label}>Horizontal Position (%):</label>
                            <input
                                type="range"
                                min="-100"
                                max="100"
                                value={component.style?.imagePosition?.x || 0}
                                onChange={(e) => {
                                    handlePositionChange({ x: parseInt(e.target.value) });
                                }}
                                style={styles.input}
                            />
                        </div>
                        <div>
                            <label style={styles.label}>Vertical Position (%):</label>
                            <input
                                type="range"
                                min="-100"
                                max="100"
                                value={component.style?.imagePosition?.y || 0}
                                onChange={(e) => {
                                    handlePositionChange({ y: parseInt(e.target.value) });
                                }}
                                style={styles.input}
                            />
                        </div>
                    </div>
                </div>
            </div>

            {/* Animation Controls */}
            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Animation Settings</h3>
                <div style={styles.row}>
                    <select
                        value={component.style?.animation?.type ?? 'none'}
                        onChange={(e) => handleAnimationChange({ type: e.target.value as AnimationOptions['type'] })}
                        style={styles.input}
                    >
                        <option value="none">None</option>
                        <option value="fade">Fade</option>
                        <option value="scale">Scale</option>
                        <option value="rotate">Rotate</option>
                        <option value="slide">Slide</option>
                    </select>
                </div>
                {component.style?.animation?.type !== 'none' && (
                    <>
                        <div style={styles.row}>
                            <select
                                value={component.style?.animation?.direction ?? 'in'}
                                onChange={(e) => handleAnimationChange({ direction: e.target.value as AnimationOptions['direction'] })}
                                style={styles.input}
                            >
                                <option value="in">In</option>
                                <option value="out">Out</option>
                            </select>
                            <select
                                value={component.style?.animation?.easing ?? 'easeInOut'}
                                onChange={(e) => handleAnimationChange({ easing: e.target.value as AnimationOptions['easing'] })}
                                style={styles.input}
                            >
                                <option value="linear">Linear</option>
                                <option value="easeIn">Ease In</option>
                                <option value="easeOut">Ease Out</option>
                                <option value="easeInOut">Ease In Out</option>
                            </select>
                        </div>
                        <div style={styles.row}>
                            <input
                                type="number"
                                value={component.style?.animation?.duration ?? 30}
                                onChange={(e) => handleAnimationChange({ duration: Number(e.target.value) })}
                                placeholder="Duration (frames)"
                                min="1"
                                style={styles.input}
                            />
                            <input
                                type="number"
                                value={component.style?.animation?.delay ?? 0}
                                onChange={(e) => handleAnimationChange({ delay: Number(e.target.value) })}
                                placeholder="Delay (frames)"
                                min="0"
                                style={styles.input}
                            />
                            <input
                                type="number"
                                value={component.style?.animation?.stagger ?? 0}
                                onChange={(e) => handleAnimationChange({ stagger: Number(e.target.value) })}
                                placeholder="Stagger (frames)"
                                min="0"
                                style={styles.input}
                            />
                        </div>
                    </>
                )}
            </div>

            {/* Options */}
            <div style={{
                ...styles.optionsGrid,
                gridTemplateColumns: component.orientation === 'horizontal' ? '1fr 1fr' : '1fr',
            }}>
                {/* First Option */}
                <div style={styles.optionSection}>
                    <h4 style={styles.sectionTitle}>
                        {component.orientation === 'horizontal' ? 'Left Option' : 'Top Option'}
                    </h4>
                    <input
                        type="text"
                        value={component.leftOption.text}
                        onChange={(e) => {
                            onChange({
                                ...component,
                                leftOption: {
                                    ...component.leftOption,
                                    text: e.target.value || '',
                                }
                            });
                        }}
                        style={styles.input}
                        placeholder="Enter text..."
                    />
                    <ImageSelector
                        onSelect={(url) => {
                            onChange({
                                ...component,
                                leftOption: {
                                    ...component.leftOption,
                                    imageUrl: url,
                                }
                            });
                        }}
                        searchTerm={component.leftOption.text || 'image'}
                    />
                </div>

                {/* Second Option */}
                <div style={styles.optionSection}>
                    <h4 style={styles.sectionTitle}>
                        {component.orientation === 'horizontal' ? 'Right Option' : 'Bottom Option'}
                    </h4>
                    <input
                        type="text"
                        value={component.rightOption.text}
                        onChange={(e) => {
                            onChange({
                                ...component,
                                rightOption: {
                                    ...component.rightOption,
                                    text: e.target.value || '',
                                }
                            });
                        }}
                        style={styles.input}
                        placeholder="Enter text..."
                    />
                    <ImageSelector
                        onSelect={(url) => {
                            onChange({
                                ...component,
                                rightOption: {
                                    ...component.rightOption,
                                    imageUrl: url,
                                }
                            });
                        }}
                        searchTerm={component.rightOption.text || 'image'}
                    />
                </div>
            </div>
        </div>
    );
};

const styles = {
    container: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.md,
        height: '100%',
        backgroundColor: 'transparent',
    },
    section: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.sm,
        padding: theme.spacing.md,
        backgroundColor: theme.colors.background.secondary,
        borderRadius: theme.borderRadius.md,
        border: `1px solid ${theme.colors.border}`,
    },
    sectionTitle: {
        margin: '0 0 8px 0',
        color: theme.colors.text.primary,
        fontSize: '1rem',
        fontWeight: 600,
    },
    label: {
        fontSize: '0.9rem',
        fontWeight: 500,
        color: theme.colors.text.primary,
    },
    input: {
        padding: '0.5rem',
        borderRadius: theme.borderRadius.sm,
        border: `1px solid ${theme.colors.border}`,
        backgroundColor: theme.colors.background.tertiary,
        color: theme.colors.text.primary,
        width: '100%',
        minWidth: 0,
    },
    settingsGrid: {
        display: 'grid',
        gridTemplateColumns: '1fr 1fr',
        gap: theme.spacing.sm,
    },
    optionsGrid: {
        display: 'grid',
        gap: theme.spacing.md,
    },
    optionSection: {
        backgroundColor: theme.colors.background.secondary,
        padding: theme.spacing.md,
        borderRadius: theme.borderRadius.md,
        border: `1px solid ${theme.colors.border}`,
    },
    row: {
        display: 'flex',
        gap: theme.spacing.sm,
        alignItems: 'center',
        flexWrap: 'wrap' as const,
    },
    preview: {
        width: '100%',
        maxHeight: '200px',
        objectFit: 'contain' as const,
        backgroundColor: theme.colors.background.tertiary,
        borderRadius: theme.borderRadius.md,
        marginBottom: theme.spacing.sm,
    },
    checkbox: {
        margin: 0,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\ComponentEditor.tsx ---

import React, { useState } from 'react';
import { ScriptComponent, TextStyle, TextComponent, TitleComponent, CountdownComponent } from '../../types/script';
import { TextComponentEditor } from './TextComponentEditor';
import { TitleComponentEditor } from './TitleComponentEditor';
import { ComparisonComponentEditor } from './ComparisonComponentEditor';
import { CountdownComponentEditor } from './CountdownComponentEditor';
import { VoiceComponentEditor } from './VoiceComponentEditor';
import { PositioningScreen } from './PositioningScreen';
import { theme } from '../../styles/theme';
import { VideoComponentEditor } from './VideoComponentEditor';
import { AudioComponentEditor } from './AudioComponentEditor';

export interface ComponentEditorProps {
    component: ScriptComponent;
    onChange: (updated: ScriptComponent) => void;
    onDelete: () => void;
    onEditPosition?: (componentId: string | null) => void;
}

const defaultStyle: TextStyle = {
    fontSize: 40,
    fontFamily: 'Arial',
    color: '#ffffff',
    textAlign: 'center',
};

const hasStyle = (component: ScriptComponent): component is TextComponent | TitleComponent | CountdownComponent => {
    return ['text', 'title', 'countdown'].includes(component.type);
};

export const ComponentEditor: React.FC<ComponentEditorProps> = ({
    component,
    onChange,
    onDelete,
    onEditPosition,
}) => {
    const [showPositioning, setShowPositioning] = useState(false);

    // Ensure component has a style property if it's a type that requires it
    const componentWithStyle = React.useMemo(() => {
        if (hasStyle(component) && !component.style) {
            return {
                ...component,
                style: defaultStyle,
            };
        }
        return component;
    }, [component]);

    const handlePositionChange = (position: { x: number; y: number }) => {
        if (hasStyle(componentWithStyle)) {
            onChange({
                ...componentWithStyle,
                style: {
                    ...componentWithStyle.style,
                    position: {
                        x: position.x,
                        y: position.y,
                        width: componentWithStyle.style.position?.width || 300,
                    },
                },
            });
        }
    };

    const handleDelete = () => {
        onDelete();
    };

    return (
        <div style={{
            display: 'flex',
            flexDirection: 'column',
            gap: theme.spacing.md,
        }}>
            {/* Header */}
            <div style={{
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                padding: theme.spacing.sm,
                backgroundColor: theme.colors.background.tertiary,
                borderRadius: theme.borderRadius.sm,
            }}>
                <h3 style={{
                    margin: 0,
                    fontSize: theme.fontSizes.lg,
                    color: theme.colors.text.primary,
                }}>
                    {componentWithStyle.type.charAt(0).toUpperCase() + componentWithStyle.type.slice(1)} Settings
                </h3>
                <button
                    onClick={handleDelete}
                    style={{
                        backgroundColor: theme.colors.error,
                        color: 'white',
                        border: 'none',
                        padding: `${theme.spacing.xs} ${theme.spacing.sm}`,
                        borderRadius: theme.borderRadius.sm,
                        cursor: 'pointer',
                        fontSize: theme.fontSizes.sm,
                    }}
                >
                    Delete
                </button>
            </div>

            {/* Component-specific editors */}
            <div style={{
                padding: theme.spacing.sm,
                backgroundColor: theme.colors.background.tertiary,
                borderRadius: theme.borderRadius.sm,
            }}>
                {(() => {
                    switch (componentWithStyle.type) {
                        case 'text':
                            return <TextComponentEditor component={componentWithStyle as TextComponent} onChange={onChange} />;
                        case 'title':
                            return <TitleComponentEditor component={componentWithStyle as TitleComponent} onChange={onChange} />;
                        case 'comparison':
                            return <ComparisonComponentEditor component={componentWithStyle} onChange={onChange} />;
                        case 'countdown':
                            return <CountdownComponentEditor component={componentWithStyle as CountdownComponent} onChange={onChange} />;
                        case 'voice':
                            return <VoiceComponentEditor component={componentWithStyle} onChange={onChange} />;
                        case 'video':
                            return <VideoComponentEditor component={componentWithStyle} onChange={onChange} />;
                        case 'audio':
                            return <AudioComponentEditor component={componentWithStyle} onChange={onChange} onDelete={onDelete} />;
                        default:
                            return <div>Unknown component type: {componentWithStyle.type}</div>;
                    }
                })()}
            </div>

            {/* Position Toggle */}
            {hasStyle(componentWithStyle) && (
                <div style={{
                    padding: theme.spacing.sm,
                    backgroundColor: theme.colors.background.tertiary,
                    borderRadius: theme.borderRadius.sm,
                }}>
                    <button
                        onClick={() => setShowPositioning(!showPositioning)}
                        style={{
                            width: '100%',
                            backgroundColor: showPositioning ? theme.colors.primary : 'transparent',
                            color: showPositioning ? 'white' : theme.colors.text.primary,
                            border: `1px solid ${showPositioning ? theme.colors.primary : theme.colors.border}`,
                            padding: theme.spacing.sm,
                            borderRadius: theme.borderRadius.sm,
                            cursor: 'pointer',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            gap: theme.spacing.sm,
                            transition: 'all 0.2s ease',
                        }}
                    >
                        <span>📍</span>
                        {showPositioning ? 'Hide Position Editor' : 'Edit Position'}
                    </button>
                </div>
            )}

            {/* Positioning Screen */}
            {showPositioning && hasStyle(componentWithStyle) && (
                <PositioningScreen
                    component={componentWithStyle}
                    onPositionChange={handlePositionChange}
                    onClose={() => setShowPositioning(false)}
                />
            )}

            {/* Position display */}
            {hasStyle(componentWithStyle) && componentWithStyle.style?.position && (
                <div style={{
                    display: 'flex',
                    gap: theme.spacing.md,
                    justifyContent: 'center',
                    color: theme.colors.text.secondary,
                    fontSize: theme.fontSizes.sm,
                    padding: theme.spacing.sm,
                    backgroundColor: theme.colors.background.tertiary,
                    borderRadius: theme.borderRadius.sm,
                }}>
                    <span>X: {Math.round(componentWithStyle.style.position.x)}</span>
                    <span>Y: {Math.round(componentWithStyle.style.position.y)}</span>
                </div>
            )}
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\ComponentEditors.tsx ---

import React from 'react';
import { Component } from '../../types/script';
import { TextComponentEditor } from './TextComponentEditor';
import { ComparisonComponentEditor } from './ComparisonComponentEditor';
import { VoiceComponentEditor } from './VoiceComponentEditor';
import { VideoComponentEditor } from './VideoComponentEditor';
import { AudioComponentEditor } from './AudioComponentEditor';

interface ComponentEditorProps {
    component: Component;
    onChange: (component: Component) => void;
}

const componentEditors: Record<string, React.ComponentType<any>> = {
    text: TextComponentEditor,
    comparison: ComparisonComponentEditor,
    voice: VoiceComponentEditor,
    video: VideoComponentEditor,
    audio: AudioComponentEditor,
};

export const ComponentEditor: React.FC<ComponentEditorProps> = ({ component, onChange }) => {
    const EditorComponent = componentEditors[component.type];

    if (!EditorComponent) {
        return <div>No editor available for component type: {component.type}</div>;
    }

    return <EditorComponent component={component} onChange={onChange} />;
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\ComponentPalette.tsx ---

import React from 'react';
import { ComponentType } from '../../types/script';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';

interface ComponentPaletteProps {
    onDragStart: (type: ComponentType) => void;
}

interface ComponentOption {
    type: ComponentType;
    label: string;
    icon: string;
    description: string;
    create: () => any;
}

const components: ComponentOption[] = [
    {
        type: 'text',
        label: 'Text',
        icon: '📝',
        description: 'Add text with optional voice-over',
        create: () => ({
            type: 'text',
            text: '',
            style: {
                fontSize: '16px',
                fontWeight: 'normal',
                color: '#000000',
                lineHeight: '1.5',
            },
        }),
    },
    {
        type: 'title',
        label: 'Title',
        icon: '🔤',
        description: 'Large text with optional subtitle',
        create: () => ({
            type: 'title',
            text: '',
            style: {
                fontSize: '24px',
                fontWeight: 'bold',
                color: '#000000',
                lineHeight: '1.2',
            },
        }),
    },
    {
        type: 'comparison',
        label: 'Comparison',
        icon: '⚖️',
        description: 'Compare two options side by side',
        create: () => ({
            type: 'comparison',
            options: [],
            style: {
                width: '100%',
                height: 'auto',
            },
        }),
    },
    {
        type: 'countdown',
        label: 'Countdown',
        icon: '⏱️',
        description: 'Animated countdown timer',
        create: () => ({
            type: 'countdown',
            duration: 60,
            style: {
                width: '100%',
                height: 'auto',
            },
        }),
    },
    {
        type: 'transition',
        label: 'Transition',
        icon: '🔄',
        description: 'Smooth transition between scenes',
        create: () => ({
            type: 'transition',
            duration: 1,
            style: {
                width: '100%',
                height: 'auto',
            },
        }),
    },
    {
        type: 'voice',
        label: 'Voice',
        icon: '🎙️',
        description: 'Generate voice with synchronized captions',
        create: () => ({
            type: 'voice',
            text: '',
            style: {
                fontSize: '16px',
                fontWeight: 'normal',
                color: '#000000',
                lineHeight: '1.5',
            },
        }),
    },
    {
        type: 'video',
        label: 'Video',
        icon: '🎬',
        description: 'Add custom video content',
        create: () => ({
            type: 'video',
            videoUrl: '',
            style: {
                width: '100%',
                height: 'auto',
            },
        }),
    },
    {
        type: 'audio',
        label: 'Audio Effect',
        icon: '🎵',
        description: 'Add audio effect',
        create: () => ({
            type: 'audio',
            audioUrl: '',
            style: {
                volume: 1,
                loop: false,
                startTime: 0,
            },
        }),
    },
];

export const ComponentPalette: React.FC<ComponentPaletteProps> = ({ onDragStart }) => {
    return (
        <div>
            <h3 style={commonStyles.heading}>Components</h3>
            <div style={{
                display: 'flex',
                gap: theme.spacing.sm,
                flexWrap: 'wrap',
            }}>
                {components.map(({ type, label, icon, description }) => (
                    <div
                        key={type}
                        draggable
                        onDragStart={(e) => {
                            e.dataTransfer.setData('componentType', type);
                            onDragStart(type);
                        }}
                        style={{
                            backgroundColor: theme.colors.background.tertiary,
                            borderRadius: theme.borderRadius.md,
                            padding: theme.spacing.sm,
                            cursor: 'grab',
                            transition: 'all 0.2s ease',
                            border: `1px solid ${theme.colors.border}`,
                            flex: '0 0 auto',
                            display: 'flex',
                            alignItems: 'center',
                            gap: theme.spacing.sm,
                            minWidth: 'auto',
                        }}
                    >
                        <span style={{ fontSize: '1.2em' }}>{icon}</span>
                        <span style={{
                            color: theme.colors.text.primary,
                            fontWeight: 'bold',
                        }}>
                            {label}
                        </span>
                    </div>
                ))}
            </div>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\CountdownComponentEditor.tsx ---

import React from 'react';
import { CountdownComponent } from '../../types/script';
import { TextField, Grid, Switch, FormControlLabel } from '@mui/material';

interface CountdownComponentEditorProps {
    component: CountdownComponent;
    onChange: (component: CountdownComponent) => void;
}

export const CountdownComponentEditor: React.FC<CountdownComponentEditorProps> = ({ component, onChange }) => {
    return (
        <Grid container spacing={2}>
            <Grid item xs={12}>
                <TextField
                    fullWidth
                    type="number"
                    label="Count From"
                    value={component.from}
                    onChange={(e) => onChange({
                        ...component,
                        from: parseInt(e.target.value) || 0
                    })}
                />
            </Grid>
            <Grid item xs={12}>
                <FormControlLabel
                    control={
                        <Switch
                            checked={component.sound ?? false}
                            onChange={(e) => onChange({
                                ...component,
                                sound: e.target.checked
                            })}
                        />
                    }
                    label="Play Sound"
                />
            </Grid>
        </Grid>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\DraggablePreview.tsx ---

import React, { useState, useRef } from 'react';
import { TextStyle } from '../../types/script';

interface DraggablePreviewProps {
    text: string;
    style: TextStyle;
    onChange: (updates: Partial<TextStyle>) => void;
}

export const DraggablePreview: React.FC<DraggablePreviewProps> = ({
    text,
    style,
    onChange,
}) => {
    const containerRef = useRef<HTMLDivElement>(null);
    const elementRef = useRef<HTMLDivElement>(null);
    const [isDragging, setIsDragging] = useState(false);
    const [isResizing, setIsResizing] = useState(false);
    const [startPos, setStartPos] = useState({ x: 0, y: 0 });

    const position = style.position || { x: 50, y: 50, width: 80 };

    const handleMouseDown = (e: React.MouseEvent, mode: 'drag' | 'resize') => {
        if (mode === 'drag') setIsDragging(true);
        if (mode === 'resize') setIsResizing(true);
        setStartPos({ x: e.clientX, y: e.clientY });
        e.preventDefault();
    };

    const handleMouseMove = (e: React.MouseEvent) => {
        if (!isDragging && !isResizing) return;
        if (!containerRef.current) return;

        const containerRect = containerRef.current.getBoundingClientRect();
        
        if (isDragging) {
            const dx = e.clientX - startPos.x;
            const dy = e.clientY - startPos.y;

            const newX = position.x + (dx / containerRect.width * 100);
            const newY = position.y + (dy / containerRect.height * 100);

            onChange({
                position: {
                    ...position,
                    x: Math.max(0, Math.min(100, newX)),
                    y: Math.max(0, Math.min(100, newY)),
                }
            });
        }

        if (isResizing) {
            const dx = e.clientX - startPos.x;
            const newWidth = position.width + (dx / containerRect.width * 100);

            onChange({
                position: {
                    ...position,
                    width: Math.max(10, Math.min(100, newWidth)),
                }
            });
        }

        setStartPos({ x: e.clientX, y: e.clientY });
    };

    const handleMouseUp = () => {
        setIsDragging(false);
        setIsResizing(false);
    };

    return (
        <div
            ref={containerRef}
            style={{
                position: 'relative',
                width: '100%',
                height: '400px',
                backgroundColor: '#1a1a1a',
                borderRadius: '8px',
                overflow: 'hidden',
                cursor: isDragging ? 'grabbing' : 'default',
            }}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseUp}
        >
            <div
                ref={elementRef}
                style={{
                    position: 'absolute',
                    left: `${position.x}%`,
                    top: `${position.y}%`,
                    width: `${position.width}%`,
                    transform: 'translate(-50%, -50%)',
                    cursor: isDragging ? 'grabbing' : 'grab',
                    userSelect: 'none',
                    backgroundColor: 'rgba(255, 255, 255, 0.1)',
                    padding: '20px',
                    borderRadius: '8px',
                    border: '2px solid rgba(255, 255, 255, 0.2)',
                }}
            >
                <div
                    style={{
                        padding: '10px',
                        fontFamily: style.fontFamily,
                        fontSize: `${style.fontSize}px`,
                        color: style.color || '#fff',
                        textAlign: style.textAlign || 'center',
                        fontWeight: style.fontWeight,
                    }}
                    onMouseDown={(e) => handleMouseDown(e, 'drag')}
                >
                    {text || 'Preview text will appear here...'}
                </div>
                <div
                    style={{
                        position: 'absolute',
                        right: '-5px',
                        top: '50%',
                        transform: 'translateY(-50%)',
                        width: '10px',
                        height: '20px',
                        backgroundColor: 'rgba(255, 255, 255, 0.5)',
                        cursor: 'ew-resize',
                        borderRadius: '4px',
                    }}
                    onMouseDown={(e) => handleMouseDown(e, 'resize')}
                />
            </div>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\ImageComponentEditor.tsx ---

import React, { useState } from 'react';
import { ImageComponent } from '../../types/script';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';
import { ColorPicker } from '../common/ColorPicker';
import { Slider } from '../common/Slider';
import { Switch } from '../common/Switch';

interface PexelsImage {
    id: number;
    thumbnail: string;
    url: string;
    photographer: string;
    width: number;
    height: number;
}

interface ImageComponentEditorProps {
    component: ImageComponent;
    onChange: (component: ImageComponent) => void;
}

export const ImageComponentEditor: React.FC<ImageComponentEditorProps> = ({
    component,
    onChange,
}) => {
    const [uploadingImage, setUploadingImage] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [searchQuery, setSearchQuery] = useState('');
    const [searching, setSearching] = useState(false);
    const [pexelsImages, setPexelsImages] = useState<PexelsImage[]>([]);
    const [showPexelsSearch, setShowPexelsSearch] = useState(false);

    const handleImageUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (!file) return;

        setUploadingImage(true);
        setError(null);

        try {
            const formData = new FormData();
            formData.append('file', file);

            const response = await fetch('http://localhost:5003/upload_image', {
                method: 'POST',
                body: formData,
            });

            if (!response.ok) {
                throw new Error('Failed to upload image');
            }

            const data = await response.json();
            onChange({
                ...component,
                imageUrl: data.url,
            });
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to upload image');
        } finally {
            setUploadingImage(false);
        }
    };

    const handlePexelsSearch = async () => {
        if (!searchQuery.trim()) return;

        setSearching(true);
        setError(null);

        try {
            const response = await fetch(`http://localhost:5003/search_pexels?query=${encodeURIComponent(searchQuery)}`);
            if (!response.ok) {
                throw new Error('Failed to search Pexels');
            }

            const images = await response.json();
            setPexelsImages(images);
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to search Pexels');
        } finally {
            setSearching(false);
        }
    };

    const handlePexelsSelect = async (pexelsImage: PexelsImage) => {
        setUploadingImage(true);
        setError(null);

        try {
            const response = await fetch('http://localhost:5003/download_pexels', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ url: pexelsImage.url }),
            });

            if (!response.ok) {
                throw new Error('Failed to download image');
            }

            const data = await response.json();
            onChange({
                ...component,
                imageUrl: data.url,
                style: {
                    ...component.style,
                    width: pexelsImage.width,
                    height: pexelsImage.height,
                },
            });
            setShowPexelsSearch(false);
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to download image');
        } finally {
            setUploadingImage(false);
        }
    };

    const handleStyleChange = (updates: Partial<ImageComponent['style']>) => {
        onChange({
            ...component,
            style: {
                ...component.style,
                ...updates,
            },
        });
    };

    const handleDropShadowChange = (updates: Partial<ImageComponent['style']['dropShadow']>) => {
        handleStyleChange({
            dropShadow: {
                ...component.style?.dropShadow,
                ...updates,
            },
        });
    };

    const handleBorderChange = (updates: Partial<ImageComponent['style']['border']>) => {
        handleStyleChange({
            border: {
                ...component.style?.border,
                ...updates,
            },
        });
    };

    return (
        <div style={styles.container}>
            {/* Image Upload */}
            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Image</h3>
                <div style={styles.uploadButtons}>
                    <input
                        type="file"
                        accept="image/*"
                        onChange={handleImageUpload}
                        style={{ display: 'none' }}
                        id="image-upload"
                    />
                    <label htmlFor="image-upload" style={styles.uploadButton}>
                        {uploadingImage ? 'Uploading...' : 'Upload Image'}
                    </label>
                    <button
                        onClick={() => setShowPexelsSearch(!showPexelsSearch)}
                        style={styles.uploadButton}
                    >
                        Search Pexels
                    </button>
                </div>

                {showPexelsSearch && (
                    <div style={styles.pexelsSearch}>
                        <div style={styles.searchBar}>
                            <input
                                type="text"
                                value={searchQuery}
                                onChange={(e) => setSearchQuery(e.target.value)}
                                onKeyDown={(e) => e.key === 'Enter' && handlePexelsSearch()}
                                placeholder="Search Pexels images..."
                                style={styles.searchInput}
                            />
                            <button
                                onClick={handlePexelsSearch}
                                style={styles.searchButton}
                                disabled={searching}
                            >
                                {searching ? 'Searching...' : 'Search'}
                            </button>
                        </div>
                        <div style={styles.pexelsResults}>
                            {pexelsImages.map((image) => (
                                <div
                                    key={image.id}
                                    onClick={() => handlePexelsSelect(image)}
                                    style={styles.pexelsImage}
                                >
                                    <img
                                        src={image.thumbnail}
                                        alt={`By ${image.photographer}`}
                                        style={styles.pexelsThumbnail}
                                    />
                                    <div style={styles.photographerCredit}>
                                        By {image.photographer}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                )}

                {error && <div style={styles.error}>{error}</div>}
                {component.imageUrl && (
                    <img
                        src={component.imageUrl}
                        alt="Preview"
                        style={styles.preview}
                    />
                )}
            </div>

            {/* Size and Position */}
            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Size & Position</h3>
                <Slider
                    label="Width"
                    value={component.style?.width ?? 400}
                    onChange={(value) => handleStyleChange({ width: value })}
                    min={50}
                    max={1920}
                />
                <Slider
                    label="Height"
                    value={component.style?.height ?? 400}
                    onChange={(value) => handleStyleChange({ height: value })}
                    min={50}
                    max={1080}
                />
                <Slider
                    label="X Position"
                    value={component.style?.position?.x ?? 0}
                    onChange={(value) => handleStyleChange({ position: { ...component.style?.position, x: value } })}
                    min={-1920}
                    max={1920}
                />
                <Slider
                    label="Y Position"
                    value={component.style?.position?.y ?? 0}
                    onChange={(value) => handleStyleChange({ position: { ...component.style?.position, y: value } })}
                    min={-1080}
                    max={1080}
                />
            </div>

            {/* Transform */}
            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Transform</h3>
                <Slider
                    label="Scale"
                    value={component.style?.scale ?? 1}
                    onChange={(value) => handleStyleChange({ scale: value })}
                    min={0.1}
                    max={5}
                    step={0.1}
                />
                <Slider
                    label="Rotation"
                    value={component.style?.rotation ?? 0}
                    onChange={(value) => handleStyleChange({ rotation: value })}
                    min={-180}
                    max={180}
                />
                <Slider
                    label="Opacity"
                    value={component.style?.opacity ?? 1}
                    onChange={(value) => handleStyleChange({ opacity: value })}
                    min={0}
                    max={1}
                    step={0.1}
                />
            </div>

            {/* Border */}
            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Border</h3>
                <Switch
                    label="Enable Border"
                    checked={component.style?.border?.enabled ?? false}
                    onChange={(checked) => handleBorderChange({ enabled: checked })}
                />
                {component.style?.border?.enabled && (
                    <>
                        <ColorPicker
                            label="Border Color"
                            color={component.style.border.color}
                            onChange={(color) => handleBorderChange({ color })}
                        />
                        <Slider
                            label="Border Width"
                            value={component.style.border.width}
                            onChange={(value) => handleBorderChange({ width: value })}
                            min={1}
                            max={20}
                        />
                    </>
                )}
            </div>

            {/* Drop Shadow */}
            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Drop Shadow</h3>
                <Switch
                    label="Enable Shadow"
                    checked={component.style?.dropShadow?.enabled ?? false}
                    onChange={(checked) => handleDropShadowChange({ enabled: checked })}
                />
                {component.style?.dropShadow?.enabled && (
                    <>
                        <ColorPicker
                            label="Shadow Color"
                            color={component.style.dropShadow.color}
                            onChange={(color) => handleDropShadowChange({ color })}
                        />
                        <Slider
                            label="Blur Radius"
                            value={component.style.dropShadow.blur}
                            onChange={(value) => handleDropShadowChange({ blur: value })}
                            min={0}
                            max={50}
                        />
                        <Slider
                            label="Spread"
                            value={component.style.dropShadow.spread}
                            onChange={(value) => handleDropShadowChange({ spread: value })}
                            min={0}
                            max={50}
                        />
                        <Slider
                            label="X Offset"
                            value={component.style.dropShadow.x}
                            onChange={(value) => handleDropShadowChange({ x: value })}
                            min={-50}
                            max={50}
                        />
                        <Slider
                            label="Y Offset"
                            value={component.style.dropShadow.y}
                            onChange={(value) => handleDropShadowChange({ y: value })}
                            min={-50}
                            max={50}
                        />
                    </>
                )}
            </div>
        </div>
    );
};

const styles = {
    container: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.lg,
    },
    section: {
        backgroundColor: theme.colors.background.secondary,
        padding: theme.spacing.md,
        borderRadius: theme.borderRadius.md,
    },
    sectionTitle: {
        margin: 0,
        marginBottom: theme.spacing.sm,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.md,
    },
    uploadButtons: {
        display: 'flex',
        gap: theme.spacing.sm,
        marginBottom: theme.spacing.md,
    },
    uploadButton: {
        ...commonStyles.button.primary,
        display: 'inline-block',
        cursor: 'pointer',
        marginBottom: theme.spacing.md,
    },
    preview: {
        width: '100%',
        height: '200px',
        objectFit: 'cover' as const,
        borderRadius: theme.borderRadius.sm,
        marginTop: theme.spacing.sm,
    },
    error: {
        color: theme.colors.error,
        marginTop: theme.spacing.sm,
        fontSize: theme.fontSizes.sm,
    },
    pexelsSearch: {
        marginTop: theme.spacing.md,
    },
    searchBar: {
        display: 'flex',
        gap: theme.spacing.sm,
        marginBottom: theme.spacing.md,
    },
    searchInput: {
        flex: 1,
        padding: theme.spacing.sm,
        backgroundColor: theme.colors.background.tertiary,
        border: `1px solid ${theme.colors.border}`,
        borderRadius: theme.borderRadius.sm,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
    },
    searchButton: {
        ...commonStyles.button.primary,
    },
    pexelsResults: {
        display: 'grid',
        gridTemplateColumns: 'repeat(auto-fill, minmax(150px, 1fr))',
        gap: theme.spacing.md,
        maxHeight: '400px',
        overflowY: 'auto',
    },
    pexelsImage: {
        cursor: 'pointer',
        borderRadius: theme.borderRadius.sm,
        overflow: 'hidden',
        backgroundColor: theme.colors.background.tertiary,
        transition: 'transform 0.2s',
        '&:hover': {
            transform: 'scale(1.05)',
        },
    },
    pexelsThumbnail: {
        width: '100%',
        height: '150px',
        objectFit: 'cover' as const,
    },
    photographerCredit: {
        padding: theme.spacing.xs,
        fontSize: theme.fontSizes.xs,
        color: theme.colors.text.secondary,
        textAlign: 'center' as const,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\PositioningScreen.tsx ---

import React, { useRef, useState, useEffect, useCallback } from 'react';
import { TextComponent } from '../../types/script';
import { theme } from '../../styles/theme';

const PREVIEW_WIDTH = 400; // Doubled from 200
const PREVIEW_HEIGHT = 712; // Doubled from 356
const SCALE_FACTOR = 2.7; // Halved from 5.4 since we doubled the preview size

interface Props {
    component: TextComponent;
    onPositionChange: (position: { x: number; y: number }) => void;
    onClose: () => void;
}

const getInitialPosition = (component: TextComponent) => {
    if (component.style?.position) {
        return {
            x: component.style.position.x / SCALE_FACTOR,
            y: component.style.position.y / SCALE_FACTOR,
        };
    }
    return {
        x: PREVIEW_WIDTH / 2,
        y: PREVIEW_HEIGHT / 2,
    };
};

export const PositioningScreen: React.FC<Props> = React.memo(({ component, onPositionChange, onClose }) => {
    const containerRef = useRef<HTMLDivElement>(null);
    const [state, setState] = useState(() => ({
        isDragging: false,
        position: getInitialPosition(component)
    }));

    const updatePosition = useCallback((clientX: number, clientY: number) => {
        if (containerRef.current) {
            const rect = containerRef.current.getBoundingClientRect();
            const x = Math.min(Math.max(0, clientX - rect.left), PREVIEW_WIDTH);
            const y = Math.min(Math.max(0, clientY - rect.top), PREVIEW_HEIGHT);
            
            setState(prev => ({
                ...prev,
                position: { x, y }
            }));
            onPositionChange({
                x: Math.round(x * SCALE_FACTOR),
                y: Math.round(y * SCALE_FACTOR),
            });
        }
    }, [onPositionChange]);

    const handleMouseDown = useCallback((e: React.MouseEvent) => {
        setState(prev => ({ ...prev, isDragging: true }));
        updatePosition(e.clientX, e.clientY);
    }, [updatePosition]);

    const handleMouseMove = useCallback((e: MouseEvent) => {
        if (state.isDragging) {
            updatePosition(e.clientX, e.clientY);
        }
    }, [state.isDragging, updatePosition]);

    const handleMouseUp = useCallback(() => {
        setState(prev => ({ ...prev, isDragging: false }));
    }, []);

    useEffect(() => {
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        return () => {
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
        };
    }, [handleMouseMove, handleMouseUp]);

    return (
        <div style={{
            display: 'flex',
            flexDirection: 'column',
            gap: theme.spacing.sm,
        }}>
            <div
                ref={containerRef}
                onMouseDown={handleMouseDown}
                style={{
                    width: PREVIEW_WIDTH,
                    height: PREVIEW_HEIGHT,
                    backgroundColor: '#1a1a1a',
                    position: 'relative',
                    borderRadius: theme.borderRadius.sm,
                    overflow: 'hidden',
                    cursor: state.isDragging ? 'grabbing' : 'grab',
                }}
            >
                {/* Grid lines */}
                <div style={{
                    position: 'absolute',
                    inset: 0,
                    backgroundImage: `
                        linear-gradient(to right, #333 1px, transparent 1px),
                        linear-gradient(to bottom, #333 1px, transparent 1px)
                    `,
                    backgroundSize: '40px 40px',
                    opacity: 0.5,
                    pointerEvents: 'none',
                }} />

                {/* Center dot */}
                <div
                    style={{
                        position: 'absolute',
                        left: state.position.x,
                        top: state.position.y,
                        width: 8,
                        height: 8,
                        backgroundColor: theme.colors.primary,
                        borderRadius: '50%',
                        transform: 'translate(-50%, -50%)',
                        pointerEvents: 'none',
                        boxShadow: '0 0 0 2px rgba(255, 255, 255, 0.3)',
                    }}
                />
            </div>

            {/* Position display */}
            <div style={{
                display: 'flex',
                gap: theme.spacing.md,
                justifyContent: 'center',
                color: theme.colors.text.secondary,
                fontSize: theme.fontSizes.sm,
            }}>
                <span>X: {Math.round(state.position.x * SCALE_FACTOR)}</span>
                <span>Y: {Math.round(state.position.y * SCALE_FACTOR)}</span>
            </div>
        </div>
    );
}); 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\ScriptEditor.tsx ---

import React, { useState } from 'react';
import { Script, ScriptComponent, ComponentType } from '../../types/script';
import { ComponentEditor } from './ComponentEditor';
import { StyleEditor } from './StyleEditor';
import { Player } from '@remotion/player';
import { ScriptVideo } from '../Video/ScriptVideo';
import { ComponentPalette } from './ComponentPalette';
import { Timeline } from './Timeline';
import '../../styles/timeline.css';
import { ConfigMenu } from '../ConfigMenu/ConfigMenu';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';
import { Modal } from '../common/Modal';
import { TemplateManager } from '../TemplateManager/TemplateManager';
import { CaptionTimeline } from './CaptionTimeline';

export const ScriptEditor: React.FC = () => {
    const [script, setScript] = useState<Script>({
        id: Date.now().toString(),
        title: 'New Quiz',
        components: [],
        captionTracks: [],
        settings: {
            defaultTextStyle: {
                fontSize: 40,
                color: 'white',
                fontFamily: 'Arial',
                textAlign: 'center',
            },
            defaultCaptionStyle: {
                fontSize: 24,
                color: 'white',
                fontFamily: 'Arial',
                textAlign: 'center',
            },
            background: {
                type: 'none',
            }
        },
    });

    const [selectedComponentId, setSelectedComponentId] = useState<string>();
    const [isConfigOpen, setIsConfigOpen] = useState(false);
    const [isTemplateManagerOpen, setIsTemplateManagerOpen] = useState(false);

    const handleComponentChange = (updated: ScriptComponent) => {
        setScript(prev => ({
            ...prev,
            components: prev.components.map(c => 
                c.id === updated.id ? updated : c
            ),
        }));
    };

    const handleComponentDelete = (id: string) => {
        setScript(prev => ({
            ...prev,
            components: prev.components.filter(c => c.id !== id),
        }));
        setSelectedComponentId(undefined);
    };

    const handleDragStart = (type: ComponentType) => {
        // This can be empty or add visual feedback
    };

    const handleReorder = (newComponents: ScriptComponent[]) => {
        setScript(prev => ({
            ...prev,
            components: newComponents,
        }));
    };

    const selectedComponent = script.components.find(c => c.id === selectedComponentId);

    // Calculate total duration, minimum 30 frames (1 second)
    const totalDuration = Math.max(
        ...script.components.map(comp => {
            const start = comp.startFrame || 0;
            const duration = comp.durationInFrames || 150; // Default 5 seconds if not specified
            return start + duration;
        }),
        30 // Minimum 1 second
    );

    const PreviewPanel = ({ script }: { script: Script }) => (
        <>
            <div style={{
                padding: theme.spacing.md,
                borderBottom: `1px solid ${theme.colors.border}`,
                backgroundColor: theme.colors.background.secondary,
            }}>
                <h3 style={{
                    ...commonStyles.heading,
                    margin: 0,
                    fontSize: '16px',
                }}>
                    Preview
                </h3>
            </div>
            <div style={{
                flex: 1,
                padding: theme.spacing.md,
                display: 'flex',
                flexDirection: 'column',
                gap: theme.spacing.md,
            }}>
                <div style={{
                    position: 'relative',
                    width: '100%',
                    aspectRatio: '9/16',
                    backgroundColor: '#000',
                    borderRadius: theme.borderRadius.md,
                    overflow: 'hidden',
                }}>
                    <Player
                        component={ScriptVideo}
                        durationInFrames={totalDuration}
                        fps={30}
                        compositionWidth={1080}
                        compositionHeight={1920}
                        style={{
                            width: '100%',
                            height: '100%',
                        }}
                        controls
                        autoPlay
                        loop
                        inputProps={{ script }}
                    />
                </div>
            </div>
        </>
    );

    return (
        <div style={{
            backgroundColor: theme.colors.background.primary,
            minHeight: '100vh',
            display: 'flex',
            flexDirection: 'column',
        }}>
            {/* Header */}
            <header style={{
                backgroundColor: theme.colors.background.secondary,
                padding: `${theme.spacing.sm} ${theme.spacing.md}`,
                borderBottom: `1px solid ${theme.colors.border}`,
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                height: '48px',
            }}>
                <h1 style={{ margin: 0, fontSize: '24px' }}>Video Editor</h1>
                <div style={{ display: 'flex', gap: theme.spacing.md }}>
                    <button
                        onClick={() => setIsTemplateManagerOpen(true)}
                        style={{
                            ...commonStyles.button.secondary,
                            display: 'flex',
                            alignItems: 'center',
                            gap: theme.spacing.sm,
                        }}
                    >
                        📋 Templates
                    </button>
                    <button
                        onClick={() => setIsConfigOpen(true)}
                        style={{
                            ...commonStyles.button.secondary,
                            display: 'flex',
                            alignItems: 'center',
                            gap: theme.spacing.sm,
                        }}
                    >
                        ⚙️ Settings
                    </button>
                </div>
            </header>

            {/* Main Content */}
            <div style={{
                display: 'grid',
                gridTemplateColumns: '4fr 1fr',
                gap: theme.spacing.sm,
                padding: theme.spacing.sm,
                flex: 1,
                height: 'calc(100vh - 48px)',
                overflow: 'hidden',
            }}>
                {/* Left Panel */}
                <div style={{
                    display: 'flex',
                    flexDirection: 'column',
                    gap: theme.spacing.sm,
                    overflow: 'hidden',
                }}>
                    {/* Component Palette */}
                    <div style={{
                        ...commonStyles.card,
                        padding: theme.spacing.sm,
                    }}>
                        <ComponentPalette onDragStart={handleDragStart} />
                    </div>

                    {/* Timeline Container */}
                    <div style={{
                        ...commonStyles.card,
                        padding: theme.spacing.sm,
                        display: 'flex',
                        flexDirection: 'column',
                        gap: theme.spacing.md,
                        overflow: 'visible',
                    }}>
                        {/* Main Timeline */}
                        <div>
                            <h3 style={{ 
                                color: theme.colors.text.primary, 
                                margin: 0,
                                marginBottom: theme.spacing.md,
                                fontSize: '16px',
                                fontWeight: 'bold',
                            }}>
                                Timeline
                            </h3>
                            <Timeline
                                script={script}
                                onReorder={handleReorder}
                                onSelect={setSelectedComponentId}
                                selectedId={selectedComponentId}
                                onDelete={handleComponentDelete}
                            />
                        </div>

                        {/* Caption Timeline */}
                        <CaptionTimeline
                            script={script}
                            onScriptChange={setScript}
                        />
                    </div>
                </div>

                {/* Right Panel */}
                <div style={{
                    flex: 1,
                    display: 'flex',
                    flexDirection: 'column',
                    padding: theme.spacing.md,
                    backgroundColor: theme.colors.background.primary,
                    overflow: 'auto',
                }}>
                    {/* Preview */}
                    <div style={{
                        position: 'relative',
                        width: '100%',
                        maxWidth: '300px',
                        margin: '0 auto',
                        aspectRatio: '9/16',
                        backgroundColor: '#000',
                        borderRadius: theme.borderRadius.lg,
                        overflow: 'hidden',
                    }}>
                        <Player
                            component={ScriptVideo}
                            durationInFrames={totalDuration}
                            fps={30}
                            compositionWidth={1080}
                            compositionHeight={1920}
                            style={{
                                width: '100%',
                                height: '100%',
                            }}
                            controls
                            autoPlay
                            loop
                            inputProps={{
                                script
                            }}
                        />
                    </div>
                </div>
            </div>

            {/* Component Editor Modal */}
            <Modal
                isOpen={!!selectedComponentId}
                onClose={() => setSelectedComponentId(undefined)}
                title={
                    selectedComponent && (
                        <h2 style={{
                            ...commonStyles.heading,
                            margin: 0,
                            display: 'flex',
                            alignItems: 'center',
                            gap: theme.spacing.sm,
                            color: theme.colors.text.primary,
                            fontSize: '20px',
                        }}>
                            <span style={{ fontSize: '1.2em' }}>
                                {selectedComponent.type === 'title' && '📑'}
                                {selectedComponent.type === 'text' && '📝'}
                                {selectedComponent.type === 'comparison' && '⚖️'}
                                {selectedComponent.type === 'countdown' && '⏲️'}
                                {selectedComponent.type === 'transition' && '🔄'}
                            </span>
                            Edit {selectedComponent.type.charAt(0).toUpperCase() + selectedComponent.type.slice(1)}
                        </h2>
                    )
                }
            >
                {selectedComponent && (
                    <ComponentEditor
                        component={selectedComponent}
                        onChange={handleComponentChange}
                        onDelete={handleComponentDelete}
                    />
                )}
            </Modal>

            <ConfigMenu 
                isOpen={isConfigOpen} 
                onClose={() => setIsConfigOpen(false)} 
                script={script}
                onScriptChange={setScript}
            />

            {/* Template Manager Modal */}
            <Modal
                isOpen={isTemplateManagerOpen}
                onClose={() => setIsTemplateManagerOpen(false)}
                title="Template Manager"
            >
                <TemplateManager
                    currentScript={script}
                    onTemplateSelect={(newScript) => {
                        setScript(newScript);
                        setIsTemplateManagerOpen(false);
                    }}
                />
            </Modal>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\TextComponentEditor.tsx ---

import React, { useState, useEffect } from 'react';
import { TextComponent } from '../../types/script';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';
import { PositioningScreen } from './PositioningScreen';

interface TextComponentEditorProps {
    component: TextComponent;
    onChange: (updated: TextComponent) => void;
}

// Predefined fonts list
const FONTS = {
    system: [
        'Arial',
        'Helvetica',
        'Times New Roman',
        'Georgia',
        'Verdana',
        'Roboto',
        'Open Sans',
        'Montserrat',
    ],
    getCustomFonts: (): string[] => {
        try {
            const savedFonts = localStorage.getItem('customFonts');
            if (savedFonts) {
                const fonts = JSON.parse(savedFonts);
                return fonts.map((font: { name: string }) => font.name);
            }
        } catch (error) {
            console.error('Error loading custom fonts:', error);
        }
        return [];
    },
};

const styles = {
    section: {
        backgroundColor: theme.colors.background.tertiary,
        padding: theme.spacing.md,
        borderRadius: theme.borderRadius.md,
        marginBottom: theme.spacing.md,
    },
    sectionTitle: {
        fontSize: '14px',
        fontWeight: 'bold',
        color: theme.colors.text.primary,
        margin: 0,
        marginBottom: theme.spacing.sm,
    },
    input: {
        width: '100%',
        padding: '10px 14px',
        borderRadius: '8px',
        border: `1px solid ${theme.colors.border}`,
        backgroundColor: theme.colors.background.tertiary,
        color: theme.colors.text.primary,
        fontSize: '14px',
        '&:focus': {
            outline: 'none',
            borderColor: theme.colors.primary,
        },
    },
    textarea: {
        ...commonStyles.input,
        minHeight: '120px',
        resize: 'vertical' as const,
        whiteSpace: 'pre-wrap',
        lineHeight: '1.5',
        padding: '12px 16px',
    },
    grid: {
        display: 'grid',
        gridTemplateColumns: 'repeat(2, 1fr)',
        gap: '20px',
    },
    previewArea: {
        width: '1920px',
        height: '1080px',
        backgroundColor: 'rgba(0, 0, 0, 0.8)',
        position: 'relative' as const,
        transform: 'scale(0.25)',
        transformOrigin: 'top left',
        cursor: 'pointer',
    },
    animationTimingGrid: {
        marginTop: '12px',
        display: 'grid',
        gap: '12px',
        gridTemplateColumns: '1fr 1fr',
    },
    animationInput: {
        width: '100%',
        padding: '8px 12px',
        borderRadius: '6px',
        border: `1px solid ${theme.colors.border}`,
        backgroundColor: theme.colors.background.tertiary,
        color: theme.colors.text.primary,
        fontSize: '14px',
        fontFamily: 'monospace',
    },
    animationLabel: {
        fontWeight: 'bold',
        marginBottom: '6px',
        color: theme.colors.text.primary,
        fontSize: '12px',
    },
};

export const TextComponentEditor: React.FC<TextComponentEditorProps> = ({
    component,
    onChange,
}) => {
    const style = component.style || {};
    const [customFonts, setCustomFonts] = useState<string[]>([]);
    const [isPositioningPopupOpen, setIsPositioningPopupOpen] = useState(false);

    useEffect(() => {
        const updateCustomFonts = () => {
            setCustomFonts(FONTS.getCustomFonts());
        };

        updateCustomFonts();
        window.addEventListener('storage', updateCustomFonts);
        return () => window.removeEventListener('storage', updateCustomFonts);
    }, []);

    const handleTextChange = (text: string) => {
        if (text && style.wordsPerLine && style.wordsPerLine > 0) {
            const cleanText = text.replace(/[\n\r]+/g, ' ').replace(/\s+/g, ' ').trim();
            const words = cleanText.split(' ');
            const lines = [];
            
            for (let i = 0; i < words.length; i += style.wordsPerLine) {
                const line = words.slice(i, i + style.wordsPerLine).join(' ');
                if (line) lines.push(line);
            }
            
            text = lines.join('\n');
        }

        onChange({
            ...component,
            text,
        });
    };

    const handleBlockStyleToggle = (value: string) => {
        console.log('Block style changed to:', value);
        
        let backgroundColor, textColor;
        if (value === 'white') {
            backgroundColor = '#FFFFFF';
            textColor = '#000000';
        } else if (value === 'black') {
            backgroundColor = '#000000';
            textColor = '#FFFFFF';
        } else {
            backgroundColor = undefined;
            textColor = '#FFFFFF';
        }

        console.log('Setting colors:', { backgroundColor, textColor });
        
        const newStyle = {
            ...style,
            blockStyle: { enabled: value !== 'disabled' },
            backgroundColor,
            color: textColor,
            textTransform: value !== 'disabled' ? 'uppercase' as const : 'none' as const,
            fontWeight: value !== 'disabled' ? 'bold' : 'normal',
            padding: value !== 'disabled' ? '20px 40px' : undefined,
            borderRadius: value !== 'disabled' ? '15px' : undefined,
            textAlign: value !== 'disabled' ? 'center' as const : (style.textAlign || 'center'),
        };
        
        console.log('New style:', newStyle);
        
        onChange({
            ...component,
            style: newStyle,
        });
    };

    const handlePositionChange = (position: { x: number; y: number }) => {
        onChange({
            ...component,
            style: {
                ...style,
                position,
            },
        });
    };

    return (
        <>
            {/* Basic Settings */}
            <div style={styles.grid}>
                <div>
                    <label style={styles.sectionTitle}>Duration (seconds)</label>
                    <input
                        type="number"
                        value={component.durationInFrames / 30}
                        onChange={(e) => onChange({
                            ...component,
                            durationInFrames: Math.max(1, parseFloat(e.target.value)) * 30,
                        })}
                        style={styles.input}
                        min="0.1"
                        step="0.1"
                    />
                </div>
                <div>
                    <label style={styles.sectionTitle}>Block Style</label>
                    <select
                        value={style.blockStyle?.enabled ? 
                            (style.backgroundColor === '#FFFFFF' ? 'white' : 'black') 
                            : 'disabled'}
                        onChange={(e) => handleBlockStyleToggle(e.target.value)}
                        style={styles.input}
                    >
                        <option value="disabled">Normal Text</option>
                        <option value="white">White Block with Black Text</option>
                        <option value="black">Black Block with White Text</option>
                    </select>
                </div>
            </div>

            {/* Content */}
            <div style={{ marginTop: theme.spacing.lg }}>
                <div style={{
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    marginBottom: theme.spacing.sm,
                }}>
                    <h3 style={styles.sectionTitle}>Content</h3>
                    <button style={{
                        backgroundColor: 'rgb(255, 75, 75)',
                        color: 'white',
                        border: 'none',
                        padding: '4px 8px',
                        borderRadius: '4px',
                        cursor: 'pointer',
                        fontSize: '13px',
                    }}>Delete</button>
                </div>
                <textarea
                    value={component.text}
                    onChange={(e) => handleTextChange(e.target.value)}
                    style={styles.textarea}
                    placeholder="Enter your text..."
                />
            </div>

            {/* Font Settings */}
            <div style={{ marginTop: theme.spacing.lg }}>
                <h3 style={styles.sectionTitle}>Font Settings</h3>
                <div style={styles.grid}>
                    <div>
                        <label style={styles.sectionTitle}>Font Family</label>
                        <select
                            value={style.fontFamily}
                            onChange={(e) => onChange({
                                ...component,
                                style: {
                                    ...style,
                                    fontFamily: e.target.value,
                                },
                            })}
                            style={styles.input}
                        >
                            <optgroup label="System Fonts">
                                {FONTS.system.map(font => (
                                    <option key={font} value={font}>{font}</option>
                                ))}
                            </optgroup>
                            {customFonts.length > 0 && (
                                <optgroup label="Custom Fonts">
                                    {customFonts.map(font => (
                                        <option key={font} value={font}>{font}</option>
                                    ))}
                                </optgroup>
                            )}
                        </select>
                    </div>
                    <div>
                        <label style={styles.sectionTitle}>Font Size (px)</label>
                        <input
                            type="number"
                            value={style.fontSize}
                            onChange={(e) => onChange({
                                ...component,
                                style: {
                                    ...style,
                                    fontSize: parseInt(e.target.value),
                                },
                            })}
                            style={styles.input}
                            min="12"
                            max="200"
                        />
                    </div>
                    <div>
                        <label style={styles.sectionTitle}>Font Weight</label>
                        <select
                            value={style.fontWeight}
                            onChange={(e) => onChange({
                                ...component,
                                style: {
                                    ...style,
                                    fontWeight: e.target.value,
                                },
                            })}
                            style={styles.input}
                        >
                            <option value="300">Light</option>
                            <option value="400">Regular</option>
                            <option value="500">Medium</option>
                            <option value="600">Semi Bold</option>
                            <option value="700">Bold</option>
                            <option value="800">Extra Bold</option>
                        </select>
                    </div>
                    <div>
                        <label style={styles.sectionTitle}>Line Height</label>
                        <select
                            value={style.lineHeight || '1.5'}
                            onChange={(e) => onChange({
                                ...component,
                                style: {
                                    ...style,
                                    lineHeight: e.target.value,
                                },
                            })}
                            style={styles.input}
                        >
                            <option value="1">Tight</option>
                            <option value="1.2">Compact</option>
                            <option value="1.5">Normal</option>
                            <option value="1.8">Relaxed</option>
                            <option value="2">Spacious</option>
                        </select>
                    </div>
                </div>
            </div>

            {/* Style Settings */}
            <div style={{ marginTop: theme.spacing.lg }}>
                <h3 style={styles.sectionTitle}>Style Settings</h3>
                <div style={styles.grid}>
                    <div>
                        <label style={styles.sectionTitle}>Text Color</label>
                        <div style={{ display: 'flex', gap: '8px' }}>
                            <input
                                type="color"
                                value={style.color || '#FFFFFF'}
                                onChange={(e) => onChange({
                                    ...component,
                                    style: {
                                        ...style,
                                        color: e.target.value,
                                    },
                                })}
                                style={{ ...styles.input, width: '50px', padding: '2px' }}
                            />
                            <input
                                type="text"
                                value={style.color || '#FFFFFF'}
                                onChange={(e) => onChange({
                                    ...component,
                                    style: {
                                        ...style,
                                        color: e.target.value,
                                    },
                                })}
                                style={{ ...styles.input, flex: 1 }}
                                placeholder="#FFFFFF"
                            />
                        </div>
                    </div>
                    <div>
                        <label style={styles.sectionTitle}>Text Alignment</label>
                        <select
                            value={style.textAlign || 'center'}
                            onChange={(e) => onChange({
                                ...component,
                                style: {
                                    ...style,
                                    textAlign: e.target.value as 'left' | 'center' | 'right' | 'justify',
                                },
                            })}
                            style={styles.input}
                        >
                            <option value="left">Left</option>
                            <option value="center">Center</option>
                            <option value="right">Right</option>
                            <option value="justify">Justify</option>
                        </select>
                    </div>
                </div>
            </div>

            {/* Animation Settings */}
            <div style={{ marginTop: theme.spacing.lg }}>
                <h3 style={styles.sectionTitle}>Animation Settings</h3>
                <div style={styles.grid}>
                    <div>
                        <label style={styles.sectionTitle}>Entrance Animation</label>
                        <select
                            value={style.animation?.in?.type || 'none'}
                            onChange={(e) => onChange({
                                ...component,
                                style: {
                                    ...style,
                                    animation: {
                                        ...style.animation,
                                        in: {
                                            ...style.animation?.in,
                                            type: e.target.value,
                                            startFrame: style.animation?.in?.startFrame || 0,
                                            endFrame: style.animation?.in?.endFrame || 30,
                                        },
                                    },
                                },
                            })}
                            style={styles.input}
                        >
                            <option value="none">None</option>
                            <option value="slide-left">Slide In from Left</option>
                            <option value="slide-right">Slide In from Right</option>
                        </select>
                        {style.animation?.in?.type && style.animation.in.type !== 'none' && (
                            <div style={styles.animationTimingGrid}>
                                <div>
                                    <label style={styles.animationLabel}>Start Frame</label>
                                    <input
                                        type="number"
                                        value={style.animation?.in?.startFrame ?? 0}
                                        onChange={(e) => {
                                            const newValue = parseInt(e.target.value);
                                            if (!isNaN(newValue)) {
                                                console.log('Updating in animation start frame to:', newValue);
                                                const updatedStyle = {
                                                    ...style,
                                                    animation: {
                                                        ...style.animation,
                                                        in: {
                                                            ...style.animation?.in,
                                                            startFrame: newValue,
                                                        },
                                                    },
                                                };
                                                console.log('Updated style:', updatedStyle);
                                                onChange({
                                                    ...component,
                                                    style: updatedStyle,
                                                });
                                            }
                                        }}
                                        style={styles.animationInput}
                                        min="0"
                                    />
                                </div>
                                <div>
                                    <label style={styles.animationLabel}>End Frame</label>
                                    <input
                                        type="number"
                                        value={style.animation?.in?.endFrame ?? 30}
                                        onChange={(e) => {
                                            const newValue = parseInt(e.target.value);
                                            if (!isNaN(newValue)) {
                                                console.log('Updating in animation end frame to:', newValue);
                                                const updatedStyle = {
                                                    ...style,
                                                    animation: {
                                                        ...style.animation,
                                                        in: {
                                                            ...style.animation?.in,
                                                            endFrame: newValue,
                                                        },
                                                    },
                                                };
                                                console.log('Updated style:', updatedStyle);
                                                onChange({
                                                    ...component,
                                                    style: updatedStyle,
                                                });
                                            }
                                        }}
                                        style={styles.animationInput}
                                        min={style.animation?.in?.startFrame ?? 0}
                                    />
                                </div>
                            </div>
                        )}
                    </div>
                    <div>
                        <label style={styles.sectionTitle}>Exit Animation</label>
                        <select
                            value={style.animation?.out?.type || 'none'}
                            onChange={(e) => {
                                const updatedStyle = {
                                    ...style,
                                    animation: {
                                        ...style.animation,
                                        out: {
                                            ...style.animation?.out,
                                            type: e.target.value,
                                            startFrame: style.animation?.out?.startFrame ?? 30,
                                            endFrame: style.animation?.out?.endFrame ?? 0,
                                        },
                                    },
                                };
                                console.log('Updated exit animation style:', updatedStyle);
                                onChange({
                                    ...component,
                                    style: updatedStyle,
                                });
                            }}
                            style={styles.input}
                        >
                            <option value="none">None</option>
                            <option value="slide-left">Slide Out to Left</option>
                            <option value="slide-right">Slide Out to Right</option>
                        </select>
                        {style.animation?.out?.type && style.animation.out.type !== 'none' && (
                            <div style={styles.animationTimingGrid}>
                                <div>
                                    <label style={styles.animationLabel}>Start Frame (from end)</label>
                                    <input
                                        type="number"
                                        value={style.animation?.out?.startFrame ?? 30}
                                        onChange={(e) => {
                                            const newValue = parseInt(e.target.value);
                                            if (!isNaN(newValue)) {
                                                console.log('Updating out animation start frame to:', newValue);
                                                const updatedStyle = {
                                                    ...style,
                                                    animation: {
                                                        ...style.animation,
                                                        out: {
                                                            ...style.animation?.out,
                                                            startFrame: newValue,
                                                        },
                                                    },
                                                };
                                                console.log('Updated style:', updatedStyle);
                                                onChange({
                                                    ...component,
                                                    style: updatedStyle,
                                                });
                                            }
                                        }}
                                        style={styles.animationInput}
                                        min={style.animation?.out?.endFrame ?? 0}
                                    />
                                </div>
                                <div>
                                    <label style={styles.animationLabel}>End Frame (from end)</label>
                                    <input
                                        type="number"
                                        value={style.animation?.out?.endFrame ?? 0}
                                        onChange={(e) => {
                                            const newValue = parseInt(e.target.value);
                                            if (!isNaN(newValue)) {
                                                console.log('Updating out animation end frame to:', newValue);
                                                const updatedStyle = {
                                                    ...style,
                                                    animation: {
                                                        ...style.animation,
                                                        out: {
                                                            ...style.animation?.out,
                                                            endFrame: newValue,
                                                        },
                                                    },
                                                };
                                                console.log('Updated style:', updatedStyle);
                                                onChange({
                                                    ...component,
                                                    style: updatedStyle,
                                                });
                                            }
                                        }}
                                        style={styles.animationInput}
                                        min="0"
                                    />
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            </div>

            {/* Position */}
            <div style={{ marginTop: theme.spacing.lg }}>
                <div style={{
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    marginBottom: theme.spacing.sm,
                }}>
                    <h3 style={styles.sectionTitle}>Position</h3>
                    <button
                        onClick={() => setIsPositioningPopupOpen(true)}
                        style={{
                            backgroundColor: theme.colors.primary,
                            color: theme.colors.text.primary,
                            border: 'none',
                            borderRadius: '4px',
                            padding: '4px 8px',
                            cursor: 'pointer',
                            fontSize: '13px',
                        }}
                    >
                        Open Large Preview
                    </button>
                </div>
                <div style={{
                    width: '200px',
                    height: '356px',
                    backgroundColor: '#1a1a1a',
                    position: 'relative',
                    borderRadius: theme.borderRadius.sm,
                    overflow: 'hidden',
                    cursor: 'pointer',
                }}
                onClick={(e) => {
                    const rect = e.currentTarget.getBoundingClientRect();
                    const x = (e.clientX - rect.left) * 5.4;
                    const y = (e.clientY - rect.top) * 5.4;
                    handlePositionChange({ x, y });
                }}>
                    {/* Grid lines */}
                    <div style={{
                        position: 'absolute',
                        inset: 0,
                        backgroundImage: `
                            linear-gradient(to right, #333 1px, transparent 1px),
                            linear-gradient(to bottom, #333 1px, transparent 1px)
                        `,
                        backgroundSize: '20px 20px',
                        opacity: 0.5,
                        pointerEvents: 'none',
                    }} />

                    {/* Center dot */}
                    <div style={{
                        position: 'absolute',
                        left: (style.position?.x || 0) / 5.4,
                        top: (style.position?.y || 0) / 5.4,
                        width: 6,
                        height: 6,
                        backgroundColor: theme.colors.primary,
                        borderRadius: '50%',
                        transform: 'translate(-50%, -50%)',
                        pointerEvents: 'none',
                        boxShadow: '0 0 0 2px rgba(255, 255, 255, 0.3)',
                    }} />
                </div>
            </div>

            {/* Positioning Popup */}
            {isPositioningPopupOpen && (
                <PositioningScreen
                    component={component}
                    onPositionChange={handlePositionChange}
                    onClose={() => setIsPositioningPopupOpen(false)}
                />
            )}
        </>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\Timeline.tsx ---

import React, { useState, useRef, useEffect } from 'react';
import { Script, BaseScriptComponent, ComponentType } from '../../types/script';
import { theme } from '../../styles/theme';
import { createComponent } from '../../utils/componentFactory';

interface TimelineProps {
    script: Script;
    onReorder: (components: BaseScriptComponent[]) => void;
    onSelect: (id: string) => void;
    selectedId?: string;
    onDelete: (id: string) => void;
    zoom?: number;
}

const TRACK_HEIGHT = 40;
const PIXELS_PER_SECOND = 100;
const FRAMES_PER_SECOND = 30;
const NUM_TRACKS = 5;

export const Timeline: React.FC<TimelineProps> = ({
    script,
    onReorder,
    onSelect,
    selectedId,
    onDelete,
    zoom = 1,
}) => {
    const [draggingId, setDraggingId] = useState<string | null>(null);
    const [dragOffset, setDragOffset] = useState(0);
    const containerRef = useRef<HTMLDivElement>(null);

    // Calculate timeline width based on the maximum end time of all components
    const timelineWidth = Math.max(
        ...script.components.map(comp => {
            const start = comp.startFrame || 0;
            const duration = comp.durationInFrames || 150;
            return (start + duration) / FRAMES_PER_SECOND * PIXELS_PER_SECOND * zoom;
        }),
        PIXELS_PER_SECOND * 10 * zoom // Minimum width of 10 seconds
    );

    useEffect(() => {
        // Scroll to show the rightmost component if it's out of view
        if (containerRef.current) {
            const maxEndTime = Math.max(...script.components.map(comp => {
                const start = comp.startFrame || 0;
                const duration = comp.durationInFrames || 150;
                return start + duration;
            }));
            const scrollPosition = (maxEndTime / FRAMES_PER_SECOND) * PIXELS_PER_SECOND * zoom;
            const clientWidth = containerRef.current.clientWidth;

            if (scrollPosition > clientWidth) {
                containerRef.current.scrollLeft = scrollPosition - clientWidth + 100;
            }
        }
    }, [script.components, zoom]);

    const handleDragStart = (e: React.DragEvent, component: BaseScriptComponent) => {
        e.stopPropagation();
        const rect = e.currentTarget.getBoundingClientRect();
        const offsetX = e.clientX - rect.left;
        setDragOffset(Math.round((offsetX / (PIXELS_PER_SECOND * zoom)) * FRAMES_PER_SECOND));
        setDraggingId(component.id);
        e.dataTransfer.effectAllowed = 'move';
    };

    const handleDrop = (e: React.DragEvent, trackIndex: number) => {
        e.preventDefault();
        e.stopPropagation();
        
        const rect = containerRef.current?.getBoundingClientRect();
        if (!rect) return;

        const scrollLeft = containerRef.current?.scrollLeft || 0;
        const x = e.clientX - rect.left + scrollLeft;
        const startFrame = Math.round((x / (PIXELS_PER_SECOND * zoom)) * FRAMES_PER_SECOND);

        if (draggingId) {
            // Update existing component position
            const updatedComponents = script.components.map(comp => {
                if (comp.id === draggingId) {
                    const newStartFrame = Math.max(0, startFrame - dragOffset);
                    const newComp = {
                        ...comp,
                        startFrame: newStartFrame,
                        track: trackIndex,
                    };
                    
                    // Only handle style for text components
                    if (comp.type === 'text' && 'style' in comp) {
                        return {
                            ...newComp,
                            style: {
                                ...comp.style,
                                position: comp.style.position
                            }
                        };
                    }
                    
                    return newComp;
                }
                return comp;
            });
            onReorder(updatedComponents);
        } else {
            // Handle new component from palette
            const componentType = e.dataTransfer.getData('componentType') as ComponentType;
            if (componentType) {
                const newComponent = createComponent(
                    componentType,
                    script.settings.defaultTextStyle,
                    script.settings.defaultCaptionStyle
                );
                newComponent.startFrame = Math.max(0, startFrame);
                newComponent.track = trackIndex;
                onReorder([...script.components, newComponent]);
            }
        }
        setDraggingId(null);
        setDragOffset(0);
    };

    const handleDrag = (e: React.DragEvent, trackIndex: number) => {
        e.preventDefault();
        e.stopPropagation();
        
        if (!draggingId || !containerRef.current || !e.clientX) return;

        const rect = containerRef.current.getBoundingClientRect();
        const scrollLeft = containerRef.current.scrollLeft;
        const x = e.clientX - rect.left + scrollLeft;
        const newStartFrame = Math.max(0, Math.round((x / (PIXELS_PER_SECOND * zoom)) * FRAMES_PER_SECOND) - dragOffset);

        // Auto-scroll when dragging near the right edge
        const SCROLL_THRESHOLD = 100; // pixels from the right edge
        const SCROLL_SPEED = 10;
        
        if (e.clientX > rect.right - SCROLL_THRESHOLD) {
            containerRef.current.scrollLeft += SCROLL_SPEED;
        }

        const updatedComponents = script.components.map(comp => {
            if (comp.id === draggingId) {
                return {
                    ...comp,
                    startFrame: newStartFrame,
                    track: trackIndex
                };
            }
            return comp;
        });

        onReorder(updatedComponents);
    };

    // Calculate timeline width including extra space for dragging
    const timelineWidthIncludingExtraSpace = Math.max(
        containerRef.current?.clientWidth || 0,
        script.components.reduce((max, comp) => {
            const endFrame = comp.startFrame + comp.durationInFrames;
            return Math.max(max, endFrame);
        }, 0) * (PIXELS_PER_SECOND * zoom) / FRAMES_PER_SECOND + 500 // Add extra space
    );

    return (
        <div 
            ref={containerRef}
            style={{
                overflow: 'auto',
                backgroundColor: theme.colors.background.tertiary,
                borderRadius: theme.borderRadius.sm,
            }}
        >
            <div style={{
                width: `${timelineWidthIncludingExtraSpace}px`,
                minHeight: TRACK_HEIGHT * NUM_TRACKS,
                position: 'relative',
            }}>
                {/* Time markers */}
                <div style={{
                    height: '20px',
                    borderBottom: `1px solid ${theme.colors.border}`,
                    position: 'relative',
                }}>
                    {Array.from({ length: Math.ceil(timelineWidthIncludingExtraSpace / PIXELS_PER_SECOND) }).map((_, i) => (
                        <div
                            key={i}
                            style={{
                                position: 'absolute',
                                left: `${i * PIXELS_PER_SECOND}px`,
                                height: '100%',
                                borderLeft: `1px solid ${theme.colors.border}`,
                            }}
                        >
                            <span style={{
                                position: 'absolute',
                                top: '2px',
                                left: '4px',
                                fontSize: '10px',
                                color: theme.colors.text.secondary,
                            }}>
                                {i}s
                            </span>
                        </div>
                    ))}
                </div>

                {/* Tracks */}
                {Array.from({ length: NUM_TRACKS }).map((_, trackIndex) => (
                    <div
                        key={trackIndex}
                        style={{
                            height: TRACK_HEIGHT,
                            borderBottom: `1px solid ${theme.colors.border}`,
                            position: 'relative',
                            backgroundColor: theme.colors.background.secondary,
                        }}
                        onDragOver={(e) => {
                            e.preventDefault();
                            handleDrag(e, trackIndex);
                        }}
                        onDrop={(e) => handleDrop(e, trackIndex)}
                    >
                        {script.components
                            .filter(comp => (comp.track || 0) === trackIndex)
                            .map(component => (
                                <div
                                    key={component.id}
                                    draggable
                                    onClick={() => onSelect(component.id)}
                                    onDragStart={(e) => handleDragStart(e, component as BaseScriptComponent)}
                                    onDragEnd={() => setDraggingId(null)}
                                    style={{
                                        position: 'absolute',
                                        left: `${((component.startFrame || 0) / FRAMES_PER_SECOND) * PIXELS_PER_SECOND * zoom}px`,
                                        width: `${((component.durationInFrames || 150) / FRAMES_PER_SECOND) * PIXELS_PER_SECOND * zoom}px`,
                                        height: TRACK_HEIGHT - 2,
                                        backgroundColor: selectedId === component.id ? theme.colors.primary : theme.colors.secondary,
                                        borderRadius: theme.borderRadius.sm,
                                        cursor: 'grab',
                                        display: 'flex',
                                        alignItems: 'center',
                                        padding: '0 8px',
                                        fontSize: '12px',
                                        color: 'white',
                                        whiteSpace: 'nowrap',
                                        overflow: 'hidden',
                                        textOverflow: 'ellipsis',
                                        transition: theme.transitions.fast,
                                    }}
                                >
                                    {component.type}
                                </div>
                        ))}
                    </div>
                ))}
            </div>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\TitleComponentEditor.tsx ---

import React from 'react';
import { TitleComponent } from '../../types/script';
import { TextField, Grid } from '@mui/material';

interface TitleComponentEditorProps {
    component: TitleComponent;
    onChange: (component: TitleComponent) => void;
}

export const TitleComponentEditor: React.FC<TitleComponentEditorProps> = ({ component, onChange }) => {
    return (
        <Grid container spacing={2}>
            <Grid item xs={12}>
                <TextField
                    fullWidth
                    label="Title Text"
                    value={component.text}
                    onChange={(e) => onChange({
                        ...component,
                        text: e.target.value
                    })}
                />
            </Grid>
            <Grid item xs={12}>
                <TextField
                    fullWidth
                    label="Subtitle"
                    value={component.subtitle || ''}
                    onChange={(e) => onChange({
                        ...component,
                        subtitle: e.target.value
                    })}
                />
            </Grid>
        </Grid>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\VideoComponentEditor.tsx ---

import React from 'react';
import { VideoComponent, AnimationOptions } from '../../types/script';
import { theme } from '../../styles/theme';

interface VideoComponentEditorProps {
    component: VideoComponent;
    onChange: (updated: VideoComponent) => void;
}

export const VideoComponentEditor: React.FC<VideoComponentEditorProps> = ({
    component,
    onChange,
}) => {
    const handleStyleChange = (updated: Partial<VideoComponent['style']>) => {
        onChange({
            ...component,
            style: {
                ...component.style,
                ...updated
            }
        });
    };

    const handleAnimationChange = (updates: Partial<AnimationOptions>) => {
        const currentAnimation = component.style?.animation || {
            type: 'none',
            direction: 'in',
            easing: 'easeInOut',
            duration: 30,
            delay: 0,
            stagger: 0
        };
        handleStyleChange({
            animation: {
                ...currentAnimation,
                ...updates,
            }
        });
    };

    const handleChromakeyChange = (updates: Partial<NonNullable<VideoComponent['style']>['chromakey']>) => {
        const currentChromakey = component.style?.chromakey || {
            enabled: false,
            color: '#00ff00',
            similarity: 0.4,
            smoothness: 0.1
        };
        handleStyleChange({
            chromakey: {
                ...currentChromakey,
                ...updates,
            }
        });
    };

    return (
        <div style={styles.container}>
            {/* Video URL */}
            <div style={styles.section}>
                <label style={styles.label}>Video URL:</label>
                <input
                    type="text"
                    value={component.videoUrl}
                    onChange={(e) => {
                        onChange({
                            ...component,
                            videoUrl: e.target.value
                        });
                    }}
                    style={styles.input}
                    placeholder="Enter video URL (supports video files and GIFs)..."
                />
            </div>

            {/* Size and Position */}
            <div style={styles.section}>
                <h4 style={styles.sectionTitle}>Size & Position</h4>
                <div style={styles.settingsGrid}>
                    <div>
                        <label style={styles.label}>Width (%):</label>
                        <input
                            type="number"
                            min="1"
                            max="100"
                            value={component.style?.width || 100}
                            onChange={(e) => handleStyleChange({ width: Number(e.target.value) })}
                            style={styles.input}
                        />
                    </div>
                    <div>
                        <label style={styles.label}>Height (%):</label>
                        <input
                            type="number"
                            min="1"
                            max="100"
                            value={component.style?.height || 100}
                            onChange={(e) => handleStyleChange({ height: Number(e.target.value) })}
                            style={styles.input}
                        />
                    </div>
                </div>

                <div style={styles.settingsGrid}>
                    <div>
                        <label style={styles.label}>X Position (%):</label>
                        <input
                            type="range"
                            min="-100"
                            max="100"
                            value={component.style?.position?.x || 0}
                            onChange={(e) => handleStyleChange({
                                position: {
                                    x: Number(e.target.value),
                                    y: component.style?.position?.y || 0
                                }
                            })}
                            style={styles.input}
                        />
                    </div>
                    <div>
                        <label style={styles.label}>Y Position (%):</label>
                        <input
                            type="range"
                            min="-100"
                            max="100"
                            value={component.style?.position?.y || 0}
                            onChange={(e) => handleStyleChange({
                                position: {
                                    x: component.style?.position?.x || 0,
                                    y: Number(e.target.value)
                                }
                            })}
                            style={styles.input}
                        />
                    </div>
                </div>
            </div>

            {/* Transform */}
            <div style={styles.section}>
                <h4 style={styles.sectionTitle}>Transform</h4>
                <div style={styles.settingsGrid}>
                    <div>
                        <label style={styles.label}>Scale:</label>
                        <input
                            type="number"
                            min="0.1"
                            max="5"
                            step="0.1"
                            value={component.style?.scale || 1}
                            onChange={(e) => handleStyleChange({ scale: Number(e.target.value) })}
                            style={styles.input}
                        />
                    </div>
                    <div>
                        <label style={styles.label}>Rotation (deg):</label>
                        <input
                            type="number"
                            min="-360"
                            max="360"
                            value={component.style?.rotation || 0}
                            onChange={(e) => handleStyleChange({ rotation: Number(e.target.value) })}
                            style={styles.input}
                        />
                    </div>
                    <div>
                        <label style={styles.label}>Opacity:</label>
                        <input
                            type="range"
                            min="0"
                            max="1"
                            step="0.1"
                            value={component.style?.opacity || 1}
                            onChange={(e) => handleStyleChange({ opacity: Number(e.target.value) })}
                            style={styles.input}
                        />
                    </div>
                </div>
            </div>

            {/* Playback Settings */}
            <div style={styles.section}>
                <h4 style={styles.sectionTitle}>Playback Settings</h4>
                <div style={styles.settingsGrid}>
                    <div>
                        <label style={styles.label}>Volume:</label>
                        <input
                            type="range"
                            min="0"
                            max="1"
                            step="0.1"
                            value={component.style?.volume || 1}
                            onChange={(e) => handleStyleChange({ volume: Number(e.target.value) })}
                            style={styles.input}
                        />
                    </div>
                    <div>
                        <label style={styles.label}>Playback Rate:</label>
                        <input
                            type="number"
                            min="0.5"
                            max="2"
                            step="0.1"
                            value={component.style?.playbackRate || 1}
                            onChange={(e) => handleStyleChange({ playbackRate: Number(e.target.value) })}
                            style={styles.input}
                        />
                    </div>
                </div>
                <div style={styles.row}>
                    <label style={styles.checkboxLabel}>
                        <input
                            type="checkbox"
                            checked={component.style?.loop || false}
                            onChange={(e) => handleStyleChange({ loop: e.target.checked })}
                        />
                        Loop Video
                    </label>
                    <label style={styles.checkboxLabel}>
                        <input
                            type="checkbox"
                            checked={component.style?.muted || false}
                            onChange={(e) => handleStyleChange({ muted: e.target.checked })}
                        />
                        Mute Audio
                    </label>
                </div>
            </div>

            {/* Animation Controls */}
            <div style={styles.section}>
                <h4 style={styles.sectionTitle}>Animation</h4>
                <div style={styles.row}>
                    <select
                        value={component.style?.animation?.type ?? 'none'}
                        onChange={(e) => handleAnimationChange({ type: e.target.value as AnimationOptions['type'] })}
                        style={styles.input}
                    >
                        <option value="none">None</option>
                        <option value="fade">Fade</option>
                        <option value="scale">Scale</option>
                        <option value="rotate">Rotate</option>
                        <option value="slide">Slide</option>
                    </select>
                </div>
                {component.style?.animation?.type !== 'none' && (
                    <>
                        <div style={styles.row}>
                            <select
                                value={component.style?.animation?.direction ?? 'in'}
                                onChange={(e) => handleAnimationChange({ direction: e.target.value as AnimationOptions['direction'] })}
                                style={styles.input}
                            >
                                <option value="in">In</option>
                                <option value="out">Out</option>
                            </select>
                            <select
                                value={component.style?.animation?.easing ?? 'easeInOut'}
                                onChange={(e) => handleAnimationChange({ easing: e.target.value as AnimationOptions['easing'] })}
                                style={styles.input}
                            >
                                <option value="linear">Linear</option>
                                <option value="easeIn">Ease In</option>
                                <option value="easeOut">Ease Out</option>
                                <option value="easeInOut">Ease In Out</option>
                            </select>
                        </div>
                        <div style={styles.row}>
                            <input
                                type="number"
                                value={component.style?.animation?.duration ?? 30}
                                onChange={(e) => handleAnimationChange({ duration: Number(e.target.value) })}
                                placeholder="Duration (frames)"
                                min="1"
                                style={styles.input}
                            />
                            <input
                                type="number"
                                value={component.style?.animation?.delay ?? 0}
                                onChange={(e) => handleAnimationChange({ delay: Number(e.target.value) })}
                                placeholder="Delay (frames)"
                                min="0"
                                style={styles.input}
                            />
                            <input
                                type="number"
                                value={component.style?.animation?.stagger ?? 0}
                                onChange={(e) => handleAnimationChange({ stagger: Number(e.target.value) })}
                                placeholder="Stagger (frames)"
                                min="0"
                                style={styles.input}
                            />
                        </div>
                    </>
                )}
            </div>

            {/* Chromakey Settings */}
            <div style={styles.section}>
                <h4 style={styles.sectionTitle}>Chromakey</h4>
                <div style={styles.row}>
                    <label style={styles.checkboxLabel}>
                        <input
                            type="checkbox"
                            checked={component.style?.chromakey?.enabled || false}
                            onChange={(e) => handleChromakeyChange({ enabled: e.target.checked })}
                        />
                        Enable Chromakey
                    </label>
                </div>
                {component.style?.chromakey?.enabled && (
                    <>
                        <div style={styles.row}>
                            <div style={{ flex: 1 }}>
                                <label style={styles.label}>Color to Remove:</label>
                                <input
                                    type="color"
                                    value={component.style.chromakey.color || '#00ff00'}
                                    onChange={(e) => handleChromakeyChange({ color: e.target.value })}
                                    style={styles.input}
                                />
                            </div>
                        </div>
                        <div style={styles.settingsGrid}>
                            <div>
                                <label style={styles.label}>Color Similarity:</label>
                                <input
                                    type="range"
                                    min="0"
                                    max="1"
                                    step="0.01"
                                    value={component.style.chromakey.similarity || 0.4}
                                    onChange={(e) => handleChromakeyChange({ similarity: Number(e.target.value) })}
                                    style={styles.input}
                                />
                            </div>
                            <div>
                                <label style={styles.label}>Edge Smoothness:</label>
                                <input
                                    type="range"
                                    min="0"
                                    max="1"
                                    step="0.01"
                                    value={component.style.chromakey.smoothness || 0.1}
                                    onChange={(e) => handleChromakeyChange({ smoothness: Number(e.target.value) })}
                                    style={styles.input}
                                />
                            </div>
                        </div>
                    </>
                )}
            </div>
        </div>
    );
};

const styles = {
    container: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.md,
        height: '100%',
        backgroundColor: 'transparent',
    },
    section: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.sm,
        padding: theme.spacing.md,
        backgroundColor: theme.colors.background.secondary,
        borderRadius: theme.borderRadius.md,
        border: `1px solid ${theme.colors.border}`,
    },
    sectionTitle: {
        margin: '0 0 8px 0',
        color: theme.colors.text.primary,
        fontSize: '1rem',
        fontWeight: 600,
    },
    label: {
        fontSize: '0.9rem',
        fontWeight: 500,
        color: theme.colors.text.primary,
    },
    input: {
        padding: '0.5rem',
        borderRadius: theme.borderRadius.sm,
        border: `1px solid ${theme.colors.border}`,
        backgroundColor: theme.colors.background.tertiary,
        color: theme.colors.text.primary,
        width: '100%',
        minWidth: 0,
    },
    settingsGrid: {
        display: 'grid',
        gridTemplateColumns: '1fr 1fr',
        gap: theme.spacing.sm,
    },
    row: {
        display: 'flex',
        gap: theme.spacing.sm,
        alignItems: 'center',
        flexWrap: 'wrap' as const,
    },
    checkboxLabel: {
        display: 'flex',
        alignItems: 'center',
        gap: theme.spacing.sm,
        fontSize: '0.9rem',
        fontWeight: 500,
        color: theme.colors.text.primary,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\VoiceComponent.tsx ---

import React, { useState } from 'react';
import { VoiceComponent } from '../../types/script';
import { generateSpeech } from '../../services/elevenLabs';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';
import { DraggablePreview } from './DraggablePreview';

interface VoiceComponentEditorProps {
    component: VoiceComponent;
    onChange: (updated: VoiceComponent) => void;
}

type VoiceStatus = 'none' | 'generating' | 'success' | 'error';

const styles = {
    container: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: '20px',
    },
    section: {
        backgroundColor: theme.colors.background.secondary,
        padding: theme.spacing.lg,
        borderRadius: theme.borderRadius.md,
        border: `1px solid ${theme.colors.border}`,
    },
    label: {
        ...commonStyles.label,
        color: theme.colors.text.primary,
        display: 'block',
        marginBottom: theme.spacing.xs,
    },
    input: {
        ...commonStyles.input,
        backgroundColor: theme.colors.background.tertiary,
        border: `1px solid ${theme.colors.border}`,
        color: theme.colors.text.primary,
        padding: theme.spacing.sm,
        borderRadius: theme.borderRadius.sm,
        width: '100%',
    },
    button: {
        ...commonStyles.button.primary,
        display: 'flex',
        alignItems: 'center',
        gap: theme.spacing.sm,
        padding: `${theme.spacing.sm} ${theme.spacing.md}`,
    },
    grid: {
        display: 'grid',
        gridTemplateColumns: '1fr 1fr',
        gap: '20px',
    },
};

export const VoiceComponentEditor: React.FC<VoiceComponentEditorProps> = ({
    component,
    onChange,
}) => {
    const [voiceStatus, setVoiceStatus] = useState<VoiceStatus>(
        component.audioUrl ? 'success' : 'none'
    );
    const [errorMessage, setErrorMessage] = useState<string>('');
    const style = component.style || {};

    const handleVoiceGeneration = async () => {
        try {
            if (!component.text) {
                setErrorMessage('Please enter text for voice generation');
                return;
            }

            setVoiceStatus('generating');
            setErrorMessage('');
            
            const { audioUrl, wordTimings } = await generateSpeech({
                text: component.text,
                voiceId: component.voiceSettings?.voiceId || 'GhJYgP4Lrji0pwS3kQwv',
                settings: {
                    stability: component.voiceSettings?.stability || 0.75,
                    similarity_boost: component.voiceSettings?.similarity_boost || 0.75,
                },
            });

            onChange({
                ...component,
                audioUrl,
                wordTimings,
            });
            setVoiceStatus('success');
        } catch (error) {
            console.error('Voice generation failed:', error);
            setVoiceStatus('error');
            setErrorMessage(error instanceof Error ? error.message : 'Voice generation failed');
        }
    };

    const getStatusColor = () => {
        switch (voiceStatus) {
            case 'generating': return '#ffd700';
            case 'success': return '#4caf50';
            case 'error': return '#f44336';
            default: return '#007bff';
        }
    };

    return (
        <div style={styles.container}>
            {/* Voice Generation Section */}
            <div style={styles.section}>
                <h4 style={{ marginTop: 0 }}>Voice Generation</h4>
                <div style={{ marginBottom: theme.spacing.md }}>
                    <label style={styles.label}>Voice Text:</label>
                    <textarea
                        value={component.text}
                        onChange={(e) => onChange({
                            ...component,
                            text: e.target.value,
                        })}
                        style={{
                            ...styles.input,
                            minHeight: '100px',
                        }}
                        placeholder="Enter text for voice generation..."
                    />
                </div>

                <div style={styles.grid}>
                    <div>
                        <label style={styles.label}>Voice:</label>
                        <select
                            value={component.voiceSettings?.voiceId}
                            onChange={(e) => onChange({
                                ...component,
                                voiceSettings: {
                                    ...component.voiceSettings,
                                    voiceId: e.target.value,
                                },
                            })}
                            style={styles.input}
                        >
                            <option value="GhJYgP4Lrji0pwS3kQwv">Josh (Default)</option>
                            <option value="21m00Tcm4TlvDq8ikWAM">Rachel</option>
                            <option value="AZnzlk1XvdvUeBnXmlld">Domi</option>
                            <option value="EXAVITQu4vr4xnSDxMaL">Bella</option>
                            <option value="MF3mGyEYCl7XYWbV9V6O">Elli</option>
                        </select>
                    </div>

                    <div>
                        <label style={styles.label}>Stability:</label>
                        <input
                            type="range"
                            min="0"
                            max="100"
                            value={((component.voiceSettings?.stability || 0.75) * 100)}
                            onChange={(e) => onChange({
                                ...component,
                                voiceSettings: {
                                    ...component.voiceSettings,
                                    stability: parseInt(e.target.value) / 100,
                                },
                            })}
                            style={styles.input}
                        />
                    </div>

                    <div>
                        <label style={styles.label}>Similarity Boost:</label>
                        <input
                            type="range"
                            min="0"
                            max="100"
                            value={((component.voiceSettings?.similarity_boost || 0.75) * 100)}
                            onChange={(e) => onChange({
                                ...component,
                                voiceSettings: {
                                    ...component.voiceSettings,
                                    similarity_boost: parseInt(e.target.value) / 100,
                                },
                            })}
                            style={styles.input}
                        />
                    </div>
                </div>

                <div style={{ marginTop: theme.spacing.md }}>
                    <button
                        onClick={handleVoiceGeneration}
                        disabled={voiceStatus === 'generating'}
                        style={{
                            ...styles.button,
                            backgroundColor: getStatusColor(),
                        }}
                    >
                        {voiceStatus === 'generating' && (
                            <div style={{
                                width: '16px',
                                height: '16px',
                                border: '2px solid white',
                                borderTop: '2px solid transparent',
                                borderRadius: '50%',
                                animation: 'spin 1s linear infinite',
                            }}>
                                <style>
                                    {`
                                        @keyframes spin {
                                            0% { transform: rotate(0deg); }
                                            100% { transform: rotate(360deg); }
                                        }
                                    `}
                                </style>
                            </div>
                        )}
                        {voiceStatus === 'generating' ? 'Generating...' : 
                         voiceStatus === 'success' ? 'Regenerate Voice' : 
                         voiceStatus === 'error' ? 'Try Again' : 
                         'Generate Voice'}
                    </button>
                    {voiceStatus === 'success' && (
                        <span style={{ color: '#4caf50', marginLeft: '10px' }}>✓ Voice generated successfully</span>
                    )}
                    {voiceStatus === 'error' && (
                        <span style={{ color: '#f44336', marginLeft: '10px' }}>⚠️ {errorMessage}</span>
                    )}
                </div>

                {/* Audio Preview */}
                {component.audioUrl && (
                    <div style={{ marginTop: theme.spacing.md }}>
                        <label style={styles.label}>Preview Audio:</label>
                        <audio
                            controls
                            src={component.audioUrl}
                            style={{ width: '100%' }}
                        />
                    </div>
                )}
            </div>

            {/* Caption Settings */}
            <div style={styles.section}>
                <div style={{ 
                    display: 'flex', 
                    alignItems: 'center', 
                    gap: theme.spacing.md,
                    marginBottom: theme.spacing.md 
                }}>
                    <h4 style={{ margin: 0 }}>Caption Settings</h4>
                    <label style={{
                        display: 'flex',
                        alignItems: 'center',
                        gap: theme.spacing.sm,
                    }}>
                        <input
                            type="checkbox"
                            checked={component.showCaptions}
                            onChange={(e) => onChange({
                                ...component,
                                showCaptions: e.target.checked,
                            })}
                        />
                        Show Captions
                    </label>
                </div>

                {component.showCaptions && (
                    <>
                        {/* Text Styling */}
                        <div style={styles.grid}>
                            <div>
                                <label style={styles.label}>Font Size:</label>
                                <input
                                    type="number"
                                    value={style.fontSize || 24}
                                    onChange={(e) => onChange({
                                        ...component,
                                        style: {
                                            ...style,
                                            fontSize: parseInt(e.target.value),
                                        },
                                    })}
                                    style={styles.input}
                                    min="12"
                                    max="72"
                                />
                            </div>

                            <div>
                                <label style={styles.label}>Font Family:</label>
                                <select
                                    value={style.fontFamily || 'Arial'}
                                    onChange={(e) => onChange({
                                        ...component,
                                        style: {
                                            ...style,
                                            fontFamily: e.target.value,
                                        },
                                    })}
                                    style={styles.input}
                                >
                                    <option value="Arial">Arial</option>
                                    <option value="Times New Roman">Times New Roman</option>
                                    <option value="Helvetica">Helvetica</option>
                                    <option value="Georgia">Georgia</option>
                                    <option value="Verdana">Verdana</option>
                                </select>
                            </div>

                            <div>
                                <label style={styles.label}>Text Color:</label>
                                <input
                                    type="color"
                                    value={style.color || '#ffffff'}
                                    onChange={(e) => onChange({
                                        ...component,
                                        style: {
                                            ...style,
                                            color: e.target.value,
                                        },
                                    })}
                                    style={styles.input}
                                />
                            </div>

                            <div>
                                <label style={styles.label}>Background Color:</label>
                                <input
                                    type="color"
                                    value={component.captionStyle?.backgroundColor || '#000000'}
                                    onChange={(e) => onChange({
                                        ...component,
                                        captionStyle: {
                                            ...component.captionStyle,
                                            backgroundColor: e.target.value,
                                        },
                                    })}
                                    style={styles.input}
                                />
                            </div>

                            <div>
                                <label style={styles.label}>Font Weight:</label>
                                <select
                                    value={style.fontWeight || 'normal'}
                                    onChange={(e) => onChange({
                                        ...component,
                                        style: {
                                            ...style,
                                            fontWeight: e.target.value,
                                        },
                                    })}
                                    style={styles.input}
                                >
                                    <option value="normal">Normal</option>
                                    <option value="bold">Bold</option>
                                    <option value="lighter">Light</option>
                                </select>
                            </div>

                            <div>
                                <label style={styles.label}>Text Alignment:</label>
                                <select
                                    value={style.textAlign || 'center'}
                                    onChange={(e) => onChange({
                                        ...component,
                                        style: {
                                            ...style,
                                            textAlign: e.target.value as 'left' | 'center' | 'right',
                                        },
                                    })}
                                    style={styles.input}
                                >
                                    <option value="left">Left</option>
                                    <option value="center">Center</option>
                                    <option value="right">Right</option>
                                </select>
                            </div>
                        </div>

                        {/* Position Preview */}
                        <div style={{ marginTop: theme.spacing.lg }}>
                            <h4 style={{ marginBottom: '10px' }}>Position & Preview</h4>
                            <DraggablePreview
                                text={component.text}
                                style={style}
                                onChange={(updates) => onChange({
                                    ...component,
                                    style: {
                                        ...style,
                                        ...updates,
                                    },
                                })}
                            />
                        </div>
                    </>
                )}
            </div>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\VoiceComponentEditor.tsx ---

import React, { useState } from 'react';
import { VoiceComponent } from '../../types/script';
import { generateSpeech, generateCaptions } from '../../services/elevenLabs';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';
import { CaptionPositioningScreen } from './CaptionPositioningScreen';

interface VoiceComponentEditorProps {
    component: VoiceComponent;
    onChange: (updated: VoiceComponent) => void;
}

type VoiceStatus = 'none' | 'generating' | 'success' | 'error';

const styles = {
    container: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: '20px',
    },
    section: {
        backgroundColor: theme.colors.background.secondary,
        padding: theme.spacing.lg,
        borderRadius: theme.borderRadius.md,
        border: `1px solid ${theme.colors.border}`,
    },
    label: {
        ...commonStyles.label,
        color: theme.colors.text.primary,
        display: 'block',
        marginBottom: theme.spacing.xs,
    },
    input: {
        ...commonStyles.input,
        backgroundColor: theme.colors.background.tertiary,
        border: `1px solid ${theme.colors.border}`,
        color: theme.colors.text.primary,
        padding: theme.spacing.sm,
        borderRadius: theme.borderRadius.sm,
        width: '100%',
    },
    button: {
        ...commonStyles.button.primary,
        display: 'flex',
        alignItems: 'center',
        gap: theme.spacing.sm,
        padding: `${theme.spacing.sm} ${theme.spacing.md}`,
    },
    grid: {
        display: 'grid',
        gridTemplateColumns: '1fr 1fr',
        gap: '20px',
    },
    modal: {
        position: 'fixed' as const,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        zIndex: 1000,
    },
    modalContent: {
        backgroundColor: '#fff',
        padding: theme.spacing.lg,
        borderRadius: theme.borderRadius.md,
        maxWidth: '90%',
        maxHeight: '90%',
        overflow: 'auto',
        position: 'relative' as const,
    },
};

export const VoiceComponentEditor: React.FC<VoiceComponentEditorProps> = ({
    component,
    onChange,
}) => {
    const [voiceStatus, setVoiceStatus] = useState<VoiceStatus>(
        component.audioUrl ? 'success' : 'none'
    );
    const [errorMessage, setErrorMessage] = useState<string>('');
    const [showPositioningScreen, setShowPositioningScreen] = useState(false);
    const style = component.style || {};

    const handleVoiceGeneration = async () => {
        try {
            if (!component.text) {
                setErrorMessage('Please enter text for voice generation');
                return;
            }

            setVoiceStatus('generating');
            setErrorMessage('');
            
            // Generate speech with the new interface
            const { audioUrl } = await generateSpeech({
                text: component.text,
                voiceId: component.voiceSettings?.voiceId || 'GhJYgP4Lrji0pwS3kQwv',
                settings: {
                    stability: component.voiceSettings?.stability || 0.75,
                    similarity_boost: component.voiceSettings?.similarity_boost || 0.75
                }
            });

            onChange({
                ...component,
                audioUrl,
                // Note: wordTimings are now included in the generateSpeech response
            });
            setVoiceStatus('success');
        } catch (error) {
            console.error('Voice generation failed:', error);
            setVoiceStatus('error');
            setErrorMessage(error instanceof Error ? error.message : 'Voice generation failed');
        }
    };

    const getStatusColor = () => {
        switch (voiceStatus) {
            case 'generating': return '#ffd700';
            case 'success': return '#4caf50';
            case 'error': return '#f44336';
            default: return '#007bff';
        }
    };

    return (
        <div style={styles.container}>
            {/* Voice Generation Section */}
            <div style={styles.section}>
                <h4 style={{ marginTop: 0 }}>Voice Generation</h4>
                <div style={{ marginBottom: theme.spacing.md }}>
                    <label style={styles.label}>Voice Text:</label>
                    <textarea
                        value={component.text}
                        onChange={(e) => onChange({
                            ...component,
                            text: e.target.value,
                        })}
                        style={{
                            ...styles.input,
                            minHeight: '100px',
                        }}
                        placeholder="Enter text for voice generation..."
                    />
                </div>

                <div style={styles.grid}>
                    <div>
                        <label style={styles.label}>Voice:</label>
                        <select
                            value={component.voiceSettings?.voiceId}
                            onChange={(e) => onChange({
                                ...component,
                                voiceSettings: {
                                    ...component.voiceSettings,
                                    voiceId: e.target.value,
                                },
                            })}
                            style={styles.input}
                        >
                            <option value="GhJYgP4Lrji0pwS3kQwv">Josh (Default)</option>
                            <option value="21m00Tcm4TlvDq8ikWAM">Rachel</option>
                            <option value="AZnzlk1XvdvUeBnXmlld">Domi</option>
                            <option value="EXAVITQu4vr4xnSDxMaL">Bella</option>
                            <option value="MF3mGyEYCl7XYWbV9V6O">Elli</option>
                        </select>
                    </div>

                    <div>
                        <label style={styles.label}>Stability:</label>
                        <input
                            type="range"
                            min="0"
                            max="100"
                            value={((component.voiceSettings?.stability || 0.75) * 100)}
                            onChange={(e) => onChange({
                                ...component,
                                voiceSettings: {
                                    ...component.voiceSettings,
                                    stability: parseInt(e.target.value) / 100,
                                },
                            })}
                            style={styles.input}
                        />
                    </div>
                </div>

                <div style={{ marginTop: theme.spacing.md }}>
                    <button
                        onClick={handleVoiceGeneration}
                        style={{
                            ...styles.button,
                            backgroundColor: getStatusColor(),
                        }}
                        disabled={voiceStatus === 'generating'}
                    >
                        {voiceStatus === 'generating' ? 'Generating...' : 'Generate Voice'}
                    </button>
                    {errorMessage && (
                        <div style={{ color: theme.colors.error, marginTop: theme.spacing.sm }}>
                            {errorMessage}
                        </div>
                    )}
                </div>

                {component.audioUrl && (
                    <div style={{ marginTop: theme.spacing.md }}>
                        <label style={styles.label}>Preview Audio:</label>
                        <audio
                            controls
                            src={component.audioUrl}
                            style={{ width: '100%' }}
                        />
                        
                        <div style={{ marginTop: theme.spacing.md }}>
                            <button
                                onClick={async () => {
                                    try {
                                        if (!component.audioUrl) return;

                                        // Get the audio file as a blob
                                        const response = await fetch(component.audioUrl);
                                        const audioBlob = await response.blob();
                                        
                                        // Create form data for transcription
                                        const formData = new FormData();
                                        formData.append('audio', audioBlob, 'speech.mp3');
                                        
                                        // Send to Whisper service
                                        const transcriptionResponse = await fetch('http://localhost:5000/transcribe', {
                                            method: 'POST',
                                            body: formData
                                        });

                                        if (!transcriptionResponse.ok) {
                                            throw new Error('Failed to generate captions');
                                        }

                                        const transcriptionData = await transcriptionResponse.json();
                                        
                                        // Update the component with captions
                                        onChange({
                                            ...component,
                                            wordTimings: transcriptionData.wordTimings,
                                            showCaptions: true,
                                            captionStyle: {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            }
                                        });
                                    } catch (error) {
                                        console.error('Error generating captions:', error);
                                        setErrorMessage('Failed to generate captions');
                                    }
                                }}
                                style={styles.button}
                                disabled={!component.audioUrl}
                            >
                                Generate Captions
                            </button>
                        </div>
                    </div>
                )}

                {/* Caption Settings */}
                {component.wordTimings && (
                    <div style={styles.section}>
                        <div style={{ 
                            display: 'flex', 
                            alignItems: 'center', 
                            gap: theme.spacing.md,
                            marginBottom: theme.spacing.md 
                        }}>
                            <h4 style={{ margin: 0 }}>Caption Settings</h4>
                            <label style={{
                                display: 'flex',
                                alignItems: 'center',
                                gap: theme.spacing.sm,
                                color: theme.colors.text.primary,
                            }}>
                                <input
                                    type="checkbox"
                                    checked={component.showCaptions}
                                    onChange={(e) => onChange({
                                        ...component,
                                        showCaptions: e.target.checked
                                    })}
                                />
                                Show Captions
                            </label>
                        </div>

                        {component.showCaptions && (
                            <div style={{ display: 'flex', flexDirection: 'column', gap: theme.spacing.md }}>
                                <div>
                                    <label style={styles.label}>Font Family:</label>
                                    <select
                                        value={component.captionStyle?.fontFamily || 'Arial'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    fontFamily: e.target.value
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    >
                                        <option value="Arial">Arial</option>
                                        <option value="Times New Roman">Times New Roman</option>
                                        <option value="Courier New">Courier New</option>
                                        <option value="Georgia">Georgia</option>
                                        <option value="Verdana">Verdana</option>
                                    </select>
                                </div>

                                <div>
                                    <label style={styles.label}>Font Size:</label>
                                    <input
                                        type="number"
                                        value={component.captionStyle?.fontSize || 24}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    fontSize: parseInt(e.target.value)
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <div>
                                    <label style={styles.label}>Font Weight:</label>
                                    <select
                                        value={component.captionStyle?.fontWeight || 'normal'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    fontWeight: e.target.value
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    >
                                        <option value="normal">Normal</option>
                                        <option value="bold">Bold</option>
                                        <option value="100">100</option>
                                        <option value="200">200</option>
                                        <option value="300">300</option>
                                        <option value="400">400</option>
                                        <option value="500">500</option>
                                        <option value="600">600</option>
                                        <option value="700">700</option>
                                        <option value="800">800</option>
                                        <option value="900">900</option>
                                    </select>
                                </div>

                                <div>
                                    <label style={styles.label}>Font Style:</label>
                                    <select
                                        value={component.captionStyle?.fontStyle || 'normal'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    fontStyle: e.target.value as 'normal' | 'italic'
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    >
                                        <option value="normal">Normal</option>
                                        <option value="italic">Italic</option>
                                    </select>
                                </div>

                                <div>
                                    <label style={styles.label}>Text Color:</label>
                                    <input
                                        type="color"
                                        value={component.captionStyle?.color || '#ffffff'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    color: e.target.value
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <div>
                                    <label style={styles.label}>Background Color:</label>
                                    <input
                                        type="color"
                                        value={component.captionStyle?.backgroundColor || 'rgba(0, 0, 0, 0.7)'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    backgroundColor: e.target.value
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <div>
                                    <label style={styles.label}>Position:</label>
                                    <select
                                        value={component.captionStyle?.position || 'bottom'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    position: e.target.value as 'top' | 'bottom'
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    >
                                        <option value="top">Top</option>
                                        <option value="bottom">Bottom</option>
                                    </select>
                                </div>

                                <div>
                                    <label style={styles.label}>Word Window:</label>
                                    <input
                                        type="number"
                                        min="1"
                                        max="10"
                                        value={component.captionStyle?.wordWindow || 1}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    wordWindow: parseInt(e.target.value)
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <div>
                                    <label style={styles.label}>Border Radius:</label>
                                    <input
                                        type="text"
                                        value={component.captionStyle?.borderRadius || '5px'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    borderRadius: e.target.value
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <div>
                                    <label style={styles.label}>Padding:</label>
                                    <input
                                        type="text"
                                        value={component.captionStyle?.padding || '10px 20px'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    padding: e.target.value
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <div>
                                    <label style={styles.label}>Box Shadow:</label>
                                    <input
                                        type="text"
                                        value={component.captionStyle?.boxShadow || 'none'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    boxShadow: e.target.value
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <div>
                                    <label style={styles.label}>Opacity:</label>
                                    <input
                                        type="range"
                                        min="0"
                                        max="1"
                                        step="0.1"
                                        value={component.captionStyle?.opacity || 1}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    opacity: parseFloat(e.target.value)
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <button
                                    onClick={() => setShowPositioningScreen(true)}
                                    style={styles.button}
                                >
                                    Open Positioning Screen
                                </button>

                                {showPositioningScreen && (
                                    <div style={styles.modal}>
                                        <div style={styles.modalContent}>
                                            <CaptionPositioningScreen
                                                style={component.captionStyle || {
                                                    fontSize: 24,
                                                    color: '#ffffff',
                                                    backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                    position: 'bottom',
                                                    wordWindow: 1
                                                }}
                                                onChange={(newStyle) => {
                                                    onChange({
                                                        ...component,
                                                        captionStyle: newStyle
                                                    });
                                                }}
                                            />
                                            <button
                                                onClick={() => setShowPositioningScreen(false)}
                                                style={styles.button}
                                            >
                                                Close
                                            </button>
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}
                    </div>
                )}
            </div>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\VoiceOverEditor.tsx ---

import React, { useState } from 'react';
import { ScriptComponent } from '../../types/script';
import { generateSpeech } from '../../services/elevenLabs';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';

interface VoiceOverEditorProps {
    component: ScriptComponent;
    onChange: (updated: ScriptComponent) => void;
}

type VoiceStatus = 'none' | 'generating' | 'success' | 'error';

const styles = {
    section: {
        backgroundColor: theme.colors.background.secondary,
        padding: theme.spacing.lg,
        borderRadius: theme.borderRadius.md,
        border: `1px solid ${theme.colors.border}`,
    },
    label: {
        ...commonStyles.label,
        color: theme.colors.text.primary,
        display: 'block',
        marginBottom: theme.spacing.xs,
    },
    input: {
        ...commonStyles.input,
        backgroundColor: theme.colors.background.tertiary,
        border: `1px solid ${theme.colors.border}`,
        color: theme.colors.text.primary,
        padding: theme.spacing.sm,
        borderRadius: theme.borderRadius.sm,
        width: '100%',
    },
    button: {
        ...commonStyles.button.primary,
        display: 'flex',
        alignItems: 'center',
        gap: theme.spacing.sm,
        padding: `${theme.spacing.sm} ${theme.spacing.md}`,
    },
};

export const VoiceOverEditor: React.FC<VoiceOverEditorProps> = ({
    component,
    onChange,
}) => {
    const [voiceStatus, setVoiceStatus] = useState<VoiceStatus>(
        component.voiceOver?.audioUrl ? 'success' : 'none'
    );
    const [errorMessage, setErrorMessage] = useState<string>('');

    const getComponentText = (comp: ScriptComponent): string => {
        switch (comp.type) {
            case 'comparison':
                return comp.question;
            case 'text':
            case 'title':
                return comp.text;
            default:
                return '';
        }
    };

    const handleVoiceGeneration = async () => {
        try {
            const text = getComponentText(component);
            if (!text) {
                setErrorMessage('No text available for voice generation');
                return;
            }

            setVoiceStatus('generating');
            setErrorMessage('');
            
            const { audioUrl, wordTimings } = await generateSpeech({
                text,
                voiceId: component.voiceOver?.voiceId || 'default',
                settings: {
                    stability: 0.75,
                    similarity_boost: 0.75,
                },
            });

            onChange({
                ...component,
                voiceOver: {
                    text,
                    audioUrl,
                    wordTimings,
                    voiceId: component.voiceOver?.voiceId || 'default',
                    settings: {
                        stability: 0.75,
                        similarity_boost: 0.75,
                    },
                },
            });
            setVoiceStatus('success');
        } catch (error) {
            console.error('Voice generation failed:', error);
            setVoiceStatus('error');
            setErrorMessage(error instanceof Error ? error.message : 'Voice generation failed');
        }
    };

    const getStatusColor = () => {
        switch (voiceStatus) {
            case 'generating': return '#ffd700';
            case 'success': return '#4caf50';
            case 'error': return '#f44336';
            default: return '#007bff';
        }
    };

    return (
        <div style={styles.section}>
            <div style={{
                display: 'flex',
                alignItems: 'center',
                gap: theme.spacing.md,
                marginBottom: theme.spacing.md,
            }}>
                <h3 style={{ margin: 0 }}>Voice Over</h3>
                <button
                    onClick={handleVoiceGeneration}
                    disabled={voiceStatus === 'generating'}
                    style={{
                        ...styles.button,
                        backgroundColor: getStatusColor(),
                    }}
                >
                    {voiceStatus === 'generating' && (
                        <div style={{
                            width: '16px',
                            height: '16px',
                            border: '2px solid white',
                            borderTop: '2px solid transparent',
                            borderRadius: '50%',
                            animation: 'spin 1s linear infinite',
                        }}>
                            <style>
                                {`
                                    @keyframes spin {
                                        0% { transform: rotate(0deg); }
                                        100% { transform: rotate(360deg); }
                                    }
                                `}
                            </style>
                        </div>
                    )}
                    {voiceStatus === 'generating' ? 'Generating...' : 
                     voiceStatus === 'success' ? 'Regenerate Voice' : 
                     voiceStatus === 'error' ? 'Try Again' : 
                     'Generate Voice'}
                </button>
                {voiceStatus === 'success' && (
                    <span style={{ color: '#4caf50' }}>✓ Voice generated successfully</span>
                )}
                {voiceStatus === 'error' && (
                    <span style={{ color: '#f44336' }}>⚠️ {errorMessage}</span>
                )}
            </div>

            {/* Caption Settings */}
            <div style={{ marginBottom: theme.spacing.md }}>
                <label style={{
                    ...styles.label,
                    display: 'flex',
                    alignItems: 'center',
                    gap: theme.spacing.sm,
                }}>
                    <input
                        type="checkbox"
                        checked={component.captions?.enabled ?? false}
                        onChange={(e) => onChange({
                            ...component,
                            captions: e.target.checked ? {
                                enabled: true,
                                displayMode: 'sync',
                                style: {
                                    fontSize: 24,
                                    color: 'white',
                                    textAlign: 'center',
                                },
                            } : undefined,
                        })}
                    />
                    Enable Captions
                </label>
            </div>

            {/* Audio Preview */}
            {component.voiceOver?.audioUrl && (
                <div style={{
                    marginTop: theme.spacing.md,
                    padding: theme.spacing.md,
                    backgroundColor: theme.colors.background.tertiary,
                    borderRadius: theme.borderRadius.md,
                }}>
                    <label style={styles.label}>Preview Audio:</label>
                    <audio
                        controls
                        src={component.voiceOver.audioUrl}
                        style={{ width: '100%' }}
                    />
                </div>
            )}
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Settings\BackgroundManager.tsx ---

import React, { useState, useEffect } from 'react';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';

interface BackgroundHistory {
    name: string;
    url: string;
    addedAt: string;
    type: 'image' | 'video' | 'none';
}

interface BackgroundManagerProps {
    onSelectBackground: (background: { 
        type: 'image' | 'video' | 'none'; 
        url?: string; 
        filePath?: string;
        durationInFrames?: number;
    }) => void;
}

export const BackgroundManager: React.FC<BackgroundManagerProps> = ({ onSelectBackground }) => {
    const [backgrounds, setBackgrounds] = useState<BackgroundHistory[]>([]);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);

    const loadBackgrounds = async () => {
        try {
            setLoading(true);
            const response = await fetch('http://localhost:3002/backgrounds/history');
            if (!response.ok) throw new Error('Failed to load backgrounds');
            const data = await response.json();
            setBackgrounds(data);
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to load backgrounds');
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        loadBackgrounds();
    }, []);

    const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (!file) return;

        const formData = new FormData();
        formData.append('file', file);

        try {
            setLoading(true);
            const response = await fetch('http://localhost:3002/set_background', {
                method: 'POST',
                body: formData,
            });

            if (!response.ok) throw new Error('Failed to upload background');
            
            const data = await response.json();
            await loadBackgrounds(); // Refresh the list
            
            // Select the newly uploaded background
            onSelectBackground({
                type: 'image',
                url: data.url,
                filePath: data.filePath
            });
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to upload background');
        } finally {
            setLoading(false);
        }
    };

    const handleRemoveBackground = async (name: string) => {
        try {
            setLoading(true);
            const response = await fetch('http://localhost:3002/remove_background', {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ name }),
            });

            if (!response.ok) throw new Error('Failed to remove background');
            await loadBackgrounds(); // Refresh the list
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to remove background');
        } finally {
            setLoading(false);
        }
    };

    return (
        <div style={styles.container}>
            <div style={styles.header}>
                <h3 style={styles.title}>Background Manager</h3>
                <input
                    type="file"
                    accept="image/*"
                    onChange={handleFileUpload}
                    style={{ display: 'none' }}
                    id="background-upload"
                />
                <label htmlFor="background-upload" style={styles.uploadButton}>
                    Upload New Background
                </label>
            </div>

            {error && <div style={styles.error}>{error}</div>}

            <div style={styles.grid}>
                {/* No Background Option */}
                <div 
                    style={styles.backgroundItem}
                    onClick={() => onSelectBackground({ type: 'none', url: '', filePath: '' })}
                >
                    <div style={styles.noBackgroundPreview}>
                        No Background
                    </div>
                    <div style={styles.backgroundName}>None</div>
                </div>

                {backgrounds.map((bg) => (
                    <div key={bg.name} style={styles.backgroundItem}>
                        <div 
                            style={styles.imagePreview}
                            onClick={() => onSelectBackground({
                                type: 'image',
                                url: bg.url,
                                filePath: bg.name
                            })}
                        >
                            <img src={bg.url} alt={bg.name} style={styles.previewImage} />
                        </div>
                        <div style={styles.backgroundInfo}>
                            <div style={styles.backgroundName}>{bg.name}</div>
                            <button
                                onClick={(e) => {
                                    e.stopPropagation();
                                    handleRemoveBackground(bg.name);
                                }}
                                style={styles.removeButton}
                            >
                                Remove
                            </button>
                        </div>
                    </div>
                ))}
            </div>

            {loading && <div style={styles.loading}>Loading...</div>}
        </div>
    );
};

const styles = {
    container: {
        padding: theme.spacing.md,
    },
    header: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: theme.spacing.lg,
    },
    title: {
        margin: 0,
        color: theme.colors.text.primary,
    },
    uploadButton: {
        ...commonStyles.button.primary,
        cursor: 'pointer',
    },
    grid: {
        display: 'grid',
        gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))',
        gap: theme.spacing.md,
        marginTop: theme.spacing.md,
    },
    backgroundItem: {
        border: `1px solid ${theme.colors.border}`,
        borderRadius: theme.borderRadius.md,
        overflow: 'hidden',
        backgroundColor: theme.colors.background.secondary,
    },
    imagePreview: {
        width: '100%',
        height: '150px',
        backgroundColor: theme.colors.background.tertiary,
        cursor: 'pointer',
        position: 'relative' as const,
    },
    noBackgroundPreview: {
        width: '100%',
        height: '150px',
        backgroundColor: theme.colors.background.tertiary,
        cursor: 'pointer',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        color: theme.colors.text.secondary,
    },
    previewImage: {
        width: '100%',
        height: '100%',
        objectFit: 'cover' as const,
    },
    backgroundInfo: {
        padding: theme.spacing.sm,
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
    },
    backgroundName: {
        color: theme.colors.text.primary,
        fontSize: '0.9em',
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap' as const,
    },
    removeButton: {
        ...commonStyles.button.secondary,
        color: theme.colors.error,
        padding: '4px 8px',
        fontSize: '0.8em',
    },
    error: {
        color: theme.colors.error,
        marginBottom: theme.spacing.md,
        padding: theme.spacing.sm,
        backgroundColor: 'rgba(244, 67, 54, 0.1)',
        borderRadius: theme.borderRadius.sm,
    },
    loading: {
        textAlign: 'center' as const,
        color: theme.colors.text.secondary,
        marginTop: theme.spacing.md,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Settings\FontManager.tsx ---

import React, { useState, useEffect } from 'react';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';

interface FontManagerProps {
    onClose: () => void;
}

interface CustomFont {
    name: string;
    url: string;
    format: 'truetype' | 'opentype';
}

const styles = {
    modal: {
        position: 'fixed' as const,
        top: '50%',
        left: '50%',
        transform: 'translate(-50%, -50%)',
        backgroundColor: theme.colors.background.secondary,
        padding: theme.spacing.xl,
        borderRadius: theme.borderRadius.lg,
        boxShadow: theme.shadows.lg,
        width: '90%',
        maxWidth: '600px',
        maxHeight: '80vh',
        overflow: 'auto',
        zIndex: 1000,
    },
    overlay: {
        position: 'fixed' as const,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.7)',
        zIndex: 999,
    },
    title: {
        margin: 0,
        marginBottom: theme.spacing.lg,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.xl,
    },
    fontList: {
        marginBottom: theme.spacing.lg,
    },
    fontItem: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        padding: theme.spacing.md,
        backgroundColor: theme.colors.background.tertiary,
        borderRadius: theme.borderRadius.sm,
        marginBottom: theme.spacing.sm,
    },
    button: {
        ...commonStyles.button,
        marginRight: theme.spacing.sm,
    },
    deleteButton: {
        backgroundColor: theme.colors.error,
        color: 'white',
        border: 'none',
        padding: `${theme.spacing.xs} ${theme.spacing.sm}`,
        borderRadius: theme.borderRadius.sm,
        cursor: 'pointer',
    },
    input: {
        display: 'none',
    },
};

export const FontManager: React.FC<FontManagerProps> = ({ onClose }) => {
    const [customFonts, setCustomFonts] = useState<CustomFont[]>([]);

    // Load fonts from background service
    useEffect(() => {
        const loadFonts = async () => {
            try {
                const response = await fetch('http://localhost:3003/fonts/dictionary');
                if (!response.ok) throw new Error('Failed to load fonts');
                const fontDict = await response.json();
                
                // Convert dictionary to array
                const fonts = Object.entries(fontDict).map(([name, data]: [string, any]) => ({
                    name,
                    url: data.url,
                    format: data.format
                }));
                setCustomFonts(fonts);

                // Load each font
                fonts.forEach(font => {
                    try {
                        const testFont = new FontFace(font.name, `url(${font.url})`);
                        testFont.load().then(loadedFont => {
                            document.fonts.add(loadedFont);
                        }).catch(error => {
                            console.error('Error loading font:', error);
                        });
                    } catch (error) {
                        console.error('Error creating font:', error);
                    }
                });
            } catch (error) {
                console.error('Error loading font dictionary:', error);
            }
        };

        loadFonts();
    }, []);

    const handleFileSelect = async (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (!file) return;

        // Check if it's an OTF or TTF file
        if (!file.name.match(/\.(otf|ttf)$/i)) {
            alert('Please select an OTF or TTF font file');
            return;
        }

        try {
            // Create form data
            const formData = new FormData();
            formData.append('file', file);

            // Upload font to font service
            const response = await fetch('http://localhost:3003/set_font', {
                method: 'POST',
                body: formData,
            });

            if (!response.ok) {
                throw new Error('Failed to upload font');
            }

            const result = await response.json();
            const { url, name } = result;
            const format = file.name.toLowerCase().endsWith('.otf') ? 'opentype' as const : 'truetype' as const;

            // Test if font can be loaded
            console.log('Loading font:', name, 'from URL:', url);
            const testFont = new FontFace(name, `url(${url})`);
            await testFont.load();
            document.fonts.add(testFont);
            console.log('Successfully loaded font:', name);

            // Add new font to list
            const newFont: CustomFont = { name, url, format };
            setCustomFonts(prev => [...prev, newFont]);

            // Force preview to reload fonts
            window.dispatchEvent(new Event('fontsUpdated'));

        } catch (error) {
            console.error('Error loading font:', error);
            alert('Error loading font. Please try another file.');
        }
    };

    const handleDelete = async (fontName: string) => {
        try {
            // Delete font from font service
            const response = await fetch('http://localhost:3003/delete_font', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ name: fontName }),
            });

            if (!response.ok) {
                throw new Error('Failed to delete font');
            }

            // Remove font from document.fonts
            const fontToRemove = Array.from(document.fonts).find(f => f.family === fontName);
            if (fontToRemove) {
                document.fonts.delete(fontToRemove);
                console.log('Removed font from document:', fontName);
            }

            // Update state
            setCustomFonts(prev => prev.filter(font => font.name !== fontName));

            // Force preview to reload fonts
            window.dispatchEvent(new Event('fontsUpdated'));

        } catch (error) {
            console.error('Error deleting font:', error);
            alert('Error deleting font. Please try again.');
        }
    };

    return (
        <>
            <div style={styles.overlay} onClick={onClose} />
            <div style={styles.modal}>
                <h2 style={styles.title}>Font Manager</h2>

                <div style={styles.fontList}>
                    {customFonts.map(font => (
                        <div key={font.name} style={styles.fontItem}>
                            <span style={{ 
                                fontFamily: `'${font.name}'`,
                                fontSize: '18px',
                            }}>
                                {font.name} - Sample Text
                            </span>
                            <button
                                style={styles.deleteButton}
                                onClick={() => handleDelete(font.name)}
                            >
                                Delete
                            </button>
                        </div>
                    ))}
                </div>

                <input
                    type="file"
                    accept=".otf,.ttf"
                    onChange={handleFileSelect}
                    id="font-file"
                    style={styles.input}
                />
                <label htmlFor="font-file" style={styles.button}>
                    Add Font
                </label>
                <button style={styles.button} onClick={onClose}>
                    Close
                </button>
            </div>
        </>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Settings\PositioningPopup.tsx ---

import React from 'react';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';

interface PositioningPopupProps {
    onClose: () => void;
    children: React.ReactNode;
}

const styles = {
    overlay: {
        position: 'fixed' as const,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.7)',
        zIndex: 9999,
    },
    modal: {
        position: 'fixed' as const,
        top: '50%',
        left: '50%',
        transform: 'translate(-50%, -50%)',
        backgroundColor: theme.colors.background.secondary,
        padding: theme.spacing.xl,
        borderRadius: theme.borderRadius.lg,
        boxShadow: theme.shadows.lg,
        width: '90vw',
        height: '90vh',
        display: 'flex',
        flexDirection: 'column' as const,
        zIndex: 10000,
    },
    header: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: theme.spacing.lg,
    },
    title: {
        margin: 0,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.xl,
    },
    closeButton: {
        ...commonStyles.button,
        padding: `${theme.spacing.xs} ${theme.spacing.sm}`,
    },
    content: {
        flex: 1,
        overflow: 'hidden',
        backgroundColor: theme.colors.background.tertiary,
        borderRadius: theme.borderRadius.md,
        position: 'relative' as const,
    },
    canvas: {
        width: '100%',
        height: '100%',
        position: 'relative' as const,
        overflow: 'hidden',
        transform: 'scale(2)',
        transformOrigin: 'top left',
    },
};

export const PositioningPopup: React.FC<PositioningPopupProps> = ({ onClose, children }) => {
    return (
        <>
            <div style={styles.overlay} onClick={onClose} />
            <div style={styles.modal}>
                <div style={styles.header}>
                    <h2 style={styles.title}>Precise Positioning</h2>
                    <button style={styles.closeButton} onClick={onClose}>
                        Close
                    </button>
                </div>
                <div style={styles.content}>
                    <div style={styles.canvas}>
                        {children}
                    </div>
                </div>
            </div>
        </>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Setup\ComparisonEditor.tsx ---

import React from 'react';
import {Comparison} from '../../types/quiz';
import { ImageSelector } from './ImageSelector';

interface ComparisonEditorProps {
  item: QuizItem;
  onChange: (item: QuizItem) => void;
  onDelete: () => void;
}

export const ComparisonEditor: React.FC<ComparisonEditorProps> = ({
  item,
  onChange,
  onDelete,
}) => {
  return (
    <div style={{
      border: '1px solid #ccc',
      padding: '20px',
      marginBottom: '20px',
      borderRadius: '8px',
    }}>
      <div style={{ marginBottom: '20px' }}>
        <label>
          Question:
          <input
            type="text"
            value={item.question}
            onChange={(e) => onChange({
              ...item,
              question: e.target.value,
              voiceover: e.target.value, // Auto-set voiceover to question
            })}
            style={{ width: '100%', padding: '8px' }}
          />
        </label>
      </div>

      <div style={{ display: 'flex', gap: '20px' }}>
        {/* Left Option */}
        <div style={{ flex: 1 }}>
          <h4>Left Option</h4>
          <input
            type="text"
            value={item.leftOption.text}
            onChange={(e) => onChange({
              ...item,
              leftOption: {
                ...item.leftOption,
                text: e.target.value,
              },
            })}
            placeholder="Left option text"
          />
          <ImageSelector
            currentImage={item.leftOption.image}
            searchTerm={item.leftOption.text}
            onSelect={(imageUrl) => onChange({
              ...item,
              leftOption: {
                ...item.leftOption,
                image: imageUrl,
              },
            })}
          />
        </div>

        {/* Right Option */}
        <div style={{ flex: 1 }}>
          <h4>Right Option</h4>
          <input
            type="text"
            value={item.rightOption.text}
            onChange={(e) => onChange({
              ...item,
              rightOption: {
                ...item.rightOption,
                text: e.target.value,
              },
            })}
            placeholder="Right option text"
          />
          <ImageSelector
            currentImage={item.rightOption.image}
            searchTerm={item.rightOption.text}
            onSelect={(imageUrl) => onChange({
              ...item,
              rightOption: {
                ...item.rightOption,
                image: imageUrl,
              },
            })}
          />
        </div>
      </div>

      <button onClick={onDelete} style={{ marginTop: '20px', color: 'red' }}>
        Delete Comparison
      </button>
    </div>
  );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Setup\ImagePicker.tsx ---

import React, { useState, useEffect } from 'react';
import { createClient } from 'pexels';

const client = createClient('rXEDE5m6pUxOXZPawHmzKj04Z29WlV2y0Us44ld2TmXwdZstXtHUIh2F');

interface ImagePickerProps {
  currentImage: string;
  searchTerm: string;
  onSelect: (imageUrl: string) => void;
}

export const ImagePicker: React.FC<ImagePickerProps> = ({
  currentImage,
  searchTerm,
  onSelect,
}) => {
  const [images, setImages] = useState<Array<{ url: string }>>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (searchTerm) {
      setLoading(true);
      client.photos.search({ query: searchTerm, per_page: 10 })
        .then(result => {
          if ('photos' in result) {
            setImages(result.photos.map(photo => ({
              url: photo.src.large
            })));
          }
          setLoading(false);
        })
        .catch(err => {
          console.error('Error fetching images:', err);
          setLoading(false);
        });
    }
  }, [searchTerm]);

  return (
    <div>
      {loading ? (
        <div>Loading images...</div>
      ) : (
        <div style={{
          display: 'grid',
          gridTemplateColumns: 'repeat(auto-fill, minmax(100px, 1fr))',
          gap: '10px',
          marginTop: '10px',
        }}>
          {images.map((image, index) => (
            <img
              key={index}
              src={image.url}
              alt={`Option ${index + 1}`}
              style={{
                width: '100%',
                height: '100px',
                objectFit: 'cover',
                cursor: 'pointer',
                border: currentImage === image.url ? '3px solid blue' : '1px solid #ccc',
              }}
              onClick={() => onSelect(image.url)}
            />
          ))}
        </div>
      )}
    </div>
  );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Setup\ImageSelector.tsx ---

import React, { useState, useEffect } from 'react';
import { createClient } from 'pexels';

const client = createClient('rXEDE5m6pUxOXZPawHmzKj04Z29WlV2y0Us44ld2TmXwdZstXtHUIh2F');

interface ImageSelectorProps {
    searchTerm: string;
    onSelect: (imageUrl: string) => void;
    currentImageUrl?: string;
}

export const ImageSelector: React.FC<ImageSelectorProps> = ({
    searchTerm,
    onSelect,
    currentImageUrl,
}) => {
    // ... rest of the component stays the same, just update property names
    // from currentImage to currentImageUrl
    // and image.url to photo.src.medium
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Setup\Setup.tsx ---

import React, { useState } from 'react';
import { Player } from '@remotion/player';
import { QuizVideo } from '../../QuizVideo';
import { QuizItem } from '../../data/quizData';
import { ComparisonEditor } from './ComparisonEditor';

export const Setup: React.FC = () => {
  const [quizItems, setQuizItems] = useState<QuizItem[]>([]);
  
  const addComparison = () => {
    setQuizItems([
      ...quizItems,
      {
        question: '',
        leftOption: {
          image: '',
          text: '',
        },
        rightOption: {
          image: '',
          text: '',
        },
        voiceover: '',
      },
    ]);
  };

  return (
    <div style={{ display: 'flex', gap: '20px', padding: '20px' }}>
      {/* Editor Section */}
      <div style={{ flex: 1 }}>
        <button onClick={addComparison}>Add Comparison</button>
        
        {quizItems.map((item, index) => (
          <ComparisonEditor
            key={index}
            item={item}
            onChange={(updatedItem) => {
              const newItems = [...quizItems];
              newItems[index] = updatedItem;
              setQuizItems(newItems);
            }}
            onDelete={() => {
              const newItems = quizItems.filter((_, i) => i !== index);
              setQuizItems(newItems);
            }}
          />
        ))}
      </div>

      {/* Preview Section */}
      <div style={{ flex: 1 }}>
        <Player
          component={QuizVideo}
          durationInFrames={1800}
          fps={30}
          compositionWidth={1080}
          compositionHeight={1920}
          style={{
            width: '100%',
            height: 'auto',
          }}
          inputProps={{
            quizConfig: {
              comparisons: quizItems
            }
          }}
        />
      </div>
    </div>
  );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\SetupPage.tsx ---

import React, {useState} from 'react';
import {Player} from '@remotion/player';
import {QuizConfig, Comparison} from '../types/quiz';
import {ComparisonEditor} from './ComparisonEditor';
import {QuizVideo} from './Video/QuizVideo';

export const SetupPage: React.FC = () => {
	const [quizConfig, setQuizConfig] = useState<QuizConfig>({
		comparisons: [],
	});

	// Calculate duration, minimum 1 second (30 frames)
	const videoDuration = Math.max(30, quizConfig.comparisons.length * 150);

	return (
		<div style={{
			display: 'grid',
			gridTemplateColumns: '1fr 1fr',
			gap: '20px',
			padding: '20px',
			height: '100vh',
			overflow: 'hidden',
		}}>
			{/* Left side - Editor Section */}
			<div style={{
				overflowY: 'auto',
				padding: '20px',
			}}>
				<h1>Quiz Video Setup</h1>
				<button
					onClick={() => {
						const newComparison: Comparison = {
							id: Date.now().toString(),
							question: '',
							leftOption: {
								text: '',
								imageUrl: '',
							},
							rightOption: {
								text: '',
								imageUrl: '',
							},
						};
						setQuizConfig(prev => ({
							...prev,
							comparisons: [...prev.comparisons, newComparison],
						}));
					}}
					style={{
						padding: '12px 24px',
						fontSize: '16px',
						cursor: 'pointer',
						backgroundColor: '#007bff',
						color: 'white',
						border: 'none',
						borderRadius: '4px',
						marginBottom: '20px',
					}}
				>
					Add New Comparison
				</button>

				<div style={{
					display: 'flex',
					flexDirection: 'column',
					gap: '20px',
				}}>
					{quizConfig.comparisons.map((comparison) => (
						<ComparisonEditor
							key={comparison.id}
							comparison={comparison}
							onChange={(updatedComparison) => {
								setQuizConfig(prev => ({
									...prev,
									comparisons: prev.comparisons.map(c => 
										c.id === updatedComparison.id ? updatedComparison : c
									),
								}));
							}}
							onDelete={() => {
								setQuizConfig(prev => ({
									...prev,
									comparisons: prev.comparisons.filter(c => c.id !== comparison.id),
								}));
							}}
						/>
					))}
				</div>
			</div>

			{/* Right side - Preview Section */}
			<div style={{
				backgroundColor: '#f8f9fa',
				padding: '20px',
				borderRadius: '8px',
				display: 'flex',
				flexDirection: 'column',
				height: '100%',
				overflowY: 'auto',
			}}>
				<h2 style={{marginBottom: '20px'}}>Preview</h2>
				
				{/* Debug Info */}
				<div style={{ 
					marginBottom: '20px', 
					padding: '10px', 
					backgroundColor: '#eee', 
					borderRadius: '4px' 
				}}>
					<h3>Debug Info:</h3>
					<pre style={{ whiteSpace: 'pre-wrap', wordBreak: 'break-word' }}>
						{JSON.stringify({
							comparisonsCount: quizConfig.comparisons.length,
							videoDuration,
							firstComparison: quizConfig.comparisons[0],
						}, null, 2)}
					</pre>
				</div>

				{/* Player Container */}
				<div style={{
					position: 'relative',
					width: '100%',
					paddingTop: '177.78%', // 16:9 aspect ratio
					backgroundColor: '#000',
					borderRadius: '8px',
					overflow: 'hidden',
				}}>
					<div style={{
						position: 'absolute',
						top: 0,
						left: 0,
						right: 0,
						bottom: 0,
					}}>
						<Player
							component={QuizVideo}
							inputProps={{
								quizConfig: quizConfig,
							}}
							durationInFrames={videoDuration}
							fps={30}
							compositionWidth={1080}
							compositionHeight={1920}
							style={{
								width: '100%',
								height: '100%',
							}}
							controls
							autoPlay
							loop
						/>
					</div>
				</div>
			</div>
		</div>
	);
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\TemplateManager\TemplateManager.tsx ---

import React, { useState, useEffect } from 'react';
import {
    Box,
    Button,
    Dialog,
    DialogTitle,
    DialogContent,
    DialogActions,
    TextField,
    List,
    ListItem,
    ListItemText,
    ListItemSecondaryAction,
    IconButton,
    Typography,
    Tooltip,
} from '@mui/material';
import DeleteIcon from '@mui/icons-material/Delete';
import DownloadIcon from '@mui/icons-material/Download';
import AddIcon from '@mui/icons-material/Add';
import { Template } from '../../types/template';
import { Script } from '../../types/script';
import {
    getTemplates,
    saveTemplate,
    deleteTemplate,
    scriptToTemplate,
    templateToScript,
} from '../../services/templateService';

interface TemplateManagerProps {
    currentScript?: Script;
    onTemplateSelect?: (script: Script) => void;
}

export const TemplateManager: React.FC<TemplateManagerProps> = ({
    currentScript,
    onTemplateSelect,
}) => {
    const [templates, setTemplates] = useState<Template[]>([]);
    const [isAddDialogOpen, setIsAddDialogOpen] = useState(false);
    const [newTemplateName, setNewTemplateName] = useState('');
    const [newTemplateDescription, setNewTemplateDescription] = useState('');

    useEffect(() => {
        loadTemplates();
    }, []);

    const loadTemplates = () => {
        const loadedTemplates = getTemplates();
        setTemplates(loadedTemplates);
    };

    const handleSaveTemplate = () => {
        if (!currentScript || !newTemplateName) return;

        const template = scriptToTemplate(
            currentScript,
            newTemplateName,
            newTemplateDescription
        );
        saveTemplate(template);
        setIsAddDialogOpen(false);
        setNewTemplateName('');
        setNewTemplateDescription('');
        loadTemplates();
    };

    const handleDeleteTemplate = (templateId: string) => {
        deleteTemplate(templateId);
        loadTemplates();
    };

    const handleTemplateSelect = (template: Template) => {
        if (onTemplateSelect) {
            const script = templateToScript(template);
            onTemplateSelect(script);
        }
    };

    const handleDownloadTemplate = (template: Template) => {
        const templateJson = JSON.stringify(template, null, 2);
        const blob = new Blob([templateJson], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${template.name.toLowerCase().replace(/\s+/g, '_')}_template.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    };

    return (
        <Box>
            <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
                <Typography variant="h6">Templates</Typography>
                <Button
                    variant="contained"
                    color="primary"
                    startIcon={<AddIcon />}
                    onClick={() => setIsAddDialogOpen(true)}
                    disabled={!currentScript}
                >
                    Save as Template
                </Button>
            </Box>

            <List>
                {templates.map((template) => (
                    <ListItem
                        key={template.id}
                        button
                        onClick={() => handleTemplateSelect(template)}
                    >
                        <ListItemText
                            primary={template.name}
                            secondary={template.description || 'No description'}
                        />
                        <ListItemSecondaryAction>
                            <Tooltip title="Download Template">
                                <IconButton
                                    edge="end"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        handleDownloadTemplate(template);
                                    }}
                                >
                                    <DownloadIcon />
                                </IconButton>
                            </Tooltip>
                            <Tooltip title="Delete Template">
                                <IconButton
                                    edge="end"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        handleDeleteTemplate(template.id);
                                    }}
                                >
                                    <DeleteIcon />
                                </IconButton>
                            </Tooltip>
                        </ListItemSecondaryAction>
                    </ListItem>
                ))}
                {templates.length === 0 && (
                    <Typography color="textSecondary" align="center" py={2}>
                        No templates saved yet
                    </Typography>
                )}
            </List>

            <Dialog
                open={isAddDialogOpen}
                onClose={() => setIsAddDialogOpen(false)}
                maxWidth="sm"
                fullWidth
            >
                <DialogTitle>Save as Template</DialogTitle>
                <DialogContent>
                    <TextField
                        autoFocus
                        margin="dense"
                        label="Template Name"
                        fullWidth
                        value={newTemplateName}
                        onChange={(e) => setNewTemplateName(e.target.value)}
                    />
                    <TextField
                        margin="dense"
                        label="Description (optional)"
                        fullWidth
                        multiline
                        rows={3}
                        value={newTemplateDescription}
                        onChange={(e) => setNewTemplateDescription(e.target.value)}
                    />
                </DialogContent>
                <DialogActions>
                    <Button onClick={() => setIsAddDialogOpen(false)}>Cancel</Button>
                    <Button
                        onClick={handleSaveTemplate}
                        color="primary"
                        disabled={!newTemplateName}
                    >
                        Save
                    </Button>
                </DialogActions>
            </Dialog>
        </Box>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Timer.tsx ---

import {useCurrentFrame, Video} from 'remotion';
import clockVideo from '../@Assets/clock.mp4';

interface TimerProps {
	startFrame: number;
}

export const Timer: React.FC<TimerProps> = ({startFrame}) => {
	const frame = useCurrentFrame();
	const relativeFrame = frame - startFrame;

	return (
		<div style={{
			position: 'absolute',
			bottom: 100,
			left: '50%',
			transform: 'translateX(-50%)',
			width: '200px', // Adjust size as needed
			height: '200px',
		}}>
			<Video
				src={clockVideo}
				startFrom={relativeFrame}
				endAt={relativeFrame + 150} // 5 seconds at 30fps
				style={{
					width: '100%',
					height: '100%',
				}}
			/>
		</div>
	);
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\AudioComponent.tsx ---

import React, { useEffect, useRef } from 'react';
import { useCurrentFrame, useVideoConfig } from 'remotion';
import { AudioComponent as AudioComponentType } from '../../types/script';

interface AudioComponentProps {
    component: AudioComponentType;
}

export const AudioComponent: React.FC<AudioComponentProps> = ({ component }) => {
    const frame = useCurrentFrame();
    const { fps } = useVideoConfig();
    const audioRef = useRef<HTMLAudioElement>(null);
    const audioContextRef = useRef<AudioContext | null>(null);
    const sourceNodeRef = useRef<MediaElementAudioSourceNode | null>(null);
    const gainNodeRef = useRef<GainNode | null>(null);

    useEffect(() => {
        if (!audioRef.current) return;

        // Initialize Web Audio API context and nodes
        if (!audioContextRef.current) {
            const AudioContextClass = window.AudioContext || (window as any).webkitAudioContext;
            audioContextRef.current = new AudioContextClass();
            sourceNodeRef.current = audioContextRef.current.createMediaElementSource(audioRef.current);
            gainNodeRef.current = audioContextRef.current.createGain();
            sourceNodeRef.current.connect(gainNodeRef.current);
            gainNodeRef.current.connect(audioContextRef.current.destination);
        }

        const audio = audioRef.current;
        const gainNode = gainNodeRef.current;
        const startTime = component.style?.startTime ?? 0;
        const currentTime = frame / fps;

        // Set volume using gain node
        if (gainNode) {
            gainNode.gain.value = component.style?.volume ?? 1;
        }

        // Set loop
        audio.loop = component.style?.loop ?? false;

        // Calculate and set current time
        const audioTime = currentTime - startTime;
        if (audioTime >= 0) {
            audio.currentTime = audioTime;
            audio.play().catch(console.error);
        } else {
            audio.pause();
        }

        // Handle duration limit
        if (component.style?.duration) {
            const duration = component.style.duration;
            if (audioTime > duration) {
                audio.pause();
            }
        }

        // Cleanup
        return () => {
            audio.pause();
            if (audioContextRef.current) {
                audioContextRef.current.close();
                audioContextRef.current = null;
                sourceNodeRef.current = null;
                gainNodeRef.current = null;
            }
        };
    }, [frame, fps, component.style?.startTime, component.style?.volume, component.style?.loop, component.style?.duration]);

    const audioUrl = typeof component.audioUrl === 'string' ? component.audioUrl : component.audioUrl.url;

    return (
        <audio
            ref={audioRef}
            src={audioUrl}
            preload="auto"
            crossOrigin="anonymous"
        />
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\CaptionRenderer.tsx ---

import React from 'react';
import { useCurrentFrame } from 'remotion';
import { WordTiming, CaptionStyle } from '../../types/script';

interface CaptionRendererProps {
    wordTimings: WordTiming[];
    style: CaptionStyle;
}

export const CaptionRenderer: React.FC<CaptionRendererProps> = ({ wordTimings, style }) => {
    const frame = useCurrentFrame();
    const fps = 30; // Standard frame rate
    const currentTime = frame / fps;

    // Find words that should be visible based on the current time and word window
    const visibleWords = wordTimings.filter(timing => {
        const isWithinTime = currentTime >= timing.start && currentTime <= timing.end;
        if (!isWithinTime) return false;

        // Find the index of the current word
        const currentIndex = wordTimings.findIndex(w => w === timing);
        const windowStart = Math.max(0, currentIndex - Math.floor(style.wordWindow / 2));
        const windowEnd = Math.min(wordTimings.length - 1, currentIndex + Math.floor(style.wordWindow / 2));

        // Check if the word is within the window
        return currentIndex >= windowStart && currentIndex <= windowEnd;
    });

    if (visibleWords.length === 0) return null;

    return (
        <div style={{
            position: 'absolute',
            bottom: style.position === 'top' ? 'auto' : '10%',
            top: style.position === 'top' ? '10%' : 'auto',
            left: '50%',
            transform: 'translateX(-50%)',
            textAlign: 'center',
            fontSize: style.fontSize,
            color: style.color,
            backgroundColor: style.backgroundColor,
            padding: '10px 20px',
            borderRadius: '5px',
            maxWidth: '80%',
            transition: 'all 0.2s ease-in-out'
        }}>
            {visibleWords.map(word => word.word).join(' ')}
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\ComparisonComponent.tsx ---

import React from 'react';
import { ComparisonComponent as ComparisonComponentType } from '../../types/script';
import { AbsoluteFill, useCurrentFrame, interpolate, spring } from 'remotion';
import { theme } from '../../styles/theme';

interface ComparisonComponentProps {
    component: ComparisonComponentType;
}

const getAnimationStyle = (
    frame: number,
    animation: ComparisonComponentType['style']['animation'],
    isSecondImage: boolean = false,
    durationInFrames: number
) => {
    if (!animation || animation.type === 'none') {
        return {};
    }

    const delay = (animation.delay || 0) + (isSecondImage ? (animation.stagger || 0) : 0);
    const duration = animation.duration || 30;
    const currentFrame = Math.max(0, frame - delay);
    const progress = interpolate(
        currentFrame,
        [0, duration, durationInFrames - duration, durationInFrames],
        [0, 1, 1, 0],
        {
            extrapolateLeft: 'clamp',
            extrapolateRight: 'clamp',
            easing: animation.easing === 'linear' ? (t) => t :
                   animation.easing === 'ease-in' ? (t) => t * t :
                   animation.easing === 'ease-out' ? (t) => 1 - Math.pow(1 - t, 2) :
                   (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2
        }
    );

    switch (animation.type) {
        case 'fade':
            return { opacity: progress };
        case 'scale':
            return { transform: `scale(${progress})` };
        case 'rotate':
            return { transform: `rotate(${interpolate(progress, [0, 1], [0, 360])}deg)` };
        case 'slide':
            const offset = 100;
            const x = animation.direction === 'left' ? -offset : 
                     animation.direction === 'right' ? offset : 0;
            const y = animation.direction === 'top' ? -offset :
                     animation.direction === 'bottom' ? offset : 0;
            return {
                transform: `translate(${interpolate(progress, [0, 1], [x, 0])}%, ${interpolate(progress, [0, 1], [y, 0])}%)`
            };
        default:
            return {};
    }
};

export const ComparisonComponent: React.FC<ComparisonComponentProps> = ({ component }) => {
    const frame = useCurrentFrame();
    const { 
        fontSize = 32, 
        fontFamily = 'Arial', 
        textColor = '#ffffff', 
        backgroundColor = 'rgba(0, 0, 0, 0.7)', 
        spacing = 20, 
        borderRadius = 8, 
        shadow = true,
        showText = true,
        imageSize = 100,
        imageGap = 20,
        forceSameSize = true,
        imagePosition = { x: 0, y: 0 },
        imageBorder,
        imageDropShadow,
        animation
    } = component.style || {};

    // Base fade animation
    const opacity = interpolate(
        frame,
        [0, 15, component.durationInFrames - 15, component.durationInFrames],
        [0, 1, 1, 0]
    );

    const imageContainerStyle = {
        display: 'flex',
        flexDirection: component.orientation === 'horizontal' ? 'row' as const : 'column' as const,
        gap: `${imageGap}px`,
        justifyContent: 'center',
        alignItems: 'center',
        transform: `translate(${imagePosition.x}%, ${imagePosition.y}%)`,
        width: '100%',
        height: '100%',
        padding: '10% 5%',
    };

    const commonImageStyle = {
        width: forceSameSize ? `${imageSize}%` : 'auto',
        height: forceSameSize ? `${imageSize}%` : 'auto',
        maxWidth: forceSameSize ? `${imageSize}%` : '100%',
        maxHeight: forceSameSize ? `${imageSize}%` : '100%',
        objectFit: forceSameSize ? 'contain' : 'cover',
        borderRadius: `${borderRadius}px`,
        border: imageBorder?.enabled ? `${imageBorder.width}px solid ${imageBorder.color}` : undefined,
        boxShadow: imageDropShadow?.enabled ? 
            `${imageDropShadow.x}px ${imageDropShadow.y}px ${imageDropShadow.blur}px ${imageDropShadow.spread}px ${imageDropShadow.color}` : 
            undefined,
    };

    return (
        <AbsoluteFill style={{ opacity }}>
            {/* Question */}
            {showText && (
                <div style={{
                    position: 'absolute',
                    top: '5%',
                    left: '50%',
                    transform: 'translateX(-50%)',
                    backgroundColor,
                    padding: '10px 20px',
                    borderRadius: borderRadius,
                    boxShadow: shadow ? '0 2px 4px rgba(0,0,0,0.2)' : undefined,
                    fontSize: `${fontSize}px`,
                    fontFamily,
                    color: textColor,
                    textAlign: 'center',
                    zIndex: 10,
                }}>
                    {component.question}
                </div>
            )}

            {/* Images Container */}
            <div style={imageContainerStyle}>
                {/* Left/Top Image */}
                <div style={{
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    gap: '10px',
                    ...getAnimationStyle(frame, animation, false, component.durationInFrames),
                }}>
                    <img
                        src={component.leftOption.imageUrl}
                        style={commonImageStyle}
                        alt={component.leftOption.text}
                    />
                    {showText && (
                        <div style={{
                            backgroundColor,
                            padding: '5px 10px',
                            borderRadius: borderRadius,
                            boxShadow: shadow ? '0 2px 4px rgba(0,0,0,0.2)' : undefined,
                            fontSize: `${fontSize * 0.8}px`,
                            fontFamily,
                            color: textColor,
                            textAlign: 'center',
                        }}>
                            {component.leftOption.text}
                        </div>
                    )}
                </div>

                {/* Right/Bottom Image */}
                <div style={{
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    gap: '10px',
                    ...getAnimationStyle(frame, animation, true, component.durationInFrames),
                }}>
                    <img
                        src={component.rightOption.imageUrl}
                        style={commonImageStyle}
                        alt={component.rightOption.text}
                    />
                    {showText && (
                        <div style={{
                            backgroundColor,
                            padding: '5px 10px',
                            borderRadius: borderRadius,
                            boxShadow: shadow ? '0 2px 4px rgba(0,0,0,0.2)' : undefined,
                            fontSize: `${fontSize * 0.8}px`,
                            fontFamily,
                            color: textColor,
                            textAlign: 'center',
                        }}>
                            {component.rightOption.text}
                        </div>
                    )}
                </div>
            </div>
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\ComparisonSequence.tsx ---

import React from 'react';
import { AbsoluteFill } from 'remotion';
import { Comparison } from '../../types/quiz';

interface ComparisonSequenceProps {
    comparison: Comparison;
}

export const ComparisonSequence: React.FC<ComparisonSequenceProps> = ({ comparison }) => {
    return (
        <AbsoluteFill>
            {/* Component content */}
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\CountdownSequence.tsx ---

import React from 'react';
import { AbsoluteFill, useCurrentFrame } from 'remotion';
import { CountdownComponent } from '../../types/script';

interface CountdownSequenceProps {
    component: CountdownComponent;
}

export const CountdownSequence: React.FC<CountdownSequenceProps> = ({ component }) => {
    const frame = useCurrentFrame();
    const style = component.style || {};
    const position = style.position || { x: 0, y: 0 };

    // Calculate current number based on frame
    const from = component.from || 10;
    const framePerNumber = component.durationInFrames ? component.durationInFrames / from : 30;
    const currentNumber = Math.max(0, Math.ceil(from - frame / framePerNumber));

    return (
        <AbsoluteFill>
            <div style={{
                position: 'absolute',
                left: position.x,
                top: position.y,
                fontSize: style.fontSize || 80,
                fontFamily: style.fontFamily || 'Arial',
                color: style.color || 'white',
                textAlign: style.textAlign || 'center',
                width: style.position?.width || 300,
                fontWeight: 'bold',
                transform: 'translate(0, 0)', // Prevent any transform issues
            }}>
                {currentNumber}
            </div>
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\ImageComponent.tsx ---

import React from 'react';
import { AbsoluteFill } from 'remotion';
import { ImageComponent as ImageComponentType } from '../../types/script';

interface ImageComponentProps {
    component: ImageComponentType;
}

export const ImageComponent: React.FC<ImageComponentProps> = ({ component }) => {
    const {
        imageUrl,
        style = {}
    } = component;

    const {
        width = 400,
        height = 400,
        position = { x: 0, y: 0 },
        scale = 1,
        rotation = 0,
        opacity = 1,
        border = { enabled: false, color: '#000000', width: 2 },
        dropShadow = { enabled: false, color: '#000000', blur: 10, spread: 0, x: 5, y: 5 }
    } = style;

    // Calculate shadow styles if enabled
    const shadowStyle = dropShadow.enabled ? {
        filter: `drop-shadow(${dropShadow.x}px ${dropShadow.y}px ${dropShadow.blur}px ${dropShadow.color})`
    } : {};

    // Calculate border styles if enabled
    const borderStyle = border.enabled ? {
        border: `${border.width}px solid ${border.color}`
    } : {};

    return (
        <AbsoluteFill>
            <div
                style={{
                    position: 'absolute',
                    left: `${position.x}px`,
                    top: `${position.y}px`,
                    width: `${width}px`,
                    height: `${height}px`,
                    transform: `scale(${scale}) rotate(${rotation}deg)`,
                    opacity,
                    ...shadowStyle,
                    ...borderStyle,
                    overflow: 'hidden',
                }}
            >
                <img
                    src={imageUrl}
                    alt="Video component"
                    style={{
                        width: '100%',
                        height: '100%',
                        objectFit: 'cover',
                    }}
                />
            </div>
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\QuizVideo.tsx ---

import React from 'react';
import {
    AbsoluteFill,
    Audio,
    Sequence,
    useVideoConfig,
} from 'remotion';
import {QuizConfig} from '../../types/quiz';
import {ComparisonSequence} from './ComparisonSequence';

interface QuizVideoProps {
    quizConfig: QuizConfig;
}

export const QuizVideo: React.FC<QuizVideoProps> = ({quizConfig}) => {
    const {fps} = useVideoConfig();
    const SEQUENCE_DURATION = 5 * fps;

    // Handle empty state
    if (!quizConfig.comparisons.length) {
        return (
            <AbsoluteFill style={{
                backgroundColor: '#1a1a1a',
                display: 'flex',
                justifyContent: 'center',
                alignItems: 'center',
            }}>
                <h1 style={{color: 'white'}}>Add a comparison to start</h1>
            </AbsoluteFill>
        );
    }

    return (
        <AbsoluteFill style={{backgroundColor: '#1a1a1a'}}>
            {quizConfig.comparisons.map((comparison, index) => (
                <Sequence
                    key={comparison.id}
                    from={index * SEQUENCE_DURATION}
                    durationInFrames={SEQUENCE_DURATION}
                >
                    <ComparisonSequence comparison={comparison} />
                </Sequence>
            ))}
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\RemotionSubtitleCaption.tsx ---

import React, { useEffect } from 'react';
import { useCurrentFrame, useVideoConfig } from 'remotion';
import { SubtitleSequence } from 'remotion-subtitle';
import {
    BounceCaption,
    ColorfulCaption,
    ExplosiveCaption,
    FadeCaption,
    FireCaption,
    GlitchCaption,
    GlowingCaption,
    LightningCaption,
    NeonCaption,
    RotatingCaption,
    ShakeCaption,
    ThreeDishCaption,
    TiltShiftCaption,
    TypewriterCaption,
    WavingCaption,
    ZoomCaption,
} from 'remotion-subtitle';
import { TextStyle, WordTiming } from '../../types/script';

interface RemotionSubtitleCaptionProps {
    wordTimings: WordTiming[];
    style: TextStyle;
    startFrame: number;
}

const CAPTION_COMPONENTS = {
    bounce: BounceCaption,
    colorful: ColorfulCaption,
    explosive: ExplosiveCaption,
    fade: FadeCaption,
    fire: FireCaption,
    glitch: GlitchCaption,
    glowing: GlowingCaption,
    lightning: LightningCaption,
    neon: NeonCaption,
    rotating: RotatingCaption,
    shake: ShakeCaption,
    threeDish: ThreeDishCaption,
    tiltShift: TiltShiftCaption,
    typewriter: TypewriterCaption,
    waving: WavingCaption,
    zoom: ZoomCaption,
};

export const RemotionSubtitleCaption: React.FC<RemotionSubtitleCaptionProps> = (props) => {
    const { wordTimings, style, startFrame } = props;
    const frame = useCurrentFrame();
    const { fps } = useVideoConfig();
    const currentTime = frame / fps;
    const componentStartTime = startFrame / fps;

    // Enhanced debug logging
    const debugLog = (message: string, data?: any, trace: boolean = false, level: 'info' | 'warn' | 'error' = 'info') => {
        const timestamp = new Date().toISOString();
        const frameInfo = `[Frame: ${frame}]`;
        const componentInfo = `[RemotionSubtitleCaption]`;
        const propsSnapshot = JSON.stringify(props, null, 2);
        const callStack = new Error().stack;

        console.group(`${timestamp} ${frameInfo} ${componentInfo} ${message}`);
        console.log('Props Snapshot:', propsSnapshot);
        console.log('Current Frame:', frame);
        console.log('FPS:', fps);
        console.log('Current Time:', currentTime);
        console.log('Component Start Time:', componentStartTime);
        console.log('Data:', data);
        console.log('Call Stack:', callStack);
        if (trace) {
            console.trace('Detailed Stack Trace');
        }
        console.groupEnd();
    };

    // Log initial render
    debugLog('Component Initial Render', {
        hasWordTimings: !!wordTimings,
        wordTimingsCount: wordTimings.length,
        style,
        startFrame,
        currentTime,
        componentStartTime
    }, true);

    // Log component mount
    useEffect(() => {
        debugLog('Component Mounted', {
            wordTimingsCount: wordTimings.length,
            style,
            startFrame,
            currentTime,
            componentStartTime,
            mountTime: new Date().toISOString(),
        }, true);

        return () => {
            debugLog('Component Unmounting', {
                unmountTime: new Date().toISOString(),
                lastFrame: frame,
            }, true);
        };
    }, []);

    // Log every frame update
    useEffect(() => {
        const frameStartTime = performance.now();
        debugLog('Frame Update', {
            currentFrame: frame,
            currentTime,
            componentStartTime,
            activeWords: wordTimings.filter(timing => {
                const start = timing.start - componentStartTime;
                const end = timing.end - componentStartTime;
                return currentTime >= start && currentTime <= end;
            }).map(w => w.word)
        });
        const frameEndTime = performance.now();
        debugLog('Frame Update Complete', {
            frameDuration: frameEndTime - frameStartTime,
            frame,
        });
    }, [frame]);

    // Convert word timings to SRT format with logging
    debugLog('Converting word timings to SRT format', {
        wordTimings,
        componentStartTime
    });

    const srtContent = wordTimings
        .map((timing, index) => {
            const start = timing.start - componentStartTime;
            const end = timing.end - componentStartTime;
            const srtEntry = `${index + 1}\n${formatTime(start)} --> ${formatTime(end)}\n${timing.word}\n\n`;
            
            debugLog('Generated SRT entry:', {
                index,
                word: timing.word,
                originalStart: timing.start,
                originalEnd: timing.end,
                adjustedStart: start,
                adjustedEnd: end,
                srtEntry
            });

            return srtEntry;
        })
        .join('');

    // Get the appropriate caption component
    const CaptionComponent = style.captionStyle && CAPTION_COMPONENTS[style.captionStyle as keyof typeof CAPTION_COMPONENTS];
    
    debugLog('Caption component selection:', {
        requestedStyle: style.captionStyle,
        foundComponent: !!CaptionComponent,
        availableStyles: Object.keys(CAPTION_COMPONENTS)
    });

    if (!CaptionComponent) {
        debugLog('No caption component found for style', {
            style: style.captionStyle
        }, true);
        return null;
    }

    // Create subtitle sequence with logging
    debugLog('Creating subtitle sequence', {
        srtContent,
        style
    });

    const subtitles = new SubtitleSequence(srtContent);

    debugLog('Rendering subtitles', {
        currentFrame: frame,
        currentTime,
        style: {
            fontSize: style.fontSize || '24px',
            color: style.color || 'white',
            ...style,
        }
    }, true);

    return (
        <div style={{
            position: 'absolute',
            left: '50%',
            bottom: '10%',
            transform: 'translateX(-50%)',
            width: '80%',
            textAlign: 'center',
        }}>
            {debugLog('Rendering Subtitles', {
                currentTime,
                componentStartTime,
                activeWords: wordTimings.filter(timing => {
                    const start = timing.start - componentStartTime;
                    const end = timing.end - componentStartTime;
                    return currentTime >= start && currentTime <= end;
                }).map(w => w.word)
            })}
            {subtitles.getSequences(
                <CaptionComponent style={{
                    fontSize: style.fontSize || '24px',
                    color: style.color || 'white',
                    ...style,
                }} />,
                fps
            )}
        </div>
    );
};

// Helper function to format time in SRT format (HH:MM:SS,mmm)
function formatTime(seconds: number): string {
    const pad = (n: number, width: number) => String(n).padStart(width, '0');
    
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    const ms = Math.floor((seconds % 1) * 1000);
    
    return `${pad(hours, 2)}:${pad(minutes, 2)}:${pad(secs, 2)},${pad(ms, 3)}`;
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\ScriptVideo.tsx ---

import React, { useEffect, useState, useMemo } from 'react';
import { AbsoluteFill, Sequence, spring, useCurrentFrame, useVideoConfig, Audio } from 'remotion';
import { Script, TextComponent as TextComponentType, VoiceComponent as VoiceComponentType, AudioComponent as AudioComponentType } from '../../types/script';
import { CaptionRenderer } from './CaptionRenderer';
import { ComparisonComponent } from './ComparisonComponent';
import { VideoComponent } from './VideoComponent';
import { TextComponent } from './TextComponent';

interface Props {
    script?: Script;
}

const getAnimationStyle = (frame: number, fps: number, animation: string, direction: 'in' | 'out', timing: { start: number; end: number }) => {
    if (!animation) return {};

    const isOut = direction === 'out';
    const durationInFrames = timing.end - timing.start;
    const adjustedFrame = frame - timing.start;

    console.log(`Animation ${direction}:`, {
        frame,
        adjustedFrame,
        timing,
        durationInFrames,
    });

    // If we're not within the animation timeframe, return the final state
    if (adjustedFrame < 0) return isOut ? {} : { opacity: 0, transform: getInitialTransform(animation) };
    if (adjustedFrame > durationInFrames) return isOut ? { opacity: 0, transform: getFinalTransform(animation) } : {};

    switch (animation) {
        case 'slide-left': {
            const opacity = spring({
                frame: adjustedFrame,
                fps,
                from: isOut ? 1 : 0,
                to: isOut ? 0 : 1,
                durationInFrames,
            });

            const slideX = spring({
                frame: adjustedFrame,
                fps,
                from: isOut ? 0 : -200,
                to: isOut ? -200 : 0,
                durationInFrames,
                config: {
                    damping: 12,
                    mass: 0.5,
                },
            });

            return {
                opacity,
                transform: `translateX(${slideX}px)`,
            };
        }
        case 'slide-right': {
            const opacity = spring({
                frame: adjustedFrame,
                fps,
                from: isOut ? 1 : 0,
                to: isOut ? 0 : 1,
                durationInFrames,
            });

            const slideX = spring({
                frame: adjustedFrame,
                fps,
                from: isOut ? 0 : 200,
                to: isOut ? 200 : 0,
                durationInFrames,
                config: {
                    damping: 12,
                    mass: 0.5,
                },
            });

            return {
                opacity,
                transform: `translateX(${slideX}px)`,
            };
        }
        default:
            return {};
    }
};

// Helper functions to get initial and final transform states
const getInitialTransform = (animation: string) => {
    switch (animation) {
        case 'slide-left':
            return 'translateX(-200px)';
        case 'slide-right':
            return 'translateX(200px)';
        default:
            return 'none';
    }
};

const getFinalTransform = (animation: string) => {
    switch (animation) {
        case 'slide-left':
            return 'translateX(-200px)';
        case 'slide-right':
            return 'translateX(200px)';
        default:
            return 'none';
    }
};

const BACKGROUND_SERVICE_URL = 'http://localhost:3002';

export const ScriptVideo: React.FC<Script> = (props) => {
    console.log('ScriptVideo received props:', props);
    
    if (!props || !props.components) {
        console.error('Invalid script data:', props);
        return (
            <AbsoluteFill style={{ backgroundColor: 'black', color: 'white' }}>
                <h1>Error: Invalid script data</h1>
            </AbsoluteFill>
        );
    }

    // Store the background URL in state to prevent re-fetching
    const [bgUrl, setBgUrl] = useState<string | null>(null);

    useEffect(() => {
        if (props.settings?.background?.type === 'image' && props.settings.background.url) {
            // If it's already a full URL, or we want to prefix a local service
            let finalUrl = props.settings.background.url;
            if (!/^https?:\/\//.test(finalUrl)) {
                // Not a fully qualified URL, prefix the background service
                finalUrl = `${BACKGROUND_SERVICE_URL}/backgrounds/${encodeURIComponent(finalUrl)}`;
            }
            setBgUrl(finalUrl);
        } else if (props.settings?.background?.type === 'video' && props.settings.background.url) {
            // Handle video backgrounds similarly
            let finalUrl = props.settings.background.url;
            if (!/^https?:\/\//.test(finalUrl)) {
                finalUrl = `${BACKGROUND_SERVICE_URL}/backgrounds/${encodeURIComponent(finalUrl)}`;
            }
            setBgUrl(finalUrl);
        } else {
            setBgUrl(null);
        }
    }, [props.settings?.background]);

    // Memoize the background style to prevent unnecessary re-renders
    const backgroundStyle = useMemo(() => {
        if (!bgUrl) {
            return {
                backgroundColor: 'black',
            };
        }

        if (props.settings?.background?.type === 'video') {
            return {
                backgroundColor: 'black',
            };
        }

        return {
            backgroundImage: `url("${bgUrl}")`,
            backgroundSize: 'cover',
            backgroundPosition: 'center',
            backgroundRepeat: 'no-repeat',
        };
    }, [bgUrl, props.settings?.background?.type]);

    useEffect(() => {
        const loadFonts = async () => {
            try {
                // Get font dictionary from font service
                const response = await fetch('http://localhost:3003/fonts/dictionary');
                if (!response.ok) throw new Error('Failed to load font dictionary');
                const fontDict = await response.json();
                console.log('ScriptVideo: Font dictionary:', fontDict);

                // Get unique font families used in components
                const usedFonts = new Set<string>();
                props.components.forEach(comp => {
                    if (comp.type === 'text' || comp.type === 'title') {
                        const textComp = comp as { style?: { fontFamily?: string } };
                        if (textComp.style?.fontFamily) {
                            usedFonts.add(textComp.style.fontFamily);
                            console.log('ScriptVideo: Found font:', textComp.style.fontFamily);
                        }
                    }
                });

                // Load each used font
                const fontLoadPromises = Array.from(usedFonts).map(async fontName => {
                    const fontData = fontDict[fontName];
                    if (fontData?.url) {
                        try {
                            console.log('ScriptVideo: Loading font:', fontName, 'from URL:', fontData.url);
                            const font = new FontFace(fontName, `url(${fontData.url})`);
                            const loadedFont = await font.load();
                            document.fonts.add(loadedFont);
                            console.log('ScriptVideo: Successfully loaded font:', fontName);
                            return true;
                        } catch (error) {
                            console.error('ScriptVideo: Error loading font:', fontName, error);
                            return false;
                        }
                    }
                    return false;
                });

                await Promise.all(fontLoadPromises);
                console.log('ScriptVideo: All fonts loaded');
            } catch (error) {
                console.error('ScriptVideo: Error loading fonts:', error);
            }
        };

        loadFonts();
    }, [props.components]);

    return (
        <AbsoluteFill style={backgroundStyle}>
            {props.settings?.background?.type === 'video' && bgUrl && (
                <video
                    src={bgUrl}
                    style={{
                        position: 'absolute',
                        width: '100%',
                        height: '100%',
                        objectFit: 'cover',
                    }}
                    autoPlay
                    loop
                    muted
                />
            )}
            {props.components.map((component) => {
                const key = `${component.id}-${component.startFrame}-${component.durationInFrames}`;
                return (
                    <Sequence
                        key={key}
                        from={component.startFrame || 0}
                        durationInFrames={component.durationInFrames || 150}
                    >
                        {component.type === 'text' && (
                            <TextComponent component={component as TextComponentType} />
                        )}
                        {component.type === 'comparison' && (
                            <ComparisonComponent component={component as any} />
                        )}
                        {component.type === 'video' && (
                            <VideoComponent component={component as any} />
                        )}
                        {component.type === 'voice' && (
                            <VoiceComponent component={component as VoiceComponentType} />
                        )}
                        {component.type === 'audio' && (
                            <AudioEffectComponent component={component as AudioComponentType} />
                        )}
                    </Sequence>
                );
            })}
        </AbsoluteFill>
    );
};

const TextComponent: React.FC<{ component: TextComponentType }> = ({ component }) => {
    const frame = useCurrentFrame();
    const { fps } = useVideoConfig();
    
    const animationIn = component.style?.animation?.in?.type || '';
    const animationOut = component.style?.animation?.out?.type || '';
    
    // Calculate animation timings
    const totalDuration = component.durationInFrames || 150;
    
    // For entrance animation
    const inStartFrame = component.style?.animation?.in?.startFrame || 0;
    const inEndFrame = component.style?.animation?.in?.endFrame || 30;
    const inTiming = {
        start: inStartFrame,
        end: inEndFrame,
    };
    
    // For exit animation
    const outStartFrame = totalDuration - (component.style?.animation?.out?.startFrame || 30);
    const outEndFrame = totalDuration - (component.style?.animation?.out?.endFrame || 0);
    const outTiming = {
        start: outStartFrame,
        end: outEndFrame,
    };
    
    console.log('Animation frames:', {
        frame,
        totalDuration,
        in: { start: inStartFrame, end: inEndFrame },
        out: { start: outStartFrame, end: outEndFrame },
    });
    
    const animationStyleIn = getAnimationStyle(frame, fps, animationIn, 'in', inTiming);
    const animationStyleOut = getAnimationStyle(frame, fps, animationOut, 'out', outTiming);
    
    return (
        <div style={{
            position: 'absolute',
            left: component.style?.position?.x || 0,
            top: component.style?.position?.y || 0,
            width: 'auto',
            display: 'inline-block',
            ...(component.style?.blockStyle?.enabled ? {
                backgroundColor: component.style.backgroundColor || '#FFFFFF',
                padding: '20px 40px',
                borderRadius: '15px',
                boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
                minWidth: '33%',
            } : {}),
            textAlign: component.style?.textAlign || 'center',
            color: component.style?.color || 'white',
            fontSize: component.style?.fontSize || 40,
            fontFamily: component.style?.fontFamily || 'Arial',
            fontWeight: component.style?.fontWeight || 'normal',
            textTransform: component.style?.textTransform || 'none',
            ...animationStyleIn,
            ...animationStyleOut,
            ...(component.style?.outline?.enabled ? {
                textShadow: `
                    -${component.style.outline.width}px -${component.style.outline.width}px 0 ${component.style.outline.color},
                    ${component.style.outline.width}px -${component.style.outline.width}px 0 ${component.style.outline.color},
                    -${component.style.outline.width}px ${component.style.outline.width}px 0 ${component.style.outline.color},
                    ${component.style.outline.width}px ${component.style.outline.width}px 0 ${component.style.outline.color}
                `
            } : {})
        }}>
            {component.text}
        </div>
    );
};

const VoiceComponent: React.FC<{ component: VoiceComponentType }> = ({ component }) => {
    if (!component.audioUrl) {
        console.warn('VoiceComponent: No audio URL provided');
        return null;
    }

    // Calculate volume based on style settings
    const volume = component.style?.volume ?? 1;

    // Calculate start and end times if specified
    const startTime = component.style?.startTime ?? 0;
    const duration = component.style?.duration;

    return (
        <>
            <Audio
                src={component.audioUrl}
                volume={volume}
                startFrom={startTime}
                endAt={duration ? startTime + duration : undefined}
            />
            {component.showCaptions && component.wordTimings && (
                <CaptionRenderer
                    wordTimings={component.wordTimings}
                    style={component.captionStyle || {
                        fontSize: 24,
                        color: '#ffffff',
                        backgroundColor: 'rgba(0, 0, 0, 0.7)',
                        position: 'bottom',
                        wordWindow: 1
                    }}
                />
            )}
        </>
    );
};

const AudioEffectComponent: React.FC<{ component: AudioComponentType }> = ({ component }) => {
    if (!component.audioUrl) {
        console.warn('AudioEffectComponent: No audio URL provided');
        return null;
    }

    // Get audio settings from style
    const volume = component.style?.volume ?? 1;
    const startTime = component.style?.startTime ?? 0;
    const duration = component.style?.duration;
    const loop = component.style?.loop ?? false;

    // Handle both string URLs and audio object URLs
    const audioSrc = typeof component.audioUrl === 'string' 
        ? component.audioUrl 
        : component.audioUrl.url;

    return (
        <Audio
            src={audioSrc}
            volume={volume}
            startFrom={startTime}
            endAt={duration ? startTime + duration : undefined}
            loop={loop}
        />
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\TextComponent.tsx ---

import React from 'react';
import { useCurrentFrame, useVideoConfig } from 'remotion';
import { TextComponent as TextComponentType } from '../../types/script';
import { getAnimationStyle } from '../../utils/animation';

interface TextComponentProps {
    component: TextComponentType;
}

export const TextComponent: React.FC<TextComponentProps> = ({ component }) => {
    const frame = useCurrentFrame();
    const { fps } = useVideoConfig();

    const style = component.style || {};
    const animationStyle = getAnimationStyle(frame, fps, style.animation);

    return (
        <div
            style={{
                position: 'absolute',
                left: '50%',
                top: '50%',
                transform: `translate(-50%, -50%)`,
                fontSize: style.fontSize || 32,
                fontFamily: style.fontFamily || 'Arial',
                color: style.color || '#ffffff',
                textAlign: style.textAlign || 'center',
                fontWeight: style.fontWeight || 'normal',
                lineHeight: style.lineHeight || 1.5,
                backgroundColor: style.backgroundColor,
                padding: style.padding,
                borderRadius: style.borderRadius,
                ...animationStyle,
            }}
        >
            {component.text}
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\TextSequence.tsx ---

import React from 'react';
import { AbsoluteFill } from 'remotion';
import { TextComponent } from '../../types/script';

interface TextSequenceProps {
    component: TextComponent;
}

export const TextSequence: React.FC<TextSequenceProps> = ({ component }) => {
    const style = component.style || {};
    const position = style.position || { x: 0, y: 0 };

    // Format text based on wordsPerLine
    const formatText = (text: string) => {
        if (!text || !style.wordsPerLine || style.wordsPerLine <= 0) {
            return text;
        }

        // Remove existing line breaks and extra spaces
        const cleanText = text.replace(/[\n\r]+/g, ' ').replace(/\s+/g, ' ').trim();
        const words = cleanText.split(' ');
        const lines = [];
        
        // Group words into lines
        for (let i = 0; i < words.length; i += style.wordsPerLine) {
            const line = words.slice(i, i + style.wordsPerLine).join(' ');
            if (line) lines.push(line);
        }
        
        // Join lines with newlines
        return lines.join('\n');
    };

    // Create text shadow for outline effect
    const getTextShadow = () => {
        if (!style.outline?.enabled) return 'none';

        const width = style.outline.width || 2;
        const color = style.outline.color || '#000000';
        const shadows = [];

        // Generate outline effect using multiple text shadows
        for (let x = -width; x <= width; x++) {
            for (let y = -width; y <= width; y++) {
                if (Math.abs(x) === width || Math.abs(y) === width) {
                    shadows.push(`${x}px ${y}px 0 ${color}`);
                }
            }
        }

        return shadows.join(', ');
    };

    return (
        <AbsoluteFill>
            <div style={{
                position: 'absolute',
                left: position.x,
                top: position.y,
                fontSize: style.fontSize || 40,
                fontFamily: style.fontFamily || 'Arial',
                color: style.color || 'white',
                textAlign: style.textAlign || 'center',
                width: '100%',
                maxWidth: '80%',
                margin: '0 auto',
                transform: 'translate(0, 0)', // Prevent any transform issues
                whiteSpace: 'pre-wrap', // Preserve line breaks
                fontWeight: style.fontWeight || 'normal',
                lineHeight: style.lineHeight || 1.5,
                textShadow: getTextShadow(),
            }}>
                {formatText(component.text)}
            </div>
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\TikTokCaptions.tsx ---

import React from 'react';
import {
    AbsoluteFill,
    useCurrentFrame,
    useVideoConfig,
    spring,
    interpolate,
} from 'remotion';
import { TikTokPage } from '../../types/script';

interface TikTokCaptionsProps {
    pages: TikTokPage[];
    style?: {
        backgroundColor?: string;
        textColor?: string;
        position?: 'top' | 'bottom' | 'middle';
    };
}

export const TikTokCaptions: React.FC<TikTokCaptionsProps> = ({
    pages,
    style = {},
}) => {
    const frame = useCurrentFrame();
    const { fps } = useVideoConfig();
    const currentTimeMs = (frame / fps) * 1000;

    const currentPage = pages.find((page, index) => {
        const nextPage = pages[index + 1];
        return (
            currentTimeMs >= page.startMs &&
            (!nextPage || currentTimeMs < nextPage.startMs)
        );
    });

    if (!currentPage) return null;

    const pageProgress = spring({
        frame,
        fps,
        config: {
            damping: 200,
        },
    });

    const getTokenOpacity = (token: TikTokPage['tokens'][0]) => {
        return interpolate(
            currentTimeMs,
            [token.fromMs, token.fromMs + 100, token.toMs - 100, token.toMs],
            [0, 1, 1, 0],
            {
                extrapolateLeft: 'clamp',
                extrapolateRight: 'clamp',
            }
        );
    };

    return (
        <AbsoluteFill
            style={{
                justifyContent: style.position === 'top' ? 'flex-start' : 
                    style.position === 'bottom' ? 'flex-end' : 'center',
                padding: '40px',
            }}
        >
            <div
                style={{
                    backgroundColor: style.backgroundColor || 'rgba(0, 0, 0, 0.8)',
                    color: style.textColor || 'white',
                    padding: '20px',
                    borderRadius: '12px',
                    fontSize: '32px',
                    fontWeight: 'bold',
                    textAlign: 'center',
                    opacity: pageProgress,
                    whiteSpace: 'pre',
                    display: 'inline-block',
                    margin: '0 auto',
                }}
            >
                {currentPage.tokens.map((token, i) => (
                    <span
                        key={i}
                        style={{
                            opacity: getTokenOpacity(token),
                            display: 'inline-block',
                        }}
                    >
                        {token.text}
                    </span>
                ))}
            </div>
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\TitleSequence.tsx ---

import React from 'react';
import { AbsoluteFill } from 'remotion';
import { TitleComponent } from '../../types/script';

interface TitleSequenceProps {
    component: TitleComponent;
}

export const TitleSequence: React.FC<TitleSequenceProps> = ({ component }) => {
    const style = component.style || {};
    const position = style.position || { x: 0, y: 0 };

    return (
        <AbsoluteFill>
            <div style={{
                position: 'absolute',
                left: position.x,
                top: position.y,
                fontSize: style.fontSize || 60,
                fontFamily: style.fontFamily || 'Arial',
                color: style.color || 'white',
                textAlign: style.textAlign || 'center',
                width: style.position?.width || 300,
                fontWeight: 'bold',
                transform: 'translate(0, 0)', // Prevent any transform issues
            }}>
                {component.text}
            </div>
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\TransitionSequence.tsx ---

import React from 'react';
import { AbsoluteFill } from 'remotion';
import { TransitionComponent } from '../../types/script';

interface TransitionSequenceProps {
    component: TransitionComponent;
}

export const TransitionSequence: React.FC<TransitionSequenceProps> = ({ component }) => {
    return (
        <AbsoluteFill style={{
            backgroundColor: 'black',
        }} />
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\VideoComponent.tsx ---

import React, { useEffect, useRef, useState } from 'react';
import { useCurrentFrame, useVideoConfig } from 'remotion';
import { VideoComponent as VideoComponentType } from '../../types/script';
import { getAnimationStyle } from '../../utils/animation';

interface VideoComponentProps {
    component: VideoComponentType;
}

export const VideoComponent: React.FC<VideoComponentProps> = ({ component }) => {
    const frame = useCurrentFrame();
    const { fps } = useVideoConfig();
    const videoRef = useRef<HTMLVideoElement>(null);
    const canvasRef = useRef<HTMLCanvasElement>(null);
    const animationFrameRef = useRef<number | undefined>(undefined);
    const [proxyUrl, setProxyUrl] = useState<string | null>(null);
    const [videoLoaded, setVideoLoaded] = useState(false);
    const [videoDuration, setVideoDuration] = useState(0);

    const style = component.style || {};
    const animationStyle = getAnimationStyle(frame, fps, style.animation);

    // Calculate current video time based on frame
    const videoTime = (frame / fps) + (style.startTime || 0);

    useEffect(() => {
        const proxyVideo = async () => {
            try {
                console.log('Proxying video:', component.videoUrl);
                const response = await fetch('http://localhost:3005/proxy_video', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ url: component.videoUrl }),
                });

                if (!response.ok) {
                    throw new Error('Failed to proxy video');
                }

                const data = await response.json();
                console.log('Received proxy URL:', data.url);
                setProxyUrl(data.url);
            } catch (error) {
                console.error('Error proxying video:', error);
            }
        };

        if (component.videoUrl) {
            proxyVideo();
        }

        return () => {
            setProxyUrl(null);
            setVideoLoaded(false);
        };
    }, [component.videoUrl]);

    // Sync video time with timeline
    useEffect(() => {
        const video = videoRef.current;
        if (!video || !videoLoaded) return;

        // Update video time
        if (Math.abs(video.currentTime - videoTime) > 0.1) {
            video.currentTime = videoTime;
        }

        // Update component duration when video metadata is loaded
        if (videoDuration === 0 && video.duration) {
            setVideoDuration(video.duration);
            // If this is a new video, update the component's duration
            if (!component.style?.duration) {
                const durationInFrames = Math.ceil(video.duration * fps);
                // You'll need to implement this update function in your state management
                // updateComponentDuration(component.id, durationInFrames);
            }
        }
    }, [frame, fps, videoLoaded, videoTime, videoDuration]);

    useEffect(() => {
        if (!videoRef.current || !canvasRef.current || !style.chromakey?.enabled || !proxyUrl || !videoLoaded) {
            console.log('Skipping chromakey setup. Conditions:', {
                hasVideoRef: !!videoRef.current,
                hasCanvasRef: !!canvasRef.current,
                chromakeyEnabled: style.chromakey?.enabled,
                hasProxyUrl: !!proxyUrl,
                videoLoaded
            });
            return;
        }

        console.log('Setting up chromakey effect with settings:', style.chromakey);

        const video = videoRef.current;
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        if (!ctx) {
            console.error('Failed to get canvas context');
            return;
        }

        const updateCanvasSize = () => {
            const newWidth = video.videoWidth || video.clientWidth;
            const newHeight = video.videoHeight || video.clientHeight;
            console.log('Updating canvas size:', { width: newWidth, height: newHeight });
            canvas.width = newWidth;
            canvas.height = newHeight;
        };

        const processFrame = () => {
            try {
                // Only process frame if video is at the correct time
                if (Math.abs(video.currentTime - videoTime) <= 0.1) {
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    
                    if (style.chromakey?.enabled) {
                        try {
                            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            const data = imageData.data;

                            const keyColor = style.chromakey.color || '#00ff00';
                            const r = parseInt(keyColor.slice(1, 3), 16);
                            const g = parseInt(keyColor.slice(3, 5), 16);
                            const b = parseInt(keyColor.slice(5, 7), 16);

                            const similarity = (style.chromakey.similarity || 0.4) * 255;
                            const smoothness = style.chromakey.smoothness || 0.1;

                            for (let i = 0; i < data.length; i += 4) {
                                const pixelR = data[i];
                                const pixelG = data[i + 1];
                                const pixelB = data[i + 2];

                                const diff = Math.sqrt(
                                    Math.pow(pixelR - r, 2) * 0.3 +
                                    Math.pow(pixelG - g, 2) * 0.59 +
                                    Math.pow(pixelB - b, 2) * 0.11
                                );

                                if (diff < similarity) {
                                    const alpha = Math.max(0, diff / (similarity * smoothness));
                                    data[i + 3] = Math.min(255, alpha * 255);
                                }
                            }

                            ctx.putImageData(imageData, 0, 0);
                        } catch (error) {
                            console.error('Error processing chromakey:', error);
                        }
                    }
                }

                // Request next frame
                animationFrameRef.current = requestAnimationFrame(processFrame);
            } catch (error) {
                console.error('Error processing frame:', error);
            }
        };

        updateCanvasSize();
        processFrame();

        return () => {
            if (animationFrameRef.current) {
                cancelAnimationFrame(animationFrameRef.current);
            }
        };
    }, [style.chromakey, proxyUrl, videoLoaded, videoTime]);

    const containerStyle: React.CSSProperties = {
        position: 'absolute',
        width: `${style.width || 100}%`,
        height: `${style.height || 100}%`,
        left: `${style.position?.x || 0}%`,
        top: `${style.position?.y || 0}%`,
        transform: `translate(-50%, -50%) scale(${style.scale || 1}) rotate(${style.rotation || 0}deg)`,
        opacity: style.opacity ?? 1,
        ...animationStyle,
    };

    if (!proxyUrl) {
        return <div style={containerStyle}>Loading video...</div>;
    }

    if (style.chromakey?.enabled) {
        return (
            <div style={containerStyle}>
                <video
                    ref={videoRef}
                    src={proxyUrl}
                    style={{ display: 'none' }}
                    autoPlay={false}
                    loop={false}
                    muted
                    playsInline
                    crossOrigin="anonymous"
                    onLoadedData={() => {
                        console.log('Video loaded');
                        setVideoLoaded(true);
                    }}
                />
                <canvas
                    ref={canvasRef}
                    style={{
                        width: '100%',
                        height: '100%',
                        objectFit: 'contain',
                    }}
                />
            </div>
        );
    }

    return (
        <div style={containerStyle}>
            <video
                ref={videoRef}
                src={proxyUrl}
                style={{
                    width: '100%',
                    height: '100%',
                    objectFit: 'contain',
                }}
                autoPlay={false}
                loop={false}
                muted
                playsInline
                crossOrigin="anonymous"
                onLoadedData={() => setVideoLoaded(true)}
            />
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\VideoPositioningScreen.tsx ---

import React from 'react';
import { VideoComponent } from '../../types/script';
import { theme } from '../../styles/theme';

interface VideoPositioningScreenProps {
    component: VideoComponent;
    onChange: (component: VideoComponent) => void;
}

export const VideoPositioningScreen: React.FC<VideoPositioningScreenProps> = ({ component, onChange }) => {
    const handlePositionChange = (x: number, y: number) => {
        onChange({
            ...component,
            style: {
                ...component.style,
                position: { x, y }
            }
        });
    };

    const handleSizeChange = (width: number, height: number) => {
        onChange({
            ...component,
            style: {
                ...component.style,
                width,
                height
            }
        });
    };

    const handleTimeChange = (startTime: number, duration: number) => {
        onChange({
            ...component,
            style: {
                ...component.style,
                startTime,
                duration
            }
        });
    };

    return (
        <div style={styles.container}>
            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Position</h3>
                <div style={styles.inputGroup}>
                    <label style={styles.label}>X Position (%)</label>
                    <input
                        type="number"
                        value={component.style?.position?.x || 0}
                        onChange={(e) => handlePositionChange(Number(e.target.value), component.style?.position?.y || 0)}
                        style={styles.input}
                        min={-100}
                        max={100}
                        step={1}
                    />
                </div>
                <div style={styles.inputGroup}>
                    <label style={styles.label}>Y Position (%)</label>
                    <input
                        type="number"
                        value={component.style?.position?.y || 0}
                        onChange={(e) => handlePositionChange(component.style?.position?.x || 0, Number(e.target.value))}
                        style={styles.input}
                        min={-100}
                        max={100}
                        step={1}
                    />
                </div>
            </div>

            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Size</h3>
                <div style={styles.inputGroup}>
                    <label style={styles.label}>Width (%)</label>
                    <input
                        type="number"
                        value={component.style?.width || 100}
                        onChange={(e) => handleSizeChange(Number(e.target.value), component.style?.height || 100)}
                        style={styles.input}
                        min={1}
                        max={500}
                        step={1}
                    />
                </div>
                <div style={styles.inputGroup}>
                    <label style={styles.label}>Height (%)</label>
                    <input
                        type="number"
                        value={component.style?.height || 100}
                        onChange={(e) => handleSizeChange(component.style?.width || 100, Number(e.target.value))}
                        style={styles.input}
                        min={1}
                        max={500}
                        step={1}
                    />
                </div>
            </div>

            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Time Control</h3>
                <div style={styles.inputGroup}>
                    <label style={styles.label}>Start Time (seconds)</label>
                    <input
                        type="number"
                        value={component.style?.startTime || 0}
                        onChange={(e) => handleTimeChange(Number(e.target.value), component.style?.duration || 0)}
                        style={styles.input}
                        min={0}
                        step={0.1}
                    />
                </div>
                <div style={styles.inputGroup}>
                    <label style={styles.label}>Duration (seconds)</label>
                    <input
                        type="number"
                        value={component.style?.duration || 0}
                        onChange={(e) => handleTimeChange(component.style?.startTime || 0, Number(e.target.value))}
                        style={styles.input}
                        min={0.1}
                        step={0.1}
                    />
                </div>
            </div>
        </div>
    );
};

const styles = {
    container: {
        padding: '1rem',
        backgroundColor: theme.backgroundLight,
        borderRadius: '8px',
        display: 'flex',
        flexDirection: 'column' as const,
        gap: '1rem',
    },
    section: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: '0.5rem',
    },
    sectionTitle: {
        margin: 0,
        color: theme.textPrimary,
        fontSize: '1rem',
        fontWeight: 600,
    },
    inputGroup: {
        display: 'flex',
        alignItems: 'center',
        gap: '0.5rem',
    },
    label: {
        color: theme.textSecondary,
        fontSize: '0.9rem',
        minWidth: '120px',
    },
    input: {
        padding: '0.25rem 0.5rem',
        borderRadius: '4px',
        border: `1px solid ${theme.borderColor}`,
        backgroundColor: theme.backgroundDark,
        color: theme.textPrimary,
        width: '80px',
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\common\ColorPicker.tsx ---

import React from 'react';
import { theme } from '../../styles/theme';

interface ColorPickerProps {
    label: string;
    color: string;
    onChange: (color: string) => void;
}

export const ColorPicker: React.FC<ColorPickerProps> = ({
    label,
    color,
    onChange,
}) => {
    return (
        <div style={styles.container}>
            <label style={styles.label}>{label}</label>
            <div style={styles.inputContainer}>
                <input
                    type="color"
                    value={color}
                    onChange={(e) => onChange(e.target.value)}
                    style={styles.colorInput}
                />
                <input
                    type="text"
                    value={color}
                    onChange={(e) => onChange(e.target.value)}
                    style={styles.textInput}
                />
            </div>
        </div>
    );
};

const styles = {
    container: {
        marginBottom: theme.spacing.sm,
    },
    label: {
        display: 'block',
        marginBottom: theme.spacing.xs,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
    },
    inputContainer: {
        display: 'flex',
        gap: theme.spacing.sm,
        alignItems: 'center',
    },
    colorInput: {
        width: '40px',
        height: '40px',
        padding: 0,
        border: `1px solid ${theme.colors.border}`,
        borderRadius: theme.borderRadius.sm,
        cursor: 'pointer',
    },
    textInput: {
        flex: 1,
        padding: theme.spacing.sm,
        backgroundColor: theme.colors.background.tertiary,
        border: `1px solid ${theme.colors.border}`,
        borderRadius: theme.borderRadius.sm,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\common\IconButton.tsx ---

import React, { useState } from 'react';
import { theme } from '../../styles/theme';

interface IconButtonProps {
    icon: string;
    onClick: () => void;
    tooltip?: string;
    disabled?: boolean;
    size?: 'sm' | 'md' | 'lg';
    variant?: 'primary' | 'secondary' | 'ghost';
}

export const IconButton: React.FC<IconButtonProps> = ({
    icon,
    onClick,
    tooltip,
    disabled = false,
    size = 'md',
    variant = 'ghost',
}) => {
    const [isHovered, setIsHovered] = useState(false);

    const sizeMap = {
        sm: {
            padding: theme.spacing.xs,
            fontSize: theme.fontSizes.sm,
        },
        md: {
            padding: theme.spacing.sm,
            fontSize: theme.fontSizes.md,
        },
        lg: {
            padding: theme.spacing.md,
            fontSize: theme.fontSizes.lg,
        },
    };

    const variantMap = {
        primary: {
            backgroundColor: theme.colors.primary,
            color: theme.colors.text.primary,
            hoverBg: theme.colors.accent.red,
        },
        secondary: {
            backgroundColor: theme.colors.background.tertiary,
            color: theme.colors.text.primary,
            hoverBg: theme.colors.background.secondary,
        },
        ghost: {
            backgroundColor: 'transparent',
            color: theme.colors.text.primary,
            hoverBg: theme.colors.background.tertiary,
        },
    };

    const currentVariant = variantMap[variant];

    return (
        <button
            onClick={onClick}
            disabled={disabled}
            title={tooltip}
            onMouseEnter={() => setIsHovered(true)}
            onMouseLeave={() => setIsHovered(false)}
            style={{
                border: 'none',
                borderRadius: theme.borderRadius.md,
                cursor: disabled ? 'not-allowed' : 'pointer',
                opacity: disabled ? 0.5 : 1,
                transition: theme.transitions.fast,
                backgroundColor: isHovered && !disabled ? currentVariant.hoverBg : currentVariant.backgroundColor,
                color: currentVariant.color,
                ...sizeMap[size],
                display: 'inline-flex',
                alignItems: 'center',
                justifyContent: 'center',
                minWidth: sizeMap[size].fontSize,
                minHeight: sizeMap[size].fontSize,
                padding: sizeMap[size].padding,
                outline: 'none',
                boxShadow: isHovered && !disabled ? theme.shadows.sm : 'none',
            }}
        >
            {icon}
        </button>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\common\Modal.tsx ---

import React from 'react';
import { theme } from '../../styles/theme';

interface ModalProps {
    isOpen: boolean;
    onClose: () => void;
    title: React.ReactNode;
    children: React.ReactNode;
}

export const Modal: React.FC<ModalProps> = ({ isOpen, onClose, title, children }) => {
    if (!isOpen) return null;

    return (
        <div style={{
            position: 'fixed',
            top: '48px', // Header height
            left: 0,
            width: '75%', // Match the timeline section width
            height: 'calc(100vh - 48px)',
            backgroundColor: 'rgba(0, 0, 0, 0.75)',
            display: 'flex',
            justifyContent: 'flex-start',
            alignItems: 'center',
            zIndex: 1000,
            backdropFilter: 'blur(4px)',
            padding: theme.spacing.xl,
        }}>
            <div style={{
                backgroundColor: theme.colors.background.primary,
                borderRadius: theme.borderRadius.lg,
                border: `1px solid ${theme.colors.border}`,
                boxShadow: '0 8px 32px rgba(0, 0, 0, 0.4)',
                width: '90%',
                maxWidth: '800px',
                maxHeight: '90vh',
                display: 'flex',
                flexDirection: 'column',
                overflow: 'hidden',
                marginLeft: theme.spacing.xl,
            }}>
                {/* Header */}
                <div style={{
                    padding: theme.spacing.lg,
                    borderBottom: `1px solid ${theme.colors.border}`,
                    backgroundColor: theme.colors.background.secondary,
                    position: 'relative',
                }}>
                    <button
                        onClick={onClose}
                        style={{
                            position: 'absolute',
                            top: '50%',
                            right: theme.spacing.md,
                            transform: 'translateY(-50%)',
                            background: 'none',
                            border: 'none',
                            color: theme.colors.text.secondary,
                            fontSize: '24px',
                            cursor: 'pointer',
                            width: '32px',
                            height: '32px',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            borderRadius: theme.borderRadius.sm,
                            transition: 'all 0.2s ease',
                        }}
                        onMouseEnter={(e) => {
                            e.currentTarget.style.backgroundColor = theme.colors.background.tertiary;
                            e.currentTarget.style.color = theme.colors.text.primary;
                        }}
                        onMouseLeave={(e) => {
                            e.currentTarget.style.backgroundColor = 'transparent';
                            e.currentTarget.style.color = theme.colors.text.secondary;
                        }}
                    >
                        ×
                    </button>
                    <div style={{ paddingRight: '32px' }}>
                        {title}
                    </div>
                </div>

                {/* Content */}
                <div style={{
                    flex: 1,
                    overflow: 'auto',
                    padding: theme.spacing.lg,
                }}>
                    {children}
                </div>
            </div>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\common\Slider.tsx ---

import React from 'react';
import { theme } from '../../styles/theme';

interface SliderProps {
    label: string;
    value: number;
    onChange: (value: number) => void;
    min: number;
    max: number;
    step?: number;
}

export const Slider: React.FC<SliderProps> = ({
    label,
    value,
    onChange,
    min,
    max,
    step = 1,
}) => {
    return (
        <div style={styles.container}>
            <div style={styles.header}>
                <label style={styles.label}>{label}</label>
                <input
                    type="number"
                    value={value}
                    onChange={(e) => onChange(Number(e.target.value))}
                    min={min}
                    max={max}
                    step={step}
                    style={styles.numberInput}
                />
            </div>
            <input
                type="range"
                value={value}
                onChange={(e) => onChange(Number(e.target.value))}
                min={min}
                max={max}
                step={step}
                style={styles.slider}
            />
        </div>
    );
};

const styles = {
    container: {
        marginBottom: theme.spacing.sm,
    },
    header: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: theme.spacing.xs,
    },
    label: {
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
    },
    numberInput: {
        width: '60px',
        padding: theme.spacing.xs,
        backgroundColor: theme.colors.background.tertiary,
        border: `1px solid ${theme.colors.border}`,
        borderRadius: theme.borderRadius.sm,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
        textAlign: 'right' as const,
    },
    slider: {
        width: '100%',
        height: '2px',
        WebkitAppearance: 'none',
        background: theme.colors.primary,
        outline: 'none',
        opacity: 0.7,
        transition: 'opacity 0.2s',
        cursor: 'pointer',
        '&:hover': {
            opacity: 1,
        },
        '&::-webkit-slider-thumb': {
            WebkitAppearance: 'none',
            appearance: 'none',
            width: '16px',
            height: '16px',
            background: theme.colors.primary,
            borderRadius: '50%',
            cursor: 'pointer',
        },
        '&::-moz-range-thumb': {
            width: '16px',
            height: '16px',
            background: theme.colors.primary,
            borderRadius: '50%',
            cursor: 'pointer',
        },
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\common\Switch.tsx ---

import React from 'react';
import { theme } from '../../styles/theme';

interface SwitchProps {
    label: string;
    checked: boolean;
    onChange: (checked: boolean) => void;
}

export const Switch: React.FC<SwitchProps> = ({
    label,
    checked,
    onChange,
}) => {
    return (
        <div style={styles.container}>
            <label style={styles.label}>
                <input
                    type="checkbox"
                    checked={checked}
                    onChange={(e) => onChange(e.target.checked)}
                    style={styles.input}
                />
                <span style={styles.switch}>
                    <span style={{
                        ...styles.slider,
                        transform: checked ? 'translateX(20px)' : 'translateX(0)',
                        backgroundColor: checked ? theme.colors.primary : theme.colors.background.tertiary,
                    }} />
                </span>
                <span style={styles.text}>{label}</span>
            </label>
        </div>
    );
};

const styles = {
    container: {
        marginBottom: theme.spacing.sm,
    },
    label: {
        display: 'flex',
        alignItems: 'center',
        cursor: 'pointer',
        userSelect: 'none' as const,
    },
    input: {
        display: 'none',
    },
    switch: {
        position: 'relative' as const,
        display: 'inline-block',
        width: '40px',
        height: '20px',
        backgroundColor: theme.colors.background.secondary,
        borderRadius: '10px',
        marginRight: theme.spacing.sm,
    },
    slider: {
        position: 'absolute' as const,
        top: '2px',
        left: '2px',
        width: '16px',
        height: '16px',
        borderRadius: '50%',
        transition: 'transform 0.2s, background-color 0.2s',
    },
    text: {
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components-dump.txt ---


+--------------------------------------------+
| Dump tree for directory: D:\Projects\Remotion Couples Quiz\my-video\src\components |
+--------------------------------------------+
├── Audio
├── Comparison.tsx
├── ComparisonEditor.tsx
├── ConfigMenu
│  └── ConfigMenu.tsx
├── ImageSelector.tsx
├── Layout
│  └── AppLayout.tsx
├── QuizSetup.tsx
├── ScriptEditor
│  ├── AudioComponentEditor.tsx
│  ├── CaptionEditor.tsx
│  ├── CaptionPositioningScreen.tsx
│  ├── CaptionTimeline.tsx
│  ├── ComparisonComponentEditor.tsx
│  ├── ComponentEditor.tsx
│  ├── ComponentEditors.tsx
│  ├── ComponentPalette.tsx
│  ├── CountdownComponentEditor.tsx
│  ├── DraggablePreview.tsx
│  ├── ImageComponentEditor.tsx
│  ├── PositioningScreen.tsx
│  ├── ScriptEditor.tsx
│  ├── TextComponentEditor.tsx
│  ├── Timeline.tsx
│  ├── TitleComponentEditor.tsx
│  ├── VideoComponentEditor.tsx
│  ├── VoiceComponent.tsx
│  ├── VoiceComponentEditor.tsx
│  └── VoiceOverEditor.tsx
├── Settings
│  ├── BackgroundManager.tsx
│  ├── FontManager.tsx
│  └── PositioningPopup.tsx
├── Setup
│  ├── ComparisonEditor.tsx
│  ├── ImagePicker.tsx
│  ├── ImageSelector.tsx
│  └── Setup.tsx
├── SetupPage.tsx
├── TemplateManager
│  └── TemplateManager.tsx
├── Timer.tsx
├── Video
│  ├── AudioComponent.tsx
│  ├── CaptionRenderer.tsx
│  ├── ComparisonComponent.tsx
│  ├── ComparisonSequence.tsx
│  ├── CountdownSequence.tsx
│  ├── ImageComponent.tsx
│  ├── QuizVideo.tsx
│  ├── RemotionSubtitleCaption.tsx
│  ├── ScriptVideo.tsx
│  ├── TextComponent.tsx
│  ├── TextSequence.tsx
│  ├── TikTokCaptions.tsx
│  ├── TitleSequence.tsx
│  ├── TransitionSequence.tsx
│  ├── VideoComponent.tsx
│  └── VideoPositioningScreen.tsx
└── common
   ├── ColorPicker.tsx
   ├── IconButton.tsx
   ├── Modal.tsx
   ├── Slider.tsx
   └── Switch.tsx



--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Comparison.tsx ---

import {
	AbsoluteFill,
	useCurrentFrame,
	interpolate,
	spring,
	useVideoConfig,
} from 'remotion';
import {Timer} from './Timer';
import {QuizItem} from '../data/quizData';

interface ComparisonProps {
	data: QuizItem;
	startFrame: number;
}

export const Comparison: React.FC<ComparisonProps> = ({data, startFrame}) => {
	const frame = useCurrentFrame();
	const {fps} = useVideoConfig();
	const relativeFrame = frame - startFrame;
	
	const opacity = spring({
		frame: relativeFrame,
		fps,
		config: {
			damping: 200,
		},
	});

	if (relativeFrame < 0 || relativeFrame > 150) return null;

	return (
		<AbsoluteFill>
			<div style={{
				opacity,
				display: 'flex',
				flexDirection: 'column',
				alignItems: 'center',
				padding: 40,
			}}>
				<h1 style={{
					fontSize: 60,
					color: 'white',
					textAlign: 'center',
					marginBottom: 40,
				}}>
					{data.question}
				</h1>
				
				<div style={{
					display: 'flex',
					width: '100%',
					justifyContent: 'space-between',
				}}>
					{/* Left Option */}
					<div style={{flex: 1, padding: 20}}>
						<img
							src={data.leftOption.image}
							style={{
								width: '100%',
								height: 'auto',
								borderRadius: 20,
							}}
						/>
						<h2 style={{
							color: 'white',
							textAlign: 'center',
							fontSize: 40,
						}}>
							{data.leftOption.text}
						</h2>
					</div>

					{/* Right Option */}
					<div style={{flex: 1, padding: 20}}>
						<img
							src={data.rightOption.image}
							style={{
								width: '100%',
								height: 'auto',
								borderRadius: 20,
							}}
						/>
						<h2 style={{
							color: 'white',
							textAlign: 'center',
							fontSize: 40,
						}}>
							{data.rightOption.text}
						</h2>
					</div>
				</div>

				<Timer startFrame={startFrame} />
			</div>
		</AbsoluteFill>
	);
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ComparisonEditor.tsx ---

import React from 'react';
import {Comparison} from '../types/quiz';
import { ImageSelector } from './ImageSelector';

interface ComparisonEditorProps {
	comparison: Comparison;
	onChange: (updatedComparison: Comparison) => void;
	onDelete: () => void;
}

export const ComparisonEditor: React.FC<ComparisonEditorProps> = ({
	comparison,
	onChange,
	onDelete,
}) => {
	return (
		<div style={{
			padding: '20px',
			border: '1px solid #ccc',
			borderRadius: '8px',
			backgroundColor: '#f8f9fa',
		}}>
			{/* Question Section */}
			<div style={{marginBottom: '20px'}}>
				<label style={{display: 'block', marginBottom: '8px', fontWeight: 'bold'}}>
					Question:
				</label>
				<input
					type="text"
					value={comparison.question}
					onChange={(e) => {
						onChange({
							...comparison,
							question: e.target.value,
						});
					}}
					style={{
						width: '100%',
						padding: '8px',
						fontSize: '16px',
						borderRadius: '4px',
						border: '1px solid #ddd',
					}}
					placeholder="Enter your question..."
				/>
			</div>

			{/* Options Section */}
			<div style={{
				display: 'grid',
				gridTemplateColumns: '1fr 1fr',
				gap: '20px',
			}}>
				{/* Left Option */}
				<div>
					<label style={{display: 'block', marginBottom: '8px', fontWeight: 'bold'}}>
						Left Option:
					</label>
					<input
						type="text"
						value={comparison.leftOption.text}
						onChange={(e) => {
							onChange({
								...comparison,
								leftOption: {
									...comparison.leftOption,
									text: e.target.value,
								},
							});
						}}
						style={{
							width: '100%',
							padding: '8px',
							fontSize: '16px',
							borderRadius: '4px',
							border: '1px solid #ddd',
							marginBottom: '10px',
						}}
						placeholder="Enter left option..."
					/>
					{/* Left Option Image Selection */}
					<ImageSelector
						searchTerm={comparison.leftOption.text}
						onSelect={(imageUrl) => {
							onChange({
								...comparison,
								leftOption: {
									...comparison.leftOption,
									imageUrl,
								},
							});
						}}
						currentImageUrl={comparison.leftOption.imageUrl}
					/>
				</div>

				{/* Right Option */}
				<div>
					<label style={{display: 'block', marginBottom: '8px', fontWeight: 'bold'}}>
						Right Option:
					</label>
					<input
						type="text"
						value={comparison.rightOption.text}
						onChange={(e) => {
							onChange({
								...comparison,
								rightOption: {
									...comparison.rightOption,
									text: e.target.value,
								},
							});
						}}
						style={{
							width: '100%',
							padding: '8px',
							fontSize: '16px',
							borderRadius: '4px',
							border: '1px solid #ddd',
							marginBottom: '10px',
						}}
						placeholder="Enter right option..."
					/>
					{/* Right Option Image Selection */}
					<ImageSelector
						searchTerm={comparison.rightOption.text}
						onSelect={(imageUrl) => {
							onChange({
								...comparison,
								rightOption: {
									...comparison.rightOption,
									imageUrl,
								},
							});
						}}
						currentImageUrl={comparison.rightOption.imageUrl}
					/>
				</div>
			</div>

			{/* Delete Button */}
			<button
				onClick={onDelete}
				style={{
					marginTop: '20px',
					padding: '8px 16px',
					backgroundColor: '#dc3545',
					color: 'white',
					border: 'none',
					borderRadius: '4px',
					cursor: 'pointer',
				}}
			>
				Delete Comparison
			</button>
		</div>
	);
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ConfigMenu\ConfigMenu.tsx ---

import React, { useState, useEffect } from 'react';
import { Modal } from '../common/Modal';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';
import { ImageSelector } from '../Setup/ImageSelector';
import { Script } from '../../types/script';
import { useConfigStore } from '../../store/configStore';
import { useVideoConfig } from 'remotion';
import { useApiKeys } from '../../store/apiKeysStore';
import { FontManager } from '../Settings/FontManager';
import { BackgroundManager } from '../Settings/BackgroundManager';

interface ConfigMenuProps {
    isOpen: boolean;
    onClose: () => void;
    script: Script;
    onScriptChange: (script: Script) => void;
}

interface ExportSettings {
    fps: number;
    width: number;
    height: number;
    codec: 'h264' | 'h265' | 'vp8' | 'vp9';
    quality: number;
}

export const ConfigMenu: React.FC<ConfigMenuProps> = ({
    isOpen,
    onClose,
    script,
    onScriptChange,
}) => {
    const fps = 30;
    const { 
        elevenLabsApiKey, 
        pexelsApiKey, 
        setElevenLabsApiKey,
        setPexelsApiKey,
    } = useApiKeys();

    const [localElevenLabsKey, setLocalElevenLabsKey] = useState(elevenLabsApiKey);
    const [localPexelsKey, setLocalPexelsKey] = useState(pexelsApiKey);
    const [showKeys, setShowKeys] = useState(false);
    const [isFontManagerOpen, setIsFontManagerOpen] = useState(false);
    const [showBackgroundManager, setShowBackgroundManager] = useState(false);
    const [saving, setSaving] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [exportSettings, setExportSettings] = useState<ExportSettings>({
        fps: 30,
        width: 1920,
        height: 1080,
        codec: 'h264',
        quality: 100
    });

    useEffect(() => {
        // Load initial config
        fetch('http://localhost:5003/config')
            .then(res => res.json())
            .then(data => {
                setLocalPexelsKey(data.pexels_api_key || '');
            })
            .catch(err => {
                console.error('Failed to load config:', err);
                setError('Failed to load configuration');
            });
    }, []);

    const handleSave = () => {
        setElevenLabsApiKey(localElevenLabsKey);
        setPexelsApiKey(localPexelsKey);
        
        // Also update the image service config
        fetch('http://localhost:5003/config', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                pexels_api_key: localPexelsKey,
            }),
        }).catch(err => {
            console.error('Failed to update image service config:', err);
        });
        
        onClose();
    };

    const handleBackgroundChange = () => {
        // Create a file input
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*,video/*';
        
        // Handle file selection
        input.onchange = async (e: Event) => {
            const file = (e.target as HTMLInputElement).files?.[0];
            if (!file) return;

            console.log('Selected file:', file.name, file.type);

            // Create form data
            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('http://localhost:3002/set_background', {
                    method: 'POST',
                    body: formData,
                });

                if (!response.ok) {
                    throw new Error('Failed to upload background');
                }

                const { filePath } = await response.json();

                // Update script with new background settings
                const backgroundType = file.type.startsWith('video/') ? 'video' as const : 'image' as const;
                const updatedScript = {
                    ...script,
                    settings: {
                        ...script.settings,
                        background: {
                            type: backgroundType,
                            url: filePath,
                            filePath: file.name,
                            ...(backgroundType === 'video' ? { durationInFrames: 300 } : {})
                        }
                    }
                };

                onScriptChange(updatedScript);
            } catch (error) {
                console.error('Error uploading background:', error);
            }
        };

        // Trigger file selection
        input.click();
    };

    const handleSaveConfig = async () => {
        setSaving(true);
        setError(null);

        try {
            const response = await fetch('http://localhost:5003/config', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    pexels_api_key: pexelsApiKey,
                }),
            });

            if (!response.ok) {
                throw new Error('Failed to save configuration');
            }

            // Show success message or update UI as needed
        } catch (err) {
            console.error('Failed to save config:', err);
            setError(err instanceof Error ? err.message : 'Failed to save configuration');
        } finally {
            setSaving(false);
        }
    };

    return (
        <>
            <Modal
                isOpen={isOpen}
                onClose={onClose}
                title={
                    <h2 style={{
                        ...commonStyles.heading,
                        margin: 0,
                        display: 'flex',
                        alignItems: 'center',
                        gap: theme.spacing.sm,
                        color: theme.colors.text.primary,
                        fontSize: '20px',
                    }}>
                        ⚙️ Settings
                    </h2>
                }
            >
                <div style={{
                    display: 'flex',
                    flexDirection: 'column',
                    gap: theme.spacing.md,
                }}>
                    {/* API Key Settings */}
                    <div>
                        <h3 style={commonStyles.heading}>API Keys</h3>
                        <div style={{
                            display: 'flex',
                            justifyContent: 'space-between',
                            alignItems: 'center',
                            marginBottom: '10px',
                        }}>
                            <label style={{ color: theme.colors.text.primary }}>Show API Keys:</label>
                            <input
                                type="checkbox"
                                checked={showKeys}
                                onChange={(e) => setShowKeys(e.target.checked)}
                            />
                        </div>

                        <div style={{ marginBottom: '16px' }}>
                            <label style={{
                                display: 'block',
                                color: theme.colors.text.primary,
                                marginBottom: '8px',
                            }}>
                                ElevenLabs API Key:
                            </label>
                            <input
                                type={showKeys ? 'text' : 'password'}
                                value={localElevenLabsKey}
                                onChange={(e) => setLocalElevenLabsKey(e.target.value)}
                                style={{
                                    width: '100%',
                                    padding: '8px',
                                    backgroundColor: theme.colors.background.secondary,
                                    border: `1px solid ${theme.colors.border}`,
                                    borderRadius: theme.borderRadius.sm,
                                    color: theme.colors.text.primary,
                                }}
                                placeholder="Enter your ElevenLabs API key"
                            />
                        </div>

                        <div style={{ marginBottom: '16px' }}>
                            <label style={{
                                display: 'block',
                                color: theme.colors.text.primary,
                                marginBottom: '8px',
                            }}>
                                Pexels API Key:
                            </label>
                            <input
                                type={showKeys ? 'text' : 'password'}
                                value={localPexelsKey}
                                onChange={(e) => setLocalPexelsKey(e.target.value)}
                                style={{
                                    width: '100%',
                                    padding: '8px',
                                    backgroundColor: theme.colors.background.secondary,
                                    border: `1px solid ${theme.colors.border}`,
                                    borderRadius: theme.borderRadius.sm,
                                    color: theme.colors.text.primary,
                                }}
                                placeholder="Enter your Pexels API key"
                            />
                        </div>
                    </div>

                    {/* Background Settings */}
                    <div>
                        <h3 style={commonStyles.heading}>Background</h3>
                        <div style={{
                            display: 'flex',
                            flexDirection: 'column',
                            gap: theme.spacing.sm,
                        }}>
                            <button
                                onClick={() => setShowBackgroundManager(true)}
                                style={commonStyles.button.secondary}
                            >
                                Manage Backgrounds
                            </button>
                            {script.settings.background?.url && (
                                <button
                                    onClick={() => onScriptChange({
                                        ...script,
                                        settings: {
                                            ...script.settings,
                                            background: {
                                                type: 'none',
                                            },
                                        },
                                    })}
                                    style={{
                                        ...commonStyles.button.secondary,
                                        color: theme.colors.error,
                                    }}
                                >
                                    Reset to Default
                                </button>
                            )}
                            {script.settings.background?.type === 'video' && (
                                <div style={{
                                    color: theme.colors.text.secondary,
                                    fontSize: '0.9em',
                                    marginTop: theme.spacing.sm,
                                }}>
                                    Note: Video will loop if timeline exceeds video length
                                </div>
                            )}
                        </div>
                    </div>

                    {/* Font Manager Button */}
                    <div>
                        <button
                            onClick={() => setIsFontManagerOpen(true)}
                            style={{
                                ...commonStyles.button,
                                width: '100%',
                                padding: theme.spacing.md,
                                backgroundColor: theme.colors.primary,
                                color: theme.colors.text.primary,
                            }}
                        >
                            Manage Custom Fonts
                        </button>
                    </div>

                    {/* Export Settings */}
                    <div>
                        <h3 style={commonStyles.heading}>Export Settings</h3>
                        <div style={{
                            display: 'grid',
                            gridTemplateColumns: '1fr 1fr',
                            gap: theme.spacing.sm,
                        }}>
                            <div>
                                <label style={styles.label}>FPS:</label>
                                <input
                                    type="number"
                                    value={exportSettings.fps}
                                    onChange={(e) => setExportSettings({
                                        ...exportSettings,
                                        fps: Number(e.target.value)
                                    })}
                                    min={1}
                                    max={60}
                                    style={styles.input}
                                />
                            </div>
                            <div>
                                <label style={styles.label}>Quality (%):</label>
                                <input
                                    type="number"
                                    value={exportSettings.quality}
                                    onChange={(e) => setExportSettings({
                                        ...exportSettings,
                                        quality: Number(e.target.value)
                                    })}
                                    min={1}
                                    max={100}
                                    style={styles.input}
                                />
                            </div>
                            <div>
                                <label style={styles.label}>Width:</label>
                                <input
                                    type="number"
                                    value={exportSettings.width}
                                    onChange={(e) => setExportSettings({
                                        ...exportSettings,
                                        width: Number(e.target.value)
                                    })}
                                    min={100}
                                    max={3840}
                                    step={2}
                                    style={styles.input}
                                />
                            </div>
                            <div>
                                <label style={styles.label}>Height:</label>
                                <input
                                    type="number"
                                    value={exportSettings.height}
                                    onChange={(e) => setExportSettings({
                                        ...exportSettings,
                                        height: Number(e.target.value)
                                    })}
                                    min={100}
                                    max={2160}
                                    step={2}
                                    style={styles.input}
                                />
                            </div>
                            <div style={{ gridColumn: '1 / -1' }}>
                                <label style={styles.label}>Codec:</label>
                                <select
                                    value={exportSettings.codec}
                                    onChange={(e) => setExportSettings({
                                        ...exportSettings,
                                        codec: e.target.value as ExportSettings['codec']
                                    })}
                                    style={styles.select}
                                >
                                    <option value="h264">H.264</option>
                                    <option value="h265">H.265 (HEVC)</option>
                                    <option value="vp8">VP8</option>
                                    <option value="vp9">VP9</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    {/* Save Button */}
                    <div style={{
                        display: 'flex',
                        justifyContent: 'flex-end',
                        gap: theme.spacing.sm,
                        marginTop: theme.spacing.md,
                    }}>
                        <button
                            onClick={onClose}
                            style={commonStyles.button.secondary}
                        >
                            Cancel
                        </button>
                        <button
                            onClick={handleSave}
                            style={commonStyles.button.primary}
                        >
                            Save
                        </button>
                    </div>
                </div>
            </Modal>

            {/* Background Manager Modal */}
            {showBackgroundManager && (
                <Modal
                    isOpen={showBackgroundManager}
                    onClose={() => setShowBackgroundManager(false)}
                    title="Background Manager"
                >
                    <BackgroundManager
                        onSelectBackground={(background) => {
                            onScriptChange({
                                ...script,
                                settings: {
                                    ...script.settings,
                                    background: background
                                }
                            });
                            setShowBackgroundManager(false);
                        }}
                    />
                </Modal>
            )}

            {/* Font Manager Modal */}
            {isFontManagerOpen && (
                <FontManager onClose={() => setIsFontManagerOpen(false)} />
            )}
        </>
    );
};

const styles = {
    label: {
        display: 'block',
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
        marginBottom: theme.spacing.xs,
    },
    input: {
        width: '100%',
        padding: theme.spacing.sm,
        backgroundColor: theme.colors.background.secondary,
        border: `1px solid ${theme.colors.border}`,
        borderRadius: theme.borderRadius.sm,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
    },
    select: {
        width: '100%',
        padding: theme.spacing.sm,
        backgroundColor: theme.colors.background.secondary,
        border: `1px solid ${theme.colors.border}`,
        borderRadius: theme.borderRadius.sm,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ImageSelector.tsx ---

import React, { useState, useEffect } from 'react';
import { createClient, Photo } from 'pexels';
import { theme } from '../styles/theme';

const client = createClient('rXEDE5m6pUxOXZPawHmzKj04Z29WlV2y0Us44ld2TmXwdZstXtHUIh2F');

interface ImageSelectorProps {
    searchTerm: string;
    onSelect: (imageUrl: string) => void;
    currentImageUrl?: string;
    orientation?: 'portrait' | 'landscape' | 'square';
}

export const ImageSelector: React.FC<ImageSelectorProps> = ({
    searchTerm,
    onSelect,
    currentImageUrl,
    orientation = 'landscape'
}) => {
    const [images, setImages] = useState<Photo[]>([]);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [page, setPage] = useState(1);
    const [totalPages, setTotalPages] = useState(1);
    const perPage = 6;

    useEffect(() => {
        if (!searchTerm) return;

        const searchImages = async () => {
            setLoading(true);
            setError(null);
            try {
                const result = await client.photos.search({
                    query: searchTerm,
                    per_page: perPage,
                    page,
                    orientation
                });
                setImages(result.photos || []);
                setTotalPages(Math.ceil((result.total_results || 0) / perPage));
            } catch (err) {
                setError('Failed to load images');
                console.error(err);
            } finally {
                setLoading(false);
            }
        };

        searchImages();
    }, [searchTerm, page, orientation]);

    return (
        <div style={styles.container}>
            {loading && <div style={styles.loading}>Loading images...</div>}
            {error && <div style={styles.error}>{error}</div>}
            
            <div style={styles.grid}>
                {images.map((photo) => (
                    <div
                        key={photo.id}
                        style={{
                            ...styles.imageContainer,
                            border: currentImageUrl === photo.src.medium ? `3px solid ${theme.colors.primary}` : '1px solid #ddd',
                        }}
                        onClick={() => onSelect(photo.src.medium)}
                    >
                        <img
                            src={photo.src.medium}
                            alt={photo.alt || 'Option image'}
                            style={styles.image}
                        />
                        <div style={styles.imageOverlay}>
                            <span>Select</span>
                        </div>
                    </div>
                ))}
            </div>

            {totalPages > 1 && (
                <div style={styles.pagination}>
                    <button
                        onClick={() => setPage(p => Math.max(1, p - 1))}
                        disabled={page === 1}
                        style={{
                            ...styles.button,
                            opacity: page === 1 ? 0.5 : 1
                        }}
                    >
                        Previous
                    </button>
                    <span style={styles.pageInfo}>
                        Page {page} of {totalPages}
                    </span>
                    <button
                        onClick={() => setPage(p => Math.min(totalPages, p + 1))}
                        disabled={page === totalPages}
                        style={{
                            ...styles.button,
                            opacity: page === totalPages ? 0.5 : 1
                        }}
                    >
                        Next
                    </button>
                </div>
            )}
        </div>
    );
};

const styles = {
    container: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.md,
    },
    loading: {
        textAlign: 'center' as const,
        padding: theme.spacing.md,
        color: theme.colors.text.secondary,
    },
    error: {
        textAlign: 'center' as const,
        padding: theme.spacing.md,
        color: theme.colors.error,
    },
    grid: {
        display: 'grid',
        gridTemplateColumns: 'repeat(2, 1fr)',
        gap: theme.spacing.md,
    },
    imageContainer: {
        position: 'relative' as const,
        cursor: 'pointer',
        borderRadius: theme.borderRadius.md,
        overflow: 'hidden',
        aspectRatio: '16/9',
        transition: 'transform 0.2s ease-in-out',
        '&:hover': {
            transform: 'scale(1.02)',
        },
    },
    image: {
        width: '100%',
        height: '100%',
        objectFit: 'cover' as const,
    },
    imageOverlay: {
        position: 'absolute' as const,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        background: 'rgba(0, 0, 0, 0.5)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        color: '#fff',
        opacity: 0,
        transition: 'opacity 0.2s ease-in-out',
        '&:hover': {
            opacity: 1,
        },
    },
    pagination: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        gap: theme.spacing.md,
        marginTop: theme.spacing.md,
    },
    pageInfo: {
        color: theme.colors.text.secondary,
    },
    button: {
        padding: `${theme.spacing.sm} ${theme.spacing.md}`,
        backgroundColor: theme.colors.primary,
        color: '#fff',
        border: 'none',
        borderRadius: theme.borderRadius.sm,
        cursor: 'pointer',
        '&:disabled': {
            cursor: 'not-allowed',
        },
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Layout\AppLayout.tsx ---

import React, { useState } from 'react';
import { theme } from '../../styles/theme';
import { ConfigMenu } from '../ConfigMenu/ConfigMenu';
import { Script } from '../../types/script';
import { exportVideo } from '../../services/videoService';

interface AppLayoutProps {
    children: [React.ReactNode, React.ReactNode, React.ReactNode]; // Left, Center, Right content
    script: Script;
    onScriptChange: (script: Script) => void;
}

export const AppLayout: React.FC<AppLayoutProps> = ({ 
    children: [leftContent, centerContent, rightContent],
    script,
    onScriptChange,
}) => {
    const [isConfigOpen, setIsConfigOpen] = useState(false);
    const [isExporting, setIsExporting] = useState(false);

    const handleExportVideo = async () => {
        try {
            console.log('Starting video export...');
            console.log('Script data:', script);
            setIsExporting(true);
            const outputLocation = await exportVideo(script);
            console.log('Video exported successfully to:', outputLocation);
            alert(`Video exported successfully to: ${outputLocation}`);
        } catch (error) {
            console.error('Error exporting video:', error);
            alert('Failed to export video. Check console for details.');
        } finally {
            setIsExporting(false);
        }
    };

    return (
        <div style={{
            minHeight: '100vh',
            backgroundColor: theme.colors.background.primary,
            color: theme.colors.text.primary,
            display: 'grid',
            gridTemplateRows: 'auto 1fr',
            overflowX: 'hidden',
        }}>
            {/* Header */}
            <header style={{
                backgroundColor: theme.colors.background.secondary,
                borderBottom: `1px solid ${theme.colors.border}`,
                padding: `${theme.spacing.md} ${theme.spacing.xl}`,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between',
                boxShadow: theme.shadows.md,
                position: 'sticky',
                top: 0,
                zIndex: 100,
            }}>
                <div style={{ display: 'flex', alignItems: 'center', gap: theme.spacing.md }}>
                    <h1 style={{ 
                        margin: 0, 
                        fontSize: '24px',
                        background: `linear-gradient(135deg, ${theme.colors.primary}, ${theme.colors.secondary})`,
                        WebkitBackgroundClip: 'text',
                        WebkitTextFillColor: 'transparent',
                        fontWeight: 'bold',
                    }}>
                        Couples Quiz Creator
                    </h1>
                </div>
                <nav style={{
                    display: 'flex',
                    gap: theme.spacing.lg,
                }}>
                    <button style={{
                        ...commonButtonStyle,
                        backgroundColor: 'transparent',
                        color: theme.colors.text.primary,
                    }}
                    onClick={() => setIsConfigOpen(true)}
                    >
                        ⚙️ Settings
                    </button>
                    <button style={{
                        ...commonButtonStyle,
                        backgroundColor: theme.colors.primary,
                        color: theme.colors.text.primary,
                        opacity: isExporting ? 0.7 : 1,
                        cursor: isExporting ? 'not-allowed' : 'pointer',
                    }}
                    onClick={handleExportVideo}
                    disabled={isExporting}
                    >
                        {isExporting ? 'Exporting...' : 'Export Video'}
                    </button>
                </nav>
            </header>

            {/* Main Content */}
            <main style={{
                padding: `${theme.spacing.lg} ${theme.spacing.lg}`,
                display: 'grid',
                gridTemplateColumns: '280px 1fr minmax(500px, 800px)',
                gap: theme.spacing.lg,
                height: 'calc(100vh - 80px)', // Subtract header height
                position: 'relative',
                overflow: 'hidden', // Prevent content from expanding outside
            }}>
                {/* Left Sidebar - Component Palette */}
                <aside style={{
                    backgroundColor: theme.colors.background.secondary,
                    borderRadius: theme.borderRadius.lg,
                    padding: theme.spacing.md,
                    boxShadow: theme.shadows.md,
                    border: `1px solid ${theme.colors.border}`,
                    position: 'sticky',
                    top: '80px',
                    height: 'fit-content',
                    maxHeight: 'calc(100vh - 100px)',
                    overflowY: 'auto',
                }}>
                    {leftContent}
                </aside>

                {/* Center Content - Preview */}
                <div style={{
                    backgroundColor: theme.colors.background.secondary,
                    borderRadius: theme.borderRadius.lg,
                    padding: theme.spacing.md,
                    boxShadow: theme.shadows.md,
                    border: `1px solid ${theme.colors.border}`,
                    display: 'flex',
                    flexDirection: 'column',
                    gap: theme.spacing.md,
                    overflowY: 'auto',
                }}>
                    {centerContent}
                </div>

                {/* Right Sidebar - Properties */}
                <aside style={{
                    backgroundColor: theme.colors.background.secondary,
                    borderRadius: theme.borderRadius.lg,
                    padding: theme.spacing.md,
                    boxShadow: theme.shadows.md,
                    border: `1px solid ${theme.colors.border}`,
                    position: 'sticky',
                    top: '80px',
                    height: 'calc(100vh - 100px)',
                    overflowY: 'auto',
                }}>
                    {rightContent}
                </aside>
            </main>

            {/* Config Menu */}
            <ConfigMenu
                isOpen={isConfigOpen}
                onClose={() => setIsConfigOpen(false)}
                script={script}
                onScriptChange={onScriptChange}
            />
        </div>
    );
};

// Common styles
const commonButtonStyle = {
    padding: `${theme.spacing.sm} ${theme.spacing.lg}`,
    borderRadius: theme.borderRadius.md,
    border: 'none',
    cursor: 'pointer',
    fontWeight: 'bold',
    transition: 'all 0.2s ease',
    '&:hover': {
        opacity: 0.9,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\QuizSetup.tsx ---

import React from 'react';
import { Photo } from 'pexels';
import { ImageSelector } from './ImageSelector';
import { QuizItem } from '../data/quizData';

interface QuizSetupProps {
  onSave: (quizData: QuizItem[]) => void;
}

export const QuizSetup: React.FC<QuizSetupProps> = ({ onSave }) => {
  const [quizItems, setQuizItems] = React.useState<QuizItem[]>([]);
  const [currentItem, setCurrentItem] = React.useState(0);
  const [selectingFor, setSelectingFor] = React.useState<'left' | 'right' | null>(null);

  const handleImageSelect = (photo: Photo) => {
    if (!selectingFor) return;

    setQuizItems((prev) => {
      const updated = [...prev];
      updated[currentItem] = {
        ...updated[currentItem],
        [selectingFor === 'left' ? 'leftOption' : 'rightOption']: {
          ...updated[currentItem][selectingFor === 'left' ? 'leftOption' : 'rightOption'],
          image: photo.src.large,
          pexelsPhoto: photo,
        },
      };
      return updated;
    });

    setSelectingFor(null);
  };

  return (
    <div>
      {selectingFor && (
        <ImageSelector
          onSelect={handleImageSelect}
          searchQuery={
            selectingFor === 'left'
              ? quizItems[currentItem].leftOption.text
              : quizItems[currentItem].rightOption.text
          }
        />
      )}
      
      {/* Add your UI controls for managing quiz items here */}
    </div>
  );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\AudioComponentEditor.tsx ---

import React, { useRef, useState, useEffect } from 'react';
import { AudioComponent } from '../../types/script';
import { theme } from '../../styles/theme';

interface AudioEffect {
    name: string;
    url: string;
}

interface AudioComponentEditorProps {
    component: AudioComponent;
    onChange: (component: AudioComponent) => void;
    onDelete: () => void;
}

export const AudioComponentEditor: React.FC<AudioComponentEditorProps> = ({
    component,
    onChange,
    onDelete,
}) => {
    const fileInputRef = useRef<HTMLInputElement>(null);
    const [effects, setEffects] = useState<AudioEffect[]>([]);
    const [isLoading, setIsLoading] = useState(false);

    // Fetch available effects on mount
    useEffect(() => {
        fetchEffects();
    }, []);

    const fetchEffects = async () => {
        try {
            console.log('Fetching available audio effects...');
            const response = await fetch('http://localhost:3005/effects/dictionary');
            if (!response.ok) throw new Error('Failed to fetch effects');
            const data = await response.json();
            console.log('Available effects:', data);
            setEffects(Object.entries(data).map(([name, url]) => ({ name, url: url as string })));
        } catch (error) {
            console.error('Error fetching effects:', error);
        }
    };

    const handleStyleChange = (key: string, value: number | boolean | undefined) => {
        onChange({
            ...component,
            style: {
                ...component.style,
                [key]: value,
            },
        });
    };

    const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (!file) return;

        setIsLoading(true);
        try {
            console.log('Uploading audio file:', file.name);
            const formData = new FormData();
            formData.append('file', file);

            const response = await fetch('http://localhost:3005/effects/upload', {
                method: 'POST',
                body: formData,
            });

            if (!response.ok) throw new Error('Failed to upload audio file');
            const data = await response.json();
            console.log('Upload successful:', data);

            onChange({
                ...component,
                audioUrl: data.url,
            });

            // Refresh effects list after upload
            await fetchEffects();
        } catch (error) {
            console.error('Error uploading audio file:', error);
            alert('Failed to upload audio file. Please try again.');
        } finally {
            setIsLoading(false);
        }
    };

    const handleEffectSelect = (effect: AudioEffect) => {
        console.log('Selected effect:', effect);
        onChange({
            ...component,
            audioUrl: effect.url,
        });
    };

    const handleEffectDelete = async (effectName: string) => {
        try {
            console.log('Deleting effect:', effectName);
            const response = await fetch('http://localhost:3005/effects/delete', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ name: effectName }),
            });

            if (!response.ok) throw new Error('Failed to delete effect');
            console.log('Effect deleted successfully');
            
            // Refresh effects list after deletion
            await fetchEffects();
        } catch (error) {
            console.error('Error deleting effect:', error);
            alert('Failed to delete effect. Please try again.');
        }
    };

    return (
        <div style={{ display: 'flex', flexDirection: 'column', gap: theme.spacing.md }}>
            <div style={{
                padding: theme.spacing.md,
                backgroundColor: theme.colors.background.tertiary,
                borderRadius: theme.borderRadius.md,
            }}>
                <h3 style={{
                    margin: 0,
                    marginBottom: theme.spacing.sm,
                    fontSize: theme.fontSizes.lg,
                    color: theme.colors.text.primary,
                }}>Audio Settings</h3>

                {/* Audio Source Selection */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <label style={{
                        display: 'block',
                        marginBottom: theme.spacing.xs,
                        color: theme.colors.text.secondary,
                    }}>
                        Audio Source
                    </label>
                    <div style={{ display: 'flex', gap: theme.spacing.sm }}>
                        <button
                            onClick={() => fileInputRef.current?.click()}
                            style={{
                                padding: theme.spacing.sm,
                                backgroundColor: theme.colors.primary,
                                color: theme.colors.text.primary,
                                border: 'none',
                                borderRadius: theme.borderRadius.sm,
                                cursor: 'pointer',
                            }}
                            disabled={isLoading}
                        >
                            {isLoading ? 'Uploading...' : 'Upload Audio File'}
                        </button>
                        <input
                            ref={fileInputRef}
                            type="file"
                            accept="audio/*"
                            onChange={handleFileUpload}
                            style={{ display: 'none' }}
                        />
                    </div>

                    {/* Available Effects */}
                    {effects.length > 0 && (
                        <div style={{ 
                            marginTop: theme.spacing.md,
                            padding: theme.spacing.sm,
                            backgroundColor: theme.colors.background.secondary,
                            borderRadius: theme.borderRadius.sm,
                        }}>
                            <h4 style={{
                                margin: 0,
                                marginBottom: theme.spacing.sm,
                                color: theme.colors.text.primary,
                            }}>Available Effects</h4>
                            <div style={{ display: 'flex', flexDirection: 'column', gap: theme.spacing.xs }}>
                                {effects.map((effect) => (
                                    <div key={effect.name} style={{
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'space-between',
                                        padding: theme.spacing.xs,
                                        backgroundColor: component.audioUrl === effect.url ? theme.colors.primary : 'transparent',
                                        borderRadius: theme.borderRadius.sm,
                                        cursor: 'pointer',
                                    }}>
                                        <span
                                            onClick={() => handleEffectSelect(effect)}
                                            style={{
                                                flex: 1,
                                                color: theme.colors.text.primary,
                                            }}
                                        >
                                            {effect.name}
                                        </span>
                                        <button
                                            onClick={() => handleEffectDelete(effect.name)}
                                            style={{
                                                padding: `${theme.spacing.xs} ${theme.spacing.sm}`,
                                                backgroundColor: theme.colors.warning,
                                                color: theme.colors.text.primary,
                                                border: 'none',
                                                borderRadius: theme.borderRadius.sm,
                                                cursor: 'pointer',
                                                fontSize: '0.8em',
                                            }}
                                        >
                                            Delete
                                        </button>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}

                    {/* URL Input */}
                    <input
                        type="text"
                        value={component.audioUrl}
                        onChange={(e) => onChange({ ...component, audioUrl: e.target.value })}
                        placeholder="Or enter audio URL"
                        style={{
                            width: '100%',
                            marginTop: theme.spacing.sm,
                            padding: theme.spacing.sm,
                            borderRadius: theme.borderRadius.sm,
                            border: `1px solid ${theme.colors.border}`,
                            backgroundColor: theme.colors.background.secondary,
                            color: theme.colors.text.primary,
                        }}
                    />
                </div>

                {/* Volume Control */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <label style={{
                        display: 'block',
                        marginBottom: theme.spacing.xs,
                        color: theme.colors.text.secondary,
                    }}>
                        Volume
                    </label>
                    <input
                        type="range"
                        min="0"
                        max="1"
                        step="0.1"
                        value={component.style?.volume ?? 1}
                        onChange={(e) => handleStyleChange('volume', parseFloat(e.target.value))}
                        style={{ width: '100%' }}
                    />
                </div>

                {/* Start Time */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <label style={{
                        display: 'block',
                        marginBottom: theme.spacing.xs,
                        color: theme.colors.text.secondary,
                    }}>
                        Start Time (seconds)
                    </label>
                    <input
                        type="number"
                        min="0"
                        step="0.1"
                        value={component.style?.startTime ?? 0}
                        onChange={(e) => handleStyleChange('startTime', parseFloat(e.target.value))}
                        style={{
                            width: '100%',
                            padding: theme.spacing.sm,
                            borderRadius: theme.borderRadius.sm,
                            border: `1px solid ${theme.colors.border}`,
                            backgroundColor: theme.colors.background.secondary,
                            color: theme.colors.text.primary,
                        }}
                    />
                </div>

                {/* Duration */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <label style={{
                        display: 'block',
                        marginBottom: theme.spacing.xs,
                        color: theme.colors.text.secondary,
                    }}>
                        Duration (seconds, leave empty for full duration)
                    </label>
                    <input
                        type="number"
                        min="0"
                        step="0.1"
                        value={component.style?.duration ?? ''}
                        onChange={(e) => handleStyleChange('duration', e.target.value ? parseFloat(e.target.value) : undefined)}
                        style={{
                            width: '100%',
                            padding: theme.spacing.sm,
                            borderRadius: theme.borderRadius.sm,
                            border: `1px solid ${theme.colors.border}`,
                            backgroundColor: theme.colors.background.secondary,
                            color: theme.colors.text.primary,
                        }}
                    />
                </div>

                {/* Loop Toggle */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <label style={{
                        display: 'flex',
                        alignItems: 'center',
                        gap: theme.spacing.sm,
                        color: theme.colors.text.secondary,
                        cursor: 'pointer',
                    }}>
                        <input
                            type="checkbox"
                            checked={component.style?.loop ?? false}
                            onChange={(e) => handleStyleChange('loop', e.target.checked)}
                        />
                        Loop Audio
                    </label>
                </div>
            </div>

            {/* Delete Button */}
            <button
                onClick={onDelete}
                style={{
                    padding: theme.spacing.sm,
                    backgroundColor: theme.colors.warning,
                    color: theme.colors.text.primary,
                    border: 'none',
                    borderRadius: theme.borderRadius.sm,
                    cursor: 'pointer',
                    fontWeight: 'bold',
                }}
            >
                Delete
            </button>

            {/* Audio Preview */}
            {component.audioUrl && (
                <div style={{
                    marginTop: theme.spacing.md,
                    padding: theme.spacing.md,
                    backgroundColor: theme.colors.background.tertiary,
                    borderRadius: theme.borderRadius.md,
                }}>
                    <h4 style={{
                        margin: 0,
                        marginBottom: theme.spacing.sm,
                        color: theme.colors.text.primary,
                    }}>Preview</h4>
                    <audio
                        controls
                        src={component.audioUrl}
                        style={{ width: '100%' }}
                    />
                </div>
            )}
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\CaptionEditor.tsx ---

import React, { useState } from 'react';
import { WordTiming } from '../../types/script';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';

interface CaptionEditorProps {
    wordTimings: WordTiming[];
    onWordTimingsChange: (newTimings: WordTiming[]) => void;
    onClose: () => void;
}

export const CaptionEditor: React.FC<CaptionEditorProps> = ({
    wordTimings,
    onWordTimingsChange,
    onClose,
}) => {
    const [editingWord, setEditingWord] = useState<number | null>(null);
    const [localTimings, setLocalTimings] = useState<WordTiming[]>(wordTimings);

    const handleWordChange = (index: number, field: keyof WordTiming, value: string | number) => {
        const newTimings = [...localTimings];
        newTimings[index] = {
            ...newTimings[index],
            [field]: field === 'word' ? value : Number(value),
        };
        setLocalTimings(newTimings);
    };

    const handleSave = () => {
        onWordTimingsChange(localTimings);
        onClose();
    };

    return (
        <div style={{
            padding: theme.spacing.md,
            display: 'flex',
            flexDirection: 'column',
            gap: theme.spacing.md,
            maxHeight: '80vh',
            overflow: 'auto',
        }}>
            <div style={{
                display: 'flex',
                flexDirection: 'column',
                gap: theme.spacing.sm,
            }}>
                {localTimings.map((timing, index) => (
                    <div
                        key={index}
                        style={{
                            display: 'flex',
                            gap: theme.spacing.md,
                            alignItems: 'center',
                            padding: theme.spacing.sm,
                            backgroundColor: theme.colors.background.secondary,
                            borderRadius: theme.borderRadius.sm,
                        }}
                    >
                        <input
                            value={timing.word}
                            onChange={(e) => handleWordChange(index, 'word', e.target.value)}
                            style={{
                                flex: 2,
                                padding: '4px 8px',
                                borderRadius: theme.borderRadius.sm,
                                border: `1px solid ${theme.colors.border}`,
                                backgroundColor: theme.colors.background.tertiary,
                                color: theme.colors.text.primary,
                            }}
                        />
                        <div style={{ display: 'flex', gap: theme.spacing.sm, alignItems: 'center' }}>
                            <label>Start:</label>
                            <input
                                type="number"
                                step="0.1"
                                value={timing.start}
                                onChange={(e) => handleWordChange(index, 'start', e.target.value)}
                                style={{
                                    width: '80px',
                                    padding: '4px 8px',
                                    borderRadius: theme.borderRadius.sm,
                                    border: `1px solid ${theme.colors.border}`,
                                    backgroundColor: theme.colors.background.tertiary,
                                    color: theme.colors.text.primary,
                                }}
                            />
                        </div>
                        <div style={{ display: 'flex', gap: theme.spacing.sm, alignItems: 'center' }}>
                            <label>End:</label>
                            <input
                                type="number"
                                step="0.1"
                                value={timing.end}
                                onChange={(e) => handleWordChange(index, 'end', e.target.value)}
                                style={{
                                    width: '80px',
                                    padding: '4px 8px',
                                    borderRadius: theme.borderRadius.sm,
                                    border: `1px solid ${theme.colors.border}`,
                                    backgroundColor: theme.colors.background.tertiary,
                                    color: theme.colors.text.primary,
                                }}
                            />
                        </div>
                    </div>
                ))}
            </div>

            <div style={{
                display: 'flex',
                justifyContent: 'flex-end',
                gap: theme.spacing.md,
                marginTop: theme.spacing.md,
            }}>
                <button
                    onClick={onClose}
                    style={commonStyles.button.secondary}
                >
                    Cancel
                </button>
                <button
                    onClick={handleSave}
                    style={commonStyles.button.primary}
                >
                    Save Changes
                </button>
            </div>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\CaptionPositioningScreen.tsx ---

import React, { useState } from 'react';
import { CaptionStyleOptions } from '../../types/script';
import { theme } from '../../styles/theme';

interface CaptionPositioningScreenProps {
    style: CaptionStyleOptions;
    onChange: (style: CaptionStyleOptions) => void;
}

export const CaptionPositioningScreen: React.FC<CaptionPositioningScreenProps> = ({
    style,
    onChange,
}) => {
    const [isDragging, setIsDragging] = useState(false);
    const [startPos, setStartPos] = useState({ x: 0, y: 0 });

    const handleMouseDown = (e: React.MouseEvent) => {
        setIsDragging(true);
        setStartPos({
            x: e.clientX - (style.x || 0),
            y: e.clientY - (style.y || 0),
        });
    };

    const handleMouseMove = (e: React.MouseEvent) => {
        if (!isDragging) return;

        const newX = e.clientX - startPos.x;
        const newY = e.clientY - startPos.y;

        onChange({
            ...style,
            x: newX,
            y: newY,
        });
    };

    const handleMouseUp = () => {
        setIsDragging(false);
    };

    return (
        <div style={styles.container}>
            <div style={styles.header}>
                <h3>Caption Positioning</h3>
                <p>Drag to position the captions or use the controls below</p>
            </div>

            <div 
                style={styles.previewArea}
                onMouseMove={handleMouseMove}
                onMouseUp={handleMouseUp}
                onMouseLeave={handleMouseUp}
            >
                <div
                    style={{
                        ...styles.captionPreview,
                        transform: `translate(${style.x || 0}px, ${style.y || 0}px) scale(${style.scale || 1}) rotate(${style.rotation || 0}deg)`,
                        cursor: isDragging ? 'grabbing' : 'grab',
                        fontSize: style.fontSize,
                        color: style.color,
                        backgroundColor: style.backgroundColor,
                        fontFamily: style.fontFamily,
                        fontWeight: style.fontWeight,
                        fontStyle: style.fontStyle,
                        textDecoration: style.textDecoration,
                        padding: style.padding,
                        margin: style.margin,
                        borderRadius: style.borderRadius,
                        border: style.border,
                        boxShadow: style.boxShadow,
                        opacity: style.opacity,
                    }}
                    onMouseDown={handleMouseDown}
                >
                    Sample Caption Text
                </div>
            </div>

            <div style={styles.controls}>
                <div style={styles.controlGroup}>
                    <label>Position X:</label>
                    <input
                        type="number"
                        value={style.x || 0}
                        onChange={(e) => onChange({ ...style, x: Number(e.target.value) })}
                    />
                </div>

                <div style={styles.controlGroup}>
                    <label>Position Y:</label>
                    <input
                        type="number"
                        value={style.y || 0}
                        onChange={(e) => onChange({ ...style, y: Number(e.target.value) })}
                    />
                </div>

                <div style={styles.controlGroup}>
                    <label>Scale:</label>
                    <input
                        type="range"
                        min="0.1"
                        max="2"
                        step="0.1"
                        value={style.scale || 1}
                        onChange={(e) => onChange({ ...style, scale: Number(e.target.value) })}
                    />
                </div>

                <div style={styles.controlGroup}>
                    <label>Rotation:</label>
                    <input
                        type="range"
                        min="-180"
                        max="180"
                        value={style.rotation || 0}
                        onChange={(e) => onChange({ ...style, rotation: Number(e.target.value) })}
                    />
                </div>
            </div>
        </div>
    );
};

const styles = {
    container: {
        padding: theme.spacing.md,
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.md,
    },
    header: {
        textAlign: 'center' as const,
    },
    previewArea: {
        width: '100%',
        height: '300px',
        backgroundColor: '#f0f0f0',
        position: 'relative' as const,
        overflow: 'hidden',
        border: '1px solid #ccc',
        borderRadius: theme.borderRadius.md,
    },
    captionPreview: {
        position: 'absolute' as const,
        userSelect: 'none' as const,
        padding: '10px 20px',
        borderRadius: '5px',
        transition: 'transform 0.1s ease-out',
    },
    controls: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.sm,
    },
    controlGroup: {
        display: 'flex',
        alignItems: 'center',
        gap: theme.spacing.sm,
        '& label': {
            minWidth: '100px',
        },
        '& input': {
            flex: 1,
            padding: theme.spacing.sm,
            borderRadius: theme.borderRadius.sm,
            border: '1px solid #ccc',
        },
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\CaptionTimeline.tsx ---

import React, { useState, useRef, useEffect } from 'react';
import { CaptionTrack, Script, VoiceComponent, WordTiming } from '../../types/script';
import { theme } from '../../styles/theme';
import { Modal } from '../common/Modal';
import { CaptionEditor } from './CaptionEditor';

interface CaptionTimelineProps {
    script: Script;
    onScriptChange: (script: Script) => void;
}

const TRACK_HEIGHT = 40;
const PIXELS_PER_SECOND = 100;
const FRAMES_PER_SECOND = 30;

export const CaptionTimeline: React.FC<CaptionTimelineProps> = ({
    script,
    onScriptChange,
}) => {
    const [draggingId, setDraggingId] = useState<string | null>(null);
    const [dragOffset, setDragOffset] = useState(0);
    const [editingCaption, setEditingCaption] = useState<string | null>(null);
    const [editingWordTimings, setEditingWordTimings] = useState<{id: string, isTrack: boolean} | null>(null);
    const containerRef = useRef<HTMLDivElement>(null);

    // Calculate timeline width based on all components and caption tracks
    const timelineWidth = Math.max(
        ...script.components
            .filter(c => c.type === 'voice')
            .map(c => {
                const start = c.startFrame || 0;
                const duration = c.durationInFrames || 150;
                return (start + duration) / FRAMES_PER_SECOND * PIXELS_PER_SECOND;
            }),
        ...(script.captionTracks || []).map(track => {
            const start = track.startFrame;
            const lastWord = track.wordTimings[track.wordTimings.length - 1];
            const duration = lastWord ? (lastWord.end * FRAMES_PER_SECOND) : 150;
            return (start + duration) / FRAMES_PER_SECOND * PIXELS_PER_SECOND;
        }),
        PIXELS_PER_SECOND * 10 // Minimum width of 10 seconds
    );

    const handleUnlink = (componentId: string) => {
        // Find the voice component
        const component = script.components.find(
            c => c.id === componentId && c.type === 'voice'
        ) as VoiceComponent | undefined;

        if (!component?.wordTimings) return;

        // Create a new caption track
        const newTrack: CaptionTrack = {
            id: `caption_${Date.now()}`,
            originalComponentId: componentId,
            isLinked: false,
            wordTimings: component.wordTimings,
            startFrame: component.startFrame || 0,
            text: component.text,
        };

        // Add to caption tracks
        onScriptChange({
            ...script,
            captionTracks: [...(script.captionTracks || []), newTrack],
        });
    };

    const handleRelink = (trackId: string) => {
        const track = script.captionTracks?.find(t => t.id === trackId);
        if (!track?.originalComponentId) return;

        // Update the original component with the track's timings
        const updatedComponents = script.components.map(comp => {
            if (comp.id === track.originalComponentId && comp.type === 'voice') {
                return {
                    ...comp,
                    wordTimings: track.wordTimings,
                    startFrame: track.startFrame,
                };
            }
            return comp;
        });

        // Remove this track from caption tracks
        onScriptChange({
            ...script,
            components: updatedComponents,
            captionTracks: script.captionTracks?.filter(t => t.id !== trackId) || [],
        });
    };

    const handleDragStart = (e: React.DragEvent, track: CaptionTrack) => {
        const rect = e.currentTarget.getBoundingClientRect();
        const offsetX = e.clientX - rect.left;
        setDragOffset(Math.round((offsetX / PIXELS_PER_SECOND) * FRAMES_PER_SECOND));
        setDraggingId(track.id);
    };

    const handleDrag = (e: React.DragEvent) => {
        if (!draggingId) return;

        const rect = e.currentTarget.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const newStartFrame = Math.max(0, Math.round((x / PIXELS_PER_SECOND) * FRAMES_PER_SECOND) - dragOffset);

        const updatedTracks = script.captionTracks?.map(track => 
            track.id === draggingId ? { ...track, startFrame: newStartFrame } : track
        );

        onScriptChange({
            ...script,
            captionTracks: updatedTracks || [],
        });
    };

    const handleEditText = (trackId: string, newText: string) => {
        const updatedTracks = script.captionTracks?.map(track => 
            track.id === trackId ? { ...track, text: newText } : track
        );

        onScriptChange({
            ...script,
            captionTracks: updatedTracks || [],
        });
    };

    const handleWordTimingsChange = (id: string, isTrack: boolean, newTimings: WordTiming[]) => {
        if (isTrack) {
            // Update caption track
            const updatedTracks = script.captionTracks?.map(track => 
                track.id === id ? { ...track, wordTimings: newTimings } : track
            );
            onScriptChange({
                ...script,
                captionTracks: updatedTracks || [],
            });
        } else {
            // Update voice component
            const updatedComponents = script.components.map(comp => 
                comp.id === id && comp.type === 'voice'
                    ? { ...comp, wordTimings: newTimings }
                    : comp
            );
            onScriptChange({
                ...script,
                components: updatedComponents,
            });
        }
    };

    return (
        <>
            <div style={{
                backgroundColor: theme.colors.background.secondary,
                padding: theme.spacing.lg,
                borderRadius: theme.borderRadius.md,
                marginTop: theme.spacing.xl,
                borderTop: `2px solid ${theme.colors.border}`,
            }}>
                <div style={{
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    marginBottom: theme.spacing.lg,
                }}>
                    <h3 style={{ 
                        color: theme.colors.text.primary, 
                        margin: 0,
                        fontSize: '16px',
                        fontWeight: 'bold',
                    }}>
                        Captions Timeline
                    </h3>
                </div>

                <div 
                    ref={containerRef}
                    style={{
                        backgroundColor: theme.colors.background.tertiary,
                        borderRadius: theme.borderRadius.sm,
                        padding: theme.spacing.sm,
                    }}
                >
                    <div style={{
                        width: `${timelineWidth}px`,
                        position: 'relative',
                    }}>
                        {/* Time markers */}
                        <div style={{
                            height: '30px',
                            borderBottom: `1px solid ${theme.colors.border}`,
                            position: 'relative',
                            marginBottom: theme.spacing.sm,
                        }}>
                            {Array.from({ length: Math.ceil(timelineWidth / PIXELS_PER_SECOND) }).map((_, i) => (
                                <div
                                    key={i}
                                    style={{
                                        position: 'absolute',
                                        left: `${i * PIXELS_PER_SECOND}px`,
                                        width: '1px',
                                        height: '15px',
                                        backgroundColor: theme.colors.border,
                                    }}
                                >
                                    <span style={{
                                        position: 'absolute',
                                        top: '-20px',
                                        left: '2px',
                                        fontSize: '12px',
                                        color: theme.colors.text.secondary,
                                        fontFamily: 'monospace',
                                    }}>
                                        {i}s
                                    </span>
                                </div>
                            ))}
                        </div>

                        {/* Empty tracks */}
                        {Array.from({ length: 3 }).map((_, index) => (
                            <div
                                key={`empty-track-${index}`}
                                style={{
                                    height: TRACK_HEIGHT,
                                    borderBottom: `1px solid ${theme.colors.border}`,
                                    position: 'relative',
                                    backgroundColor: index % 2 === 0 ? theme.colors.background.secondary : 'transparent',
                                    marginBottom: theme.spacing.sm,
                                }}
                            />
                        ))}

                        {/* Voice components with captions */}
                        {script.components
                            .filter(c => c.type === 'voice' && (c as VoiceComponent).wordTimings)
                            .map((component) => {
                                const voiceComponent = component as VoiceComponent;
                                const isUnlinked = script.captionTracks?.some(
                                    t => t.originalComponentId === component.id
                                );

                                return (
                                    <div
                                        key={component.id}
                                        style={{
                                            height: TRACK_HEIGHT,
                                            borderBottom: `1px solid ${theme.colors.border}`,
                                            position: 'relative',
                                            backgroundColor: theme.colors.background.secondary,
                                            marginBottom: theme.spacing.sm,
                                        }}
                                    >
                                        <div style={{
                                            position: 'absolute',
                                            left: `${((component.startFrame || 0) / FRAMES_PER_SECOND) * PIXELS_PER_SECOND}px`,
                                            height: TRACK_HEIGHT,
                                            backgroundColor: isUnlinked ? theme.colors.background.tertiary : theme.colors.primary,
                                            padding: '0 8px',
                                            display: 'flex',
                                            alignItems: 'center',
                                            borderRadius: theme.borderRadius.sm,
                                            cursor: 'pointer',
                                            whiteSpace: 'nowrap',
                                            overflow: 'hidden',
                                            textOverflow: 'ellipsis',
                                            minWidth: '100px',
                                        }}>
                                            <span style={{ marginRight: '8px' }}>
                                                {voiceComponent.text.substring(0, 30)}...
                                            </span>
                                            {!isUnlinked && (
                                                <button
                                                    onClick={() => handleUnlink(component.id)}
                                                    style={{
                                                        padding: '4px 8px',
                                                        backgroundColor: theme.colors.secondary,
                                                        border: 'none',
                                                        borderRadius: theme.borderRadius.sm,
                                                        cursor: 'pointer',
                                                        color: 'white',
                                                        whiteSpace: 'nowrap',
                                                    }}
                                                >
                                                    Unlink
                                                </button>
                                            )}
                                        </div>
                                    </div>
                                );
                            })}

                        {/* Caption tracks */}
                        {script.captionTracks?.map((track, index) => (
                            <div
                                key={track.id}
                                style={{
                                    height: TRACK_HEIGHT,
                                    borderBottom: `1px solid ${theme.colors.border}`,
                                    position: 'relative',
                                    backgroundColor: index % 2 === 0 ? theme.colors.background.secondary : 'transparent',
                                    marginBottom: theme.spacing.sm,
                                }}
                                onDragOver={(e) => e.preventDefault()}
                                onDrop={(e) => {
                                    e.preventDefault();
                                    setDraggingId(null);
                                }}
                            >
                                <div
                                    draggable
                                    onDragStart={(e) => handleDragStart(e, track)}
                                    onDrag={handleDrag}
                                    onDragEnd={() => setDraggingId(null)}
                                    style={{
                                        position: 'absolute',
                                        left: `${(track.startFrame / FRAMES_PER_SECOND) * PIXELS_PER_SECOND}px`,
                                        height: TRACK_HEIGHT,
                                        backgroundColor: theme.colors.secondary,
                                        padding: '0 8px',
                                        display: 'flex',
                                        alignItems: 'center',
                                        borderRadius: theme.borderRadius.sm,
                                        cursor: 'grab',
                                    }}
                                >
                                    {editingCaption === track.id ? (
                                        <input
                                            value={track.text}
                                            onChange={(e) => handleEditText(track.id, e.target.value)}
                                            onBlur={() => setEditingCaption(null)}
                                            autoFocus
                                            style={{
                                                width: '200px',
                                                padding: '4px',
                                                border: 'none',
                                                borderRadius: theme.borderRadius.sm,
                                            }}
                                        />
                                    ) : (
                                        <>
                                            <span
                                                onClick={() => setEditingCaption(track.id)}
                                                style={{ marginRight: '8px', cursor: 'text' }}
                                            >
                                                {track.text.substring(0, 20)}...
                                            </span>
                                            <button
                                                onClick={() => handleRelink(track.id)}
                                                style={{
                                                    padding: '4px 8px',
                                                    backgroundColor: theme.colors.primary,
                                                    border: 'none',
                                                    borderRadius: theme.borderRadius.sm,
                                                    cursor: 'pointer',
                                                    color: 'white',
                                                }}
                                            >
                                                Relink
                                            </button>
                                        </>
                                    )}
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            </div>

            {/* Caption Editor Modal */}
            {editingWordTimings && (
                <Modal
                    isOpen={true}
                    onClose={() => setEditingWordTimings(null)}
                    title="Edit Captions"
                >
                    <CaptionEditor
                        wordTimings={
                            editingWordTimings.isTrack
                                ? script.captionTracks?.find(t => t.id === editingWordTimings.id)?.wordTimings || []
                                : (script.components.find(c => c.id === editingWordTimings.id) as VoiceComponent)?.wordTimings || []
                        }
                        onWordTimingsChange={(newTimings) => 
                            handleWordTimingsChange(editingWordTimings.id, editingWordTimings.isTrack, newTimings)
                        }
                        onClose={() => setEditingWordTimings(null)}
                    />
                </Modal>
            )}
        </>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\ComparisonComponentEditor.tsx ---

import React from 'react';
import { ComparisonComponent, AnimationOptions } from '../../types/script';
import { ImageSelector } from '../ImageSelector';
import { theme } from '../../styles/theme';

interface ComparisonComponentEditorProps {
    component: ComparisonComponent;
    onChange: (updated: ComparisonComponent) => void;
}

export const ComparisonComponentEditor: React.FC<ComparisonComponentEditorProps> = ({
    component,
    onChange,
}) => {
    const handleStyleChange = (updated: Partial<ComparisonComponent['style']>) => {
        onChange({
            ...component,
            style: {
                ...component.style,
                ...updated
            }
        });
    };

    const handleAnimationChange = (updates: Partial<AnimationOptions>) => {
        const currentAnimation = component.style?.animation || {
            type: 'none',
            direction: 'in',
            easing: 'easeInOut',
            duration: 30,
            delay: 0,
            stagger: 0
        };
        handleStyleChange({
            animation: {
                ...currentAnimation,
                ...updates,
            }
        });
    };

    const handleBorderChange = (updates: Partial<NonNullable<ComparisonComponent['style']>['imageBorder']>) => {
        const currentBorder = component.style?.imageBorder || { enabled: false, color: '#000000', width: 1 };
        handleStyleChange({
            imageBorder: {
                ...currentBorder,
                ...updates,
            }
        });
    };

    const handleShadowChange = (updates: Partial<NonNullable<ComparisonComponent['style']>['imageDropShadow']>) => {
        const currentShadow = component.style?.imageDropShadow || { enabled: false, color: '#000000', blur: 10, spread: 0, x: 0, y: 4 };
        handleStyleChange({
            imageDropShadow: {
                ...currentShadow,
                ...updates,
            }
        });
    };

    const handlePositionChange = (updates: Partial<{ x: number; y: number }>) => {
        const currentPosition = component.style?.imagePosition || { x: 0, y: 0 };
        handleStyleChange({
            imagePosition: {
                ...currentPosition,
                ...updates
            }
        });
    };

    return (
        <div style={styles.container}>
            {/* Question */}
            <div style={styles.section}>
                <label style={styles.label}>
                    Question:
                </label>
                <input
                    type="text"
                    value={component.question}
                    onChange={(e) => {
                        onChange({
                            ...component,
                            question: e.target.value || '',
                        });
                    }}
                    style={styles.input}
                    placeholder="Enter your question..."
                />
            </div>

            {/* Settings */}
            <div style={styles.section}>
                <h4 style={styles.sectionTitle}>Settings</h4>
                <div style={styles.settingsGrid}>
                    <div>
                        <label style={styles.label}>Orientation:</label>
                        <select
                            value={component.orientation || 'horizontal'}
                            onChange={(e) => {
                                onChange({
                                    ...component,
                                    orientation: e.target.value as 'horizontal' | 'vertical'
                                });
                            }}
                            style={styles.input}
                        >
                            <option value="horizontal">Side by Side</option>
                            <option value="vertical">Top and Bottom</option>
                        </select>
                    </div>

                    <div>
                        <label style={styles.label}>Duration (frames):</label>
                        <input
                            type="number"
                            min="1"
                            value={component.durationInFrames || 150}
                            onChange={(e) => {
                                onChange({
                                    ...component,
                                    durationInFrames: parseInt(e.target.value)
                                });
                            }}
                            style={styles.input}
                        />
                    </div>
                </div>

                <div style={{ marginTop: theme.spacing.md }}>
                    <label style={{
                        ...styles.label,
                        display: 'flex',
                        alignItems: 'center',
                        gap: theme.spacing.sm,
                    }}>
                        <input
                            type="checkbox"
                            checked={component.style?.showText !== false}
                            onChange={(e) => {
                                onChange({
                                    ...component,
                                    style: {
                                        ...component.style,
                                        showText: e.target.checked
                                    }
                                });
                            }}
                        />
                        Show Text Labels
                    </label>
                </div>

                {component.style?.showText !== false && (
                    <div style={{ marginTop: theme.spacing.md }}>
                        <div style={styles.settingsGrid}>
                            <div>
                                <label style={styles.label}>Font Size:</label>
                                <input
                                    type="number"
                                    value={component.style?.fontSize || 32}
                                    onChange={(e) => {
                                        onChange({
                                            ...component,
                                            style: {
                                                ...component.style,
                                                fontSize: parseInt(e.target.value)
                                            }
                                        });
                                    }}
                                    style={styles.input}
                                />
                            </div>

                            <div>
                                <label style={styles.label}>Text Color:</label>
                                <input
                                    type="color"
                                    value={component.style?.textColor || '#ffffff'}
                                    onChange={(e) => {
                                        onChange({
                                            ...component,
                                            style: {
                                                ...component.style,
                                                textColor: e.target.value
                                            }
                                        });
                                    }}
                                    style={styles.input}
                                />
                            </div>
                        </div>
                    </div>
                )}
            </div>

            {/* Image Style Settings */}
            <div style={{ marginTop: theme.spacing.md }}>
                <h4 style={styles.sectionTitle}>Image Styles</h4>
                
                {/* Border Settings */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <div style={styles.row}>
                        <input
                            type="checkbox"
                            checked={component.style?.imageBorder?.enabled ?? false}
                            onChange={(e) => handleBorderChange({ enabled: e.target.checked })}
                            style={styles.checkbox}
                        />
                        <label style={styles.label}>Enable Border</label>
                    </div>
                    {component.style?.imageBorder?.enabled && (
                        <div style={styles.row}>
                            <input
                                type="color"
                                value={component.style.imageBorder.color ?? '#000000'}
                                onChange={(e) => handleBorderChange({ color: e.target.value })}
                                style={styles.input}
                            />
                            <input
                                type="number"
                                value={component.style.imageBorder.width ?? 1}
                                onChange={(e) => handleBorderChange({ width: Number(e.target.value) })}
                                placeholder="Width"
                                min="1"
                                max="20"
                                style={styles.input}
                            />
                        </div>
                    )}
                </div>

                {/* Drop Shadow Settings */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <div style={styles.row}>
                        <input
                            type="checkbox"
                            checked={component.style?.imageDropShadow?.enabled ?? false}
                            onChange={(e) => handleShadowChange({ enabled: e.target.checked })}
                            style={styles.checkbox}
                        />
                        <label style={styles.label}>Enable Drop Shadow</label>
                    </div>
                    {component.style?.imageDropShadow?.enabled && (
                        <>
                            <div style={styles.row}>
                                <input
                                    type="color"
                                    value={component.style.imageDropShadow.color ?? '#000000'}
                                    onChange={(e) => handleShadowChange({ color: e.target.value })}
                                    style={styles.input}
                                />
                                <input
                                    type="number"
                                    value={component.style.imageDropShadow.blur ?? 10}
                                    onChange={(e) => handleShadowChange({ blur: Number(e.target.value) })}
                                    placeholder="Blur"
                                    min="0"
                                    max="50"
                                    style={styles.input}
                                />
                            </div>
                            <div style={styles.row}>
                                <input
                                    type="number"
                                    value={component.style.imageDropShadow.x ?? 0}
                                    onChange={(e) => handleShadowChange({ x: Number(e.target.value) })}
                                    placeholder="X Offset"
                                    style={styles.input}
                                />
                                <input
                                    type="number"
                                    value={component.style.imageDropShadow.y ?? 0}
                                    onChange={(e) => handleShadowChange({ y: Number(e.target.value) })}
                                    placeholder="Y Offset"
                                    style={styles.input}
                                />
                                <input
                                    type="number"
                                    value={component.style.imageDropShadow.spread ?? 0}
                                    onChange={(e) => handleShadowChange({ spread: Number(e.target.value) })}
                                    placeholder="Spread"
                                    style={styles.input}
                                />
                            </div>
                        </>
                    )}
                </div>

                {/* Layout Settings */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <h4 style={styles.sectionTitle}>Layout</h4>
                    <div style={styles.settingsGrid}>
                        <div>
                            <label style={styles.label}>Image Size (%):</label>
                            <input
                                type="number"
                                min="10"
                                max="500"
                                value={component.style?.imageSize || 100}
                                onChange={(e) => {
                                    const size = Math.max(10, Math.min(500, parseInt(e.target.value) || 100));
                                    handleStyleChange({
                                        imageSize: size
                                    });
                                }}
                                style={styles.input}
                            />
                        </div>
                        <div>
                            <label style={styles.label}>Gap Between Images (px):</label>
                            <input
                                type="number"
                                min="0"
                                max="200"
                                value={component.style?.imageGap || 20}
                                onChange={(e) => {
                                    const gap = Math.max(0, Math.min(200, parseInt(e.target.value) || 20));
                                    handleStyleChange({
                                        imageGap: gap
                                    });
                                }}
                                style={styles.input}
                            />
                        </div>
                    </div>

                    <div style={styles.row}>
                        <input
                            type="checkbox"
                            checked={component.style?.forceSameSize ?? true}
                            onChange={(e) => handleStyleChange({ forceSameSize: e.target.checked })}
                            style={styles.checkbox}
                        />
                        <label style={styles.label}>Force Images to Same Size</label>
                    </div>

                    <div style={styles.settingsGrid}>
                        <div>
                            <label style={styles.label}>Horizontal Position (%):</label>
                            <input
                                type="range"
                                min="-100"
                                max="100"
                                value={component.style?.imagePosition?.x || 0}
                                onChange={(e) => {
                                    handlePositionChange({ x: parseInt(e.target.value) });
                                }}
                                style={styles.input}
                            />
                        </div>
                        <div>
                            <label style={styles.label}>Vertical Position (%):</label>
                            <input
                                type="range"
                                min="-100"
                                max="100"
                                value={component.style?.imagePosition?.y || 0}
                                onChange={(e) => {
                                    handlePositionChange({ y: parseInt(e.target.value) });
                                }}
                                style={styles.input}
                            />
                        </div>
                    </div>
                </div>
            </div>

            {/* Animation Controls */}
            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Animation Settings</h3>
                <div style={styles.row}>
                    <select
                        value={component.style?.animation?.type ?? 'none'}
                        onChange={(e) => handleAnimationChange({ type: e.target.value as AnimationOptions['type'] })}
                        style={styles.input}
                    >
                        <option value="none">None</option>
                        <option value="fade">Fade</option>
                        <option value="scale">Scale</option>
                        <option value="rotate">Rotate</option>
                        <option value="slide">Slide</option>
                    </select>
                </div>
                {component.style?.animation?.type !== 'none' && (
                    <>
                        <div style={styles.row}>
                            <select
                                value={component.style?.animation?.direction ?? 'in'}
                                onChange={(e) => handleAnimationChange({ direction: e.target.value as AnimationOptions['direction'] })}
                                style={styles.input}
                            >
                                <option value="in">In</option>
                                <option value="out">Out</option>
                            </select>
                            <select
                                value={component.style?.animation?.easing ?? 'easeInOut'}
                                onChange={(e) => handleAnimationChange({ easing: e.target.value as AnimationOptions['easing'] })}
                                style={styles.input}
                            >
                                <option value="linear">Linear</option>
                                <option value="easeIn">Ease In</option>
                                <option value="easeOut">Ease Out</option>
                                <option value="easeInOut">Ease In Out</option>
                            </select>
                        </div>
                        <div style={styles.row}>
                            <input
                                type="number"
                                value={component.style?.animation?.duration ?? 30}
                                onChange={(e) => handleAnimationChange({ duration: Number(e.target.value) })}
                                placeholder="Duration (frames)"
                                min="1"
                                style={styles.input}
                            />
                            <input
                                type="number"
                                value={component.style?.animation?.delay ?? 0}
                                onChange={(e) => handleAnimationChange({ delay: Number(e.target.value) })}
                                placeholder="Delay (frames)"
                                min="0"
                                style={styles.input}
                            />
                            <input
                                type="number"
                                value={component.style?.animation?.stagger ?? 0}
                                onChange={(e) => handleAnimationChange({ stagger: Number(e.target.value) })}
                                placeholder="Stagger (frames)"
                                min="0"
                                style={styles.input}
                            />
                        </div>
                    </>
                )}
            </div>

            {/* Options */}
            <div style={{
                ...styles.optionsGrid,
                gridTemplateColumns: component.orientation === 'horizontal' ? '1fr 1fr' : '1fr',
            }}>
                {/* First Option */}
                <div style={styles.optionSection}>
                    <h4 style={styles.sectionTitle}>
                        {component.orientation === 'horizontal' ? 'Left Option' : 'Top Option'}
                    </h4>
                    <input
                        type="text"
                        value={component.leftOption.text}
                        onChange={(e) => {
                            onChange({
                                ...component,
                                leftOption: {
                                    ...component.leftOption,
                                    text: e.target.value || '',
                                }
                            });
                        }}
                        style={styles.input}
                        placeholder="Enter text..."
                    />
                    <ImageSelector
                        onSelect={(url) => {
                            onChange({
                                ...component,
                                leftOption: {
                                    ...component.leftOption,
                                    imageUrl: url,
                                }
                            });
                        }}
                        searchTerm={component.leftOption.text || 'image'}
                    />
                </div>

                {/* Second Option */}
                <div style={styles.optionSection}>
                    <h4 style={styles.sectionTitle}>
                        {component.orientation === 'horizontal' ? 'Right Option' : 'Bottom Option'}
                    </h4>
                    <input
                        type="text"
                        value={component.rightOption.text}
                        onChange={(e) => {
                            onChange({
                                ...component,
                                rightOption: {
                                    ...component.rightOption,
                                    text: e.target.value || '',
                                }
                            });
                        }}
                        style={styles.input}
                        placeholder="Enter text..."
                    />
                    <ImageSelector
                        onSelect={(url) => {
                            onChange({
                                ...component,
                                rightOption: {
                                    ...component.rightOption,
                                    imageUrl: url,
                                }
                            });
                        }}
                        searchTerm={component.rightOption.text || 'image'}
                    />
                </div>
            </div>
        </div>
    );
};

const styles = {
    container: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.md,
        height: '100%',
        backgroundColor: 'transparent',
    },
    section: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.sm,
        padding: theme.spacing.md,
        backgroundColor: theme.colors.background.secondary,
        borderRadius: theme.borderRadius.md,
        border: `1px solid ${theme.colors.border}`,
    },
    sectionTitle: {
        margin: '0 0 8px 0',
        color: theme.colors.text.primary,
        fontSize: '1rem',
        fontWeight: 600,
    },
    label: {
        fontSize: '0.9rem',
        fontWeight: 500,
        color: theme.colors.text.primary,
    },
    input: {
        padding: '0.5rem',
        borderRadius: theme.borderRadius.sm,
        border: `1px solid ${theme.colors.border}`,
        backgroundColor: theme.colors.background.tertiary,
        color: theme.colors.text.primary,
        width: '100%',
        minWidth: 0,
    },
    settingsGrid: {
        display: 'grid',
        gridTemplateColumns: '1fr 1fr',
        gap: theme.spacing.sm,
    },
    optionsGrid: {
        display: 'grid',
        gap: theme.spacing.md,
    },
    optionSection: {
        backgroundColor: theme.colors.background.secondary,
        padding: theme.spacing.md,
        borderRadius: theme.borderRadius.md,
        border: `1px solid ${theme.colors.border}`,
    },
    row: {
        display: 'flex',
        gap: theme.spacing.sm,
        alignItems: 'center',
        flexWrap: 'wrap' as const,
    },
    preview: {
        width: '100%',
        maxHeight: '200px',
        objectFit: 'contain' as const,
        backgroundColor: theme.colors.background.tertiary,
        borderRadius: theme.borderRadius.md,
        marginBottom: theme.spacing.sm,
    },
    checkbox: {
        margin: 0,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\ComponentEditor.tsx ---

import React, { useState } from 'react';
import { ScriptComponent, TextStyle, TextComponent, TitleComponent, CountdownComponent } from '../../types/script';
import { TextComponentEditor } from './TextComponentEditor';
import { TitleComponentEditor } from './TitleComponentEditor';
import { ComparisonComponentEditor } from './ComparisonComponentEditor';
import { CountdownComponentEditor } from './CountdownComponentEditor';
import { VoiceComponentEditor } from './VoiceComponentEditor';
import { PositioningScreen } from './PositioningScreen';
import { theme } from '../../styles/theme';
import { VideoComponentEditor } from './VideoComponentEditor';
import { AudioComponentEditor } from './AudioComponentEditor';

export interface ComponentEditorProps {
    component: ScriptComponent;
    onChange: (updated: ScriptComponent) => void;
    onDelete: () => void;
    onEditPosition?: (componentId: string | null) => void;
}

const defaultStyle: TextStyle = {
    fontSize: 40,
    fontFamily: 'Arial',
    color: '#ffffff',
    textAlign: 'center',
};

const hasStyle = (component: ScriptComponent): component is TextComponent | TitleComponent | CountdownComponent => {
    return ['text', 'title', 'countdown'].includes(component.type);
};

export const ComponentEditor: React.FC<ComponentEditorProps> = ({
    component,
    onChange,
    onDelete,
    onEditPosition,
}) => {
    const [showPositioning, setShowPositioning] = useState(false);

    // Ensure component has a style property if it's a type that requires it
    const componentWithStyle = React.useMemo(() => {
        if (hasStyle(component) && !component.style) {
            return {
                ...component,
                style: defaultStyle,
            };
        }
        return component;
    }, [component]);

    const handlePositionChange = (position: { x: number; y: number }) => {
        if (hasStyle(componentWithStyle)) {
            onChange({
                ...componentWithStyle,
                style: {
                    ...componentWithStyle.style,
                    position: {
                        x: position.x,
                        y: position.y,
                        width: componentWithStyle.style.position?.width || 300,
                    },
                },
            });
        }
    };

    const handleDelete = () => {
        onDelete();
    };

    return (
        <div style={{
            display: 'flex',
            flexDirection: 'column',
            gap: theme.spacing.md,
        }}>
            {/* Header */}
            <div style={{
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                padding: theme.spacing.sm,
                backgroundColor: theme.colors.background.tertiary,
                borderRadius: theme.borderRadius.sm,
            }}>
                <h3 style={{
                    margin: 0,
                    fontSize: theme.fontSizes.lg,
                    color: theme.colors.text.primary,
                }}>
                    {componentWithStyle.type.charAt(0).toUpperCase() + componentWithStyle.type.slice(1)} Settings
                </h3>
                <button
                    onClick={handleDelete}
                    style={{
                        backgroundColor: theme.colors.error,
                        color: 'white',
                        border: 'none',
                        padding: `${theme.spacing.xs} ${theme.spacing.sm}`,
                        borderRadius: theme.borderRadius.sm,
                        cursor: 'pointer',
                        fontSize: theme.fontSizes.sm,
                    }}
                >
                    Delete
                </button>
            </div>

            {/* Component-specific editors */}
            <div style={{
                padding: theme.spacing.sm,
                backgroundColor: theme.colors.background.tertiary,
                borderRadius: theme.borderRadius.sm,
            }}>
                {(() => {
                    switch (componentWithStyle.type) {
                        case 'text':
                            return <TextComponentEditor component={componentWithStyle as TextComponent} onChange={onChange} />;
                        case 'title':
                            return <TitleComponentEditor component={componentWithStyle as TitleComponent} onChange={onChange} />;
                        case 'comparison':
                            return <ComparisonComponentEditor component={componentWithStyle} onChange={onChange} />;
                        case 'countdown':
                            return <CountdownComponentEditor component={componentWithStyle as CountdownComponent} onChange={onChange} />;
                        case 'voice':
                            return <VoiceComponentEditor component={componentWithStyle} onChange={onChange} />;
                        case 'video':
                            return <VideoComponentEditor component={componentWithStyle} onChange={onChange} />;
                        case 'audio':
                            return <AudioComponentEditor component={componentWithStyle} onChange={onChange} onDelete={onDelete} />;
                        default:
                            return <div>Unknown component type: {componentWithStyle.type}</div>;
                    }
                })()}
            </div>

            {/* Position Toggle */}
            {hasStyle(componentWithStyle) && (
                <div style={{
                    padding: theme.spacing.sm,
                    backgroundColor: theme.colors.background.tertiary,
                    borderRadius: theme.borderRadius.sm,
                }}>
                    <button
                        onClick={() => setShowPositioning(!showPositioning)}
                        style={{
                            width: '100%',
                            backgroundColor: showPositioning ? theme.colors.primary : 'transparent',
                            color: showPositioning ? 'white' : theme.colors.text.primary,
                            border: `1px solid ${showPositioning ? theme.colors.primary : theme.colors.border}`,
                            padding: theme.spacing.sm,
                            borderRadius: theme.borderRadius.sm,
                            cursor: 'pointer',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            gap: theme.spacing.sm,
                            transition: 'all 0.2s ease',
                        }}
                    >
                        <span>📍</span>
                        {showPositioning ? 'Hide Position Editor' : 'Edit Position'}
                    </button>
                </div>
            )}

            {/* Positioning Screen */}
            {showPositioning && hasStyle(componentWithStyle) && (
                <PositioningScreen
                    component={componentWithStyle}
                    onPositionChange={handlePositionChange}
                    onClose={() => setShowPositioning(false)}
                />
            )}

            {/* Position display */}
            {hasStyle(componentWithStyle) && componentWithStyle.style?.position && (
                <div style={{
                    display: 'flex',
                    gap: theme.spacing.md,
                    justifyContent: 'center',
                    color: theme.colors.text.secondary,
                    fontSize: theme.fontSizes.sm,
                    padding: theme.spacing.sm,
                    backgroundColor: theme.colors.background.tertiary,
                    borderRadius: theme.borderRadius.sm,
                }}>
                    <span>X: {Math.round(componentWithStyle.style.position.x)}</span>
                    <span>Y: {Math.round(componentWithStyle.style.position.y)}</span>
                </div>
            )}
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\ComponentEditors.tsx ---

import React from 'react';
import { Component } from '../../types/script';
import { TextComponentEditor } from './TextComponentEditor';
import { ComparisonComponentEditor } from './ComparisonComponentEditor';
import { VoiceComponentEditor } from './VoiceComponentEditor';
import { VideoComponentEditor } from './VideoComponentEditor';
import { AudioComponentEditor } from './AudioComponentEditor';

interface ComponentEditorProps {
    component: Component;
    onChange: (component: Component) => void;
}

const componentEditors: Record<string, React.ComponentType<any>> = {
    text: TextComponentEditor,
    comparison: ComparisonComponentEditor,
    voice: VoiceComponentEditor,
    video: VideoComponentEditor,
    audio: AudioComponentEditor,
};

export const ComponentEditor: React.FC<ComponentEditorProps> = ({ component, onChange }) => {
    const EditorComponent = componentEditors[component.type];

    if (!EditorComponent) {
        return <div>No editor available for component type: {component.type}</div>;
    }

    return <EditorComponent component={component} onChange={onChange} />;
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\ComponentPalette.tsx ---

import React from 'react';
import { ComponentType } from '../../types/script';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';

interface ComponentPaletteProps {
    onDragStart: (type: ComponentType) => void;
}

interface ComponentOption {
    type: ComponentType;
    label: string;
    icon: string;
    description: string;
    create: () => any;
}

const components: ComponentOption[] = [
    {
        type: 'text',
        label: 'Text',
        icon: '📝',
        description: 'Add text with optional voice-over',
        create: () => ({
            type: 'text',
            text: '',
            style: {
                fontSize: '16px',
                fontWeight: 'normal',
                color: '#000000',
                lineHeight: '1.5',
            },
        }),
    },
    {
        type: 'title',
        label: 'Title',
        icon: '🔤',
        description: 'Large text with optional subtitle',
        create: () => ({
            type: 'title',
            text: '',
            style: {
                fontSize: '24px',
                fontWeight: 'bold',
                color: '#000000',
                lineHeight: '1.2',
            },
        }),
    },
    {
        type: 'comparison',
        label: 'Comparison',
        icon: '⚖️',
        description: 'Compare two options side by side',
        create: () => ({
            type: 'comparison',
            options: [],
            style: {
                width: '100%',
                height: 'auto',
            },
        }),
    },
    {
        type: 'countdown',
        label: 'Countdown',
        icon: '⏱️',
        description: 'Animated countdown timer',
        create: () => ({
            type: 'countdown',
            duration: 60,
            style: {
                width: '100%',
                height: 'auto',
            },
        }),
    },
    {
        type: 'transition',
        label: 'Transition',
        icon: '🔄',
        description: 'Smooth transition between scenes',
        create: () => ({
            type: 'transition',
            duration: 1,
            style: {
                width: '100%',
                height: 'auto',
            },
        }),
    },
    {
        type: 'voice',
        label: 'Voice',
        icon: '🎙️',
        description: 'Generate voice with synchronized captions',
        create: () => ({
            type: 'voice',
            text: '',
            style: {
                fontSize: '16px',
                fontWeight: 'normal',
                color: '#000000',
                lineHeight: '1.5',
            },
        }),
    },
    {
        type: 'video',
        label: 'Video',
        icon: '🎬',
        description: 'Add custom video content',
        create: () => ({
            type: 'video',
            videoUrl: '',
            style: {
                width: '100%',
                height: 'auto',
            },
        }),
    },
    {
        type: 'audio',
        label: 'Audio Effect',
        icon: '🎵',
        description: 'Add audio effect',
        create: () => ({
            type: 'audio',
            audioUrl: '',
            style: {
                volume: 1,
                loop: false,
                startTime: 0,
            },
        }),
    },
];

export const ComponentPalette: React.FC<ComponentPaletteProps> = ({ onDragStart }) => {
    return (
        <div>
            <h3 style={commonStyles.heading}>Components</h3>
            <div style={{
                display: 'flex',
                gap: theme.spacing.sm,
                flexWrap: 'wrap',
            }}>
                {components.map(({ type, label, icon, description }) => (
                    <div
                        key={type}
                        draggable
                        onDragStart={(e) => {
                            e.dataTransfer.setData('componentType', type);
                            onDragStart(type);
                        }}
                        style={{
                            backgroundColor: theme.colors.background.tertiary,
                            borderRadius: theme.borderRadius.md,
                            padding: theme.spacing.sm,
                            cursor: 'grab',
                            transition: 'all 0.2s ease',
                            border: `1px solid ${theme.colors.border}`,
                            flex: '0 0 auto',
                            display: 'flex',
                            alignItems: 'center',
                            gap: theme.spacing.sm,
                            minWidth: 'auto',
                        }}
                    >
                        <span style={{ fontSize: '1.2em' }}>{icon}</span>
                        <span style={{
                            color: theme.colors.text.primary,
                            fontWeight: 'bold',
                        }}>
                            {label}
                        </span>
                    </div>
                ))}
            </div>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\CountdownComponentEditor.tsx ---

import React from 'react';
import { CountdownComponent } from '../../types/script';
import { TextField, Grid, Switch, FormControlLabel } from '@mui/material';

interface CountdownComponentEditorProps {
    component: CountdownComponent;
    onChange: (component: CountdownComponent) => void;
}

export const CountdownComponentEditor: React.FC<CountdownComponentEditorProps> = ({ component, onChange }) => {
    return (
        <Grid container spacing={2}>
            <Grid item xs={12}>
                <TextField
                    fullWidth
                    type="number"
                    label="Count From"
                    value={component.from}
                    onChange={(e) => onChange({
                        ...component,
                        from: parseInt(e.target.value) || 0
                    })}
                />
            </Grid>
            <Grid item xs={12}>
                <FormControlLabel
                    control={
                        <Switch
                            checked={component.sound ?? false}
                            onChange={(e) => onChange({
                                ...component,
                                sound: e.target.checked
                            })}
                        />
                    }
                    label="Play Sound"
                />
            </Grid>
        </Grid>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\DraggablePreview.tsx ---

import React, { useState, useRef } from 'react';
import { TextStyle } from '../../types/script';

interface DraggablePreviewProps {
    text: string;
    style: TextStyle;
    onChange: (updates: Partial<TextStyle>) => void;
}

export const DraggablePreview: React.FC<DraggablePreviewProps> = ({
    text,
    style,
    onChange,
}) => {
    const containerRef = useRef<HTMLDivElement>(null);
    const elementRef = useRef<HTMLDivElement>(null);
    const [isDragging, setIsDragging] = useState(false);
    const [isResizing, setIsResizing] = useState(false);
    const [startPos, setStartPos] = useState({ x: 0, y: 0 });

    const position = style.position || { x: 50, y: 50, width: 80 };

    const handleMouseDown = (e: React.MouseEvent, mode: 'drag' | 'resize') => {
        if (mode === 'drag') setIsDragging(true);
        if (mode === 'resize') setIsResizing(true);
        setStartPos({ x: e.clientX, y: e.clientY });
        e.preventDefault();
    };

    const handleMouseMove = (e: React.MouseEvent) => {
        if (!isDragging && !isResizing) return;
        if (!containerRef.current) return;

        const containerRect = containerRef.current.getBoundingClientRect();
        
        if (isDragging) {
            const dx = e.clientX - startPos.x;
            const dy = e.clientY - startPos.y;

            const newX = position.x + (dx / containerRect.width * 100);
            const newY = position.y + (dy / containerRect.height * 100);

            onChange({
                position: {
                    ...position,
                    x: Math.max(0, Math.min(100, newX)),
                    y: Math.max(0, Math.min(100, newY)),
                }
            });
        }

        if (isResizing) {
            const dx = e.clientX - startPos.x;
            const newWidth = position.width + (dx / containerRect.width * 100);

            onChange({
                position: {
                    ...position,
                    width: Math.max(10, Math.min(100, newWidth)),
                }
            });
        }

        setStartPos({ x: e.clientX, y: e.clientY });
    };

    const handleMouseUp = () => {
        setIsDragging(false);
        setIsResizing(false);
    };

    return (
        <div
            ref={containerRef}
            style={{
                position: 'relative',
                width: '100%',
                height: '400px',
                backgroundColor: '#1a1a1a',
                borderRadius: '8px',
                overflow: 'hidden',
                cursor: isDragging ? 'grabbing' : 'default',
            }}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseUp}
        >
            <div
                ref={elementRef}
                style={{
                    position: 'absolute',
                    left: `${position.x}%`,
                    top: `${position.y}%`,
                    width: `${position.width}%`,
                    transform: 'translate(-50%, -50%)',
                    cursor: isDragging ? 'grabbing' : 'grab',
                    userSelect: 'none',
                    backgroundColor: 'rgba(255, 255, 255, 0.1)',
                    padding: '20px',
                    borderRadius: '8px',
                    border: '2px solid rgba(255, 255, 255, 0.2)',
                }}
            >
                <div
                    style={{
                        padding: '10px',
                        fontFamily: style.fontFamily,
                        fontSize: `${style.fontSize}px`,
                        color: style.color || '#fff',
                        textAlign: style.textAlign || 'center',
                        fontWeight: style.fontWeight,
                    }}
                    onMouseDown={(e) => handleMouseDown(e, 'drag')}
                >
                    {text || 'Preview text will appear here...'}
                </div>
                <div
                    style={{
                        position: 'absolute',
                        right: '-5px',
                        top: '50%',
                        transform: 'translateY(-50%)',
                        width: '10px',
                        height: '20px',
                        backgroundColor: 'rgba(255, 255, 255, 0.5)',
                        cursor: 'ew-resize',
                        borderRadius: '4px',
                    }}
                    onMouseDown={(e) => handleMouseDown(e, 'resize')}
                />
            </div>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\ImageComponentEditor.tsx ---

import React, { useState } from 'react';
import { ImageComponent } from '../../types/script';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';
import { ColorPicker } from '../common/ColorPicker';
import { Slider } from '../common/Slider';
import { Switch } from '../common/Switch';

interface PexelsImage {
    id: number;
    thumbnail: string;
    url: string;
    photographer: string;
    width: number;
    height: number;
}

interface ImageComponentEditorProps {
    component: ImageComponent;
    onChange: (component: ImageComponent) => void;
}

export const ImageComponentEditor: React.FC<ImageComponentEditorProps> = ({
    component,
    onChange,
}) => {
    const [uploadingImage, setUploadingImage] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [searchQuery, setSearchQuery] = useState('');
    const [searching, setSearching] = useState(false);
    const [pexelsImages, setPexelsImages] = useState<PexelsImage[]>([]);
    const [showPexelsSearch, setShowPexelsSearch] = useState(false);

    const handleImageUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (!file) return;

        setUploadingImage(true);
        setError(null);

        try {
            const formData = new FormData();
            formData.append('file', file);

            const response = await fetch('http://localhost:5003/upload_image', {
                method: 'POST',
                body: formData,
            });

            if (!response.ok) {
                throw new Error('Failed to upload image');
            }

            const data = await response.json();
            onChange({
                ...component,
                imageUrl: data.url,
            });
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to upload image');
        } finally {
            setUploadingImage(false);
        }
    };

    const handlePexelsSearch = async () => {
        if (!searchQuery.trim()) return;

        setSearching(true);
        setError(null);

        try {
            const response = await fetch(`http://localhost:5003/search_pexels?query=${encodeURIComponent(searchQuery)}`);
            if (!response.ok) {
                throw new Error('Failed to search Pexels');
            }

            const images = await response.json();
            setPexelsImages(images);
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to search Pexels');
        } finally {
            setSearching(false);
        }
    };

    const handlePexelsSelect = async (pexelsImage: PexelsImage) => {
        setUploadingImage(true);
        setError(null);

        try {
            const response = await fetch('http://localhost:5003/download_pexels', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ url: pexelsImage.url }),
            });

            if (!response.ok) {
                throw new Error('Failed to download image');
            }

            const data = await response.json();
            onChange({
                ...component,
                imageUrl: data.url,
                style: {
                    ...component.style,
                    width: pexelsImage.width,
                    height: pexelsImage.height,
                },
            });
            setShowPexelsSearch(false);
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to download image');
        } finally {
            setUploadingImage(false);
        }
    };

    const handleStyleChange = (updates: Partial<ImageComponent['style']>) => {
        onChange({
            ...component,
            style: {
                ...component.style,
                ...updates,
            },
        });
    };

    const handleDropShadowChange = (updates: Partial<ImageComponent['style']['dropShadow']>) => {
        handleStyleChange({
            dropShadow: {
                ...component.style?.dropShadow,
                ...updates,
            },
        });
    };

    const handleBorderChange = (updates: Partial<ImageComponent['style']['border']>) => {
        handleStyleChange({
            border: {
                ...component.style?.border,
                ...updates,
            },
        });
    };

    return (
        <div style={styles.container}>
            {/* Image Upload */}
            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Image</h3>
                <div style={styles.uploadButtons}>
                    <input
                        type="file"
                        accept="image/*"
                        onChange={handleImageUpload}
                        style={{ display: 'none' }}
                        id="image-upload"
                    />
                    <label htmlFor="image-upload" style={styles.uploadButton}>
                        {uploadingImage ? 'Uploading...' : 'Upload Image'}
                    </label>
                    <button
                        onClick={() => setShowPexelsSearch(!showPexelsSearch)}
                        style={styles.uploadButton}
                    >
                        Search Pexels
                    </button>
                </div>

                {showPexelsSearch && (
                    <div style={styles.pexelsSearch}>
                        <div style={styles.searchBar}>
                            <input
                                type="text"
                                value={searchQuery}
                                onChange={(e) => setSearchQuery(e.target.value)}
                                onKeyDown={(e) => e.key === 'Enter' && handlePexelsSearch()}
                                placeholder="Search Pexels images..."
                                style={styles.searchInput}
                            />
                            <button
                                onClick={handlePexelsSearch}
                                style={styles.searchButton}
                                disabled={searching}
                            >
                                {searching ? 'Searching...' : 'Search'}
                            </button>
                        </div>
                        <div style={styles.pexelsResults}>
                            {pexelsImages.map((image) => (
                                <div
                                    key={image.id}
                                    onClick={() => handlePexelsSelect(image)}
                                    style={styles.pexelsImage}
                                >
                                    <img
                                        src={image.thumbnail}
                                        alt={`By ${image.photographer}`}
                                        style={styles.pexelsThumbnail}
                                    />
                                    <div style={styles.photographerCredit}>
                                        By {image.photographer}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                )}

                {error && <div style={styles.error}>{error}</div>}
                {component.imageUrl && (
                    <img
                        src={component.imageUrl}
                        alt="Preview"
                        style={styles.preview}
                    />
                )}
            </div>

            {/* Size and Position */}
            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Size & Position</h3>
                <Slider
                    label="Width"
                    value={component.style?.width ?? 400}
                    onChange={(value) => handleStyleChange({ width: value })}
                    min={50}
                    max={1920}
                />
                <Slider
                    label="Height"
                    value={component.style?.height ?? 400}
                    onChange={(value) => handleStyleChange({ height: value })}
                    min={50}
                    max={1080}
                />
                <Slider
                    label="X Position"
                    value={component.style?.position?.x ?? 0}
                    onChange={(value) => handleStyleChange({ position: { ...component.style?.position, x: value } })}
                    min={-1920}
                    max={1920}
                />
                <Slider
                    label="Y Position"
                    value={component.style?.position?.y ?? 0}
                    onChange={(value) => handleStyleChange({ position: { ...component.style?.position, y: value } })}
                    min={-1080}
                    max={1080}
                />
            </div>

            {/* Transform */}
            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Transform</h3>
                <Slider
                    label="Scale"
                    value={component.style?.scale ?? 1}
                    onChange={(value) => handleStyleChange({ scale: value })}
                    min={0.1}
                    max={5}
                    step={0.1}
                />
                <Slider
                    label="Rotation"
                    value={component.style?.rotation ?? 0}
                    onChange={(value) => handleStyleChange({ rotation: value })}
                    min={-180}
                    max={180}
                />
                <Slider
                    label="Opacity"
                    value={component.style?.opacity ?? 1}
                    onChange={(value) => handleStyleChange({ opacity: value })}
                    min={0}
                    max={1}
                    step={0.1}
                />
            </div>

            {/* Border */}
            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Border</h3>
                <Switch
                    label="Enable Border"
                    checked={component.style?.border?.enabled ?? false}
                    onChange={(checked) => handleBorderChange({ enabled: checked })}
                />
                {component.style?.border?.enabled && (
                    <>
                        <ColorPicker
                            label="Border Color"
                            color={component.style.border.color}
                            onChange={(color) => handleBorderChange({ color })}
                        />
                        <Slider
                            label="Border Width"
                            value={component.style.border.width}
                            onChange={(value) => handleBorderChange({ width: value })}
                            min={1}
                            max={20}
                        />
                    </>
                )}
            </div>

            {/* Drop Shadow */}
            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Drop Shadow</h3>
                <Switch
                    label="Enable Shadow"
                    checked={component.style?.dropShadow?.enabled ?? false}
                    onChange={(checked) => handleDropShadowChange({ enabled: checked })}
                />
                {component.style?.dropShadow?.enabled && (
                    <>
                        <ColorPicker
                            label="Shadow Color"
                            color={component.style.dropShadow.color}
                            onChange={(color) => handleDropShadowChange({ color })}
                        />
                        <Slider
                            label="Blur Radius"
                            value={component.style.dropShadow.blur}
                            onChange={(value) => handleDropShadowChange({ blur: value })}
                            min={0}
                            max={50}
                        />
                        <Slider
                            label="Spread"
                            value={component.style.dropShadow.spread}
                            onChange={(value) => handleDropShadowChange({ spread: value })}
                            min={0}
                            max={50}
                        />
                        <Slider
                            label="X Offset"
                            value={component.style.dropShadow.x}
                            onChange={(value) => handleDropShadowChange({ x: value })}
                            min={-50}
                            max={50}
                        />
                        <Slider
                            label="Y Offset"
                            value={component.style.dropShadow.y}
                            onChange={(value) => handleDropShadowChange({ y: value })}
                            min={-50}
                            max={50}
                        />
                    </>
                )}
            </div>
        </div>
    );
};

const styles = {
    container: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.lg,
    },
    section: {
        backgroundColor: theme.colors.background.secondary,
        padding: theme.spacing.md,
        borderRadius: theme.borderRadius.md,
    },
    sectionTitle: {
        margin: 0,
        marginBottom: theme.spacing.sm,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.md,
    },
    uploadButtons: {
        display: 'flex',
        gap: theme.spacing.sm,
        marginBottom: theme.spacing.md,
    },
    uploadButton: {
        ...commonStyles.button.primary,
        display: 'inline-block',
        cursor: 'pointer',
        marginBottom: theme.spacing.md,
    },
    preview: {
        width: '100%',
        height: '200px',
        objectFit: 'cover' as const,
        borderRadius: theme.borderRadius.sm,
        marginTop: theme.spacing.sm,
    },
    error: {
        color: theme.colors.error,
        marginTop: theme.spacing.sm,
        fontSize: theme.fontSizes.sm,
    },
    pexelsSearch: {
        marginTop: theme.spacing.md,
    },
    searchBar: {
        display: 'flex',
        gap: theme.spacing.sm,
        marginBottom: theme.spacing.md,
    },
    searchInput: {
        flex: 1,
        padding: theme.spacing.sm,
        backgroundColor: theme.colors.background.tertiary,
        border: `1px solid ${theme.colors.border}`,
        borderRadius: theme.borderRadius.sm,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
    },
    searchButton: {
        ...commonStyles.button.primary,
    },
    pexelsResults: {
        display: 'grid',
        gridTemplateColumns: 'repeat(auto-fill, minmax(150px, 1fr))',
        gap: theme.spacing.md,
        maxHeight: '400px',
        overflowY: 'auto',
    },
    pexelsImage: {
        cursor: 'pointer',
        borderRadius: theme.borderRadius.sm,
        overflow: 'hidden',
        backgroundColor: theme.colors.background.tertiary,
        transition: 'transform 0.2s',
        '&:hover': {
            transform: 'scale(1.05)',
        },
    },
    pexelsThumbnail: {
        width: '100%',
        height: '150px',
        objectFit: 'cover' as const,
    },
    photographerCredit: {
        padding: theme.spacing.xs,
        fontSize: theme.fontSizes.xs,
        color: theme.colors.text.secondary,
        textAlign: 'center' as const,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\PositioningScreen.tsx ---

import React, { useRef, useState, useEffect, useCallback } from 'react';
import { TextComponent } from '../../types/script';
import { theme } from '../../styles/theme';

const PREVIEW_WIDTH = 400; // Doubled from 200
const PREVIEW_HEIGHT = 712; // Doubled from 356
const SCALE_FACTOR = 2.7; // Halved from 5.4 since we doubled the preview size

interface Props {
    component: TextComponent;
    onPositionChange: (position: { x: number; y: number }) => void;
    onClose: () => void;
}

const getInitialPosition = (component: TextComponent) => {
    if (component.style?.position) {
        return {
            x: component.style.position.x / SCALE_FACTOR,
            y: component.style.position.y / SCALE_FACTOR,
        };
    }
    return {
        x: PREVIEW_WIDTH / 2,
        y: PREVIEW_HEIGHT / 2,
    };
};

export const PositioningScreen: React.FC<Props> = React.memo(({ component, onPositionChange, onClose }) => {
    const containerRef = useRef<HTMLDivElement>(null);
    const [state, setState] = useState(() => ({
        isDragging: false,
        position: getInitialPosition(component)
    }));

    const updatePosition = useCallback((clientX: number, clientY: number) => {
        if (containerRef.current) {
            const rect = containerRef.current.getBoundingClientRect();
            const x = Math.min(Math.max(0, clientX - rect.left), PREVIEW_WIDTH);
            const y = Math.min(Math.max(0, clientY - rect.top), PREVIEW_HEIGHT);
            
            setState(prev => ({
                ...prev,
                position: { x, y }
            }));
            onPositionChange({
                x: Math.round(x * SCALE_FACTOR),
                y: Math.round(y * SCALE_FACTOR),
            });
        }
    }, [onPositionChange]);

    const handleMouseDown = useCallback((e: React.MouseEvent) => {
        setState(prev => ({ ...prev, isDragging: true }));
        updatePosition(e.clientX, e.clientY);
    }, [updatePosition]);

    const handleMouseMove = useCallback((e: MouseEvent) => {
        if (state.isDragging) {
            updatePosition(e.clientX, e.clientY);
        }
    }, [state.isDragging, updatePosition]);

    const handleMouseUp = useCallback(() => {
        setState(prev => ({ ...prev, isDragging: false }));
    }, []);

    useEffect(() => {
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        return () => {
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
        };
    }, [handleMouseMove, handleMouseUp]);

    return (
        <div style={{
            display: 'flex',
            flexDirection: 'column',
            gap: theme.spacing.sm,
        }}>
            <div
                ref={containerRef}
                onMouseDown={handleMouseDown}
                style={{
                    width: PREVIEW_WIDTH,
                    height: PREVIEW_HEIGHT,
                    backgroundColor: '#1a1a1a',
                    position: 'relative',
                    borderRadius: theme.borderRadius.sm,
                    overflow: 'hidden',
                    cursor: state.isDragging ? 'grabbing' : 'grab',
                }}
            >
                {/* Grid lines */}
                <div style={{
                    position: 'absolute',
                    inset: 0,
                    backgroundImage: `
                        linear-gradient(to right, #333 1px, transparent 1px),
                        linear-gradient(to bottom, #333 1px, transparent 1px)
                    `,
                    backgroundSize: '40px 40px',
                    opacity: 0.5,
                    pointerEvents: 'none',
                }} />

                {/* Center dot */}
                <div
                    style={{
                        position: 'absolute',
                        left: state.position.x,
                        top: state.position.y,
                        width: 8,
                        height: 8,
                        backgroundColor: theme.colors.primary,
                        borderRadius: '50%',
                        transform: 'translate(-50%, -50%)',
                        pointerEvents: 'none',
                        boxShadow: '0 0 0 2px rgba(255, 255, 255, 0.3)',
                    }}
                />
            </div>

            {/* Position display */}
            <div style={{
                display: 'flex',
                gap: theme.spacing.md,
                justifyContent: 'center',
                color: theme.colors.text.secondary,
                fontSize: theme.fontSizes.sm,
            }}>
                <span>X: {Math.round(state.position.x * SCALE_FACTOR)}</span>
                <span>Y: {Math.round(state.position.y * SCALE_FACTOR)}</span>
            </div>
        </div>
    );
}); 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\ScriptEditor.tsx ---

import React, { useState } from 'react';
import { Script, ScriptComponent, ComponentType } from '../../types/script';
import { ComponentEditor } from './ComponentEditor';
import { StyleEditor } from './StyleEditor';
import { Player } from '@remotion/player';
import { ScriptVideo } from '../Video/ScriptVideo';
import { ComponentPalette } from './ComponentPalette';
import { Timeline } from './Timeline';
import '../../styles/timeline.css';
import { ConfigMenu } from '../ConfigMenu/ConfigMenu';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';
import { Modal } from '../common/Modal';
import { TemplateManager } from '../TemplateManager/TemplateManager';
import { CaptionTimeline } from './CaptionTimeline';

export const ScriptEditor: React.FC = () => {
    const [script, setScript] = useState<Script>({
        id: Date.now().toString(),
        title: 'New Quiz',
        components: [],
        captionTracks: [],
        settings: {
            defaultTextStyle: {
                fontSize: 40,
                color: 'white',
                fontFamily: 'Arial',
                textAlign: 'center',
            },
            defaultCaptionStyle: {
                fontSize: 24,
                color: 'white',
                fontFamily: 'Arial',
                textAlign: 'center',
            },
            background: {
                type: 'none',
            }
        },
    });

    const [selectedComponentId, setSelectedComponentId] = useState<string>();
    const [isConfigOpen, setIsConfigOpen] = useState(false);
    const [isTemplateManagerOpen, setIsTemplateManagerOpen] = useState(false);

    const handleComponentChange = (updated: ScriptComponent) => {
        setScript(prev => ({
            ...prev,
            components: prev.components.map(c => 
                c.id === updated.id ? updated : c
            ),
        }));
    };

    const handleComponentDelete = (id: string) => {
        setScript(prev => ({
            ...prev,
            components: prev.components.filter(c => c.id !== id),
        }));
        setSelectedComponentId(undefined);
    };

    const handleDragStart = (type: ComponentType) => {
        // This can be empty or add visual feedback
    };

    const handleReorder = (newComponents: ScriptComponent[]) => {
        setScript(prev => ({
            ...prev,
            components: newComponents,
        }));
    };

    const selectedComponent = script.components.find(c => c.id === selectedComponentId);

    // Calculate total duration, minimum 30 frames (1 second)
    const totalDuration = Math.max(
        ...script.components.map(comp => {
            const start = comp.startFrame || 0;
            const duration = comp.durationInFrames || 150; // Default 5 seconds if not specified
            return start + duration;
        }),
        30 // Minimum 1 second
    );

    const PreviewPanel = ({ script }: { script: Script }) => (
        <>
            <div style={{
                padding: theme.spacing.md,
                borderBottom: `1px solid ${theme.colors.border}`,
                backgroundColor: theme.colors.background.secondary,
            }}>
                <h3 style={{
                    ...commonStyles.heading,
                    margin: 0,
                    fontSize: '16px',
                }}>
                    Preview
                </h3>
            </div>
            <div style={{
                flex: 1,
                padding: theme.spacing.md,
                display: 'flex',
                flexDirection: 'column',
                gap: theme.spacing.md,
            }}>
                <div style={{
                    position: 'relative',
                    width: '100%',
                    aspectRatio: '9/16',
                    backgroundColor: '#000',
                    borderRadius: theme.borderRadius.md,
                    overflow: 'hidden',
                }}>
                    <Player
                        component={ScriptVideo}
                        durationInFrames={totalDuration}
                        fps={30}
                        compositionWidth={1080}
                        compositionHeight={1920}
                        style={{
                            width: '100%',
                            height: '100%',
                        }}
                        controls
                        autoPlay
                        loop
                        inputProps={{ script }}
                    />
                </div>
            </div>
        </>
    );

    return (
        <div style={{
            backgroundColor: theme.colors.background.primary,
            minHeight: '100vh',
            display: 'flex',
            flexDirection: 'column',
        }}>
            {/* Header */}
            <header style={{
                backgroundColor: theme.colors.background.secondary,
                padding: `${theme.spacing.sm} ${theme.spacing.md}`,
                borderBottom: `1px solid ${theme.colors.border}`,
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                height: '48px',
            }}>
                <h1 style={{ margin: 0, fontSize: '24px' }}>Video Editor</h1>
                <div style={{ display: 'flex', gap: theme.spacing.md }}>
                    <button
                        onClick={() => setIsTemplateManagerOpen(true)}
                        style={{
                            ...commonStyles.button.secondary,
                            display: 'flex',
                            alignItems: 'center',
                            gap: theme.spacing.sm,
                        }}
                    >
                        📋 Templates
                    </button>
                    <button
                        onClick={() => setIsConfigOpen(true)}
                        style={{
                            ...commonStyles.button.secondary,
                            display: 'flex',
                            alignItems: 'center',
                            gap: theme.spacing.sm,
                        }}
                    >
                        ⚙️ Settings
                    </button>
                </div>
            </header>

            {/* Main Content */}
            <div style={{
                display: 'grid',
                gridTemplateColumns: '4fr 1fr',
                gap: theme.spacing.sm,
                padding: theme.spacing.sm,
                flex: 1,
                height: 'calc(100vh - 48px)',
                overflow: 'hidden',
            }}>
                {/* Left Panel */}
                <div style={{
                    display: 'flex',
                    flexDirection: 'column',
                    gap: theme.spacing.sm,
                    overflow: 'hidden',
                }}>
                    {/* Component Palette */}
                    <div style={{
                        ...commonStyles.card,
                        padding: theme.spacing.sm,
                    }}>
                        <ComponentPalette onDragStart={handleDragStart} />
                    </div>

                    {/* Timeline Container */}
                    <div style={{
                        ...commonStyles.card,
                        padding: theme.spacing.sm,
                        display: 'flex',
                        flexDirection: 'column',
                        gap: theme.spacing.md,
                        overflow: 'visible',
                    }}>
                        {/* Main Timeline */}
                        <div>
                            <h3 style={{ 
                                color: theme.colors.text.primary, 
                                margin: 0,
                                marginBottom: theme.spacing.md,
                                fontSize: '16px',
                                fontWeight: 'bold',
                            }}>
                                Timeline
                            </h3>
                            <Timeline
                                script={script}
                                onReorder={handleReorder}
                                onSelect={setSelectedComponentId}
                                selectedId={selectedComponentId}
                                onDelete={handleComponentDelete}
                            />
                        </div>

                        {/* Caption Timeline */}
                        <CaptionTimeline
                            script={script}
                            onScriptChange={setScript}
                        />
                    </div>
                </div>

                {/* Right Panel */}
                <div style={{
                    flex: 1,
                    display: 'flex',
                    flexDirection: 'column',
                    padding: theme.spacing.md,
                    backgroundColor: theme.colors.background.primary,
                    overflow: 'auto',
                }}>
                    {/* Preview */}
                    <div style={{
                        position: 'relative',
                        width: '100%',
                        maxWidth: '300px',
                        margin: '0 auto',
                        aspectRatio: '9/16',
                        backgroundColor: '#000',
                        borderRadius: theme.borderRadius.lg,
                        overflow: 'hidden',
                    }}>
                        <Player
                            component={ScriptVideo}
                            durationInFrames={totalDuration}
                            fps={30}
                            compositionWidth={1080}
                            compositionHeight={1920}
                            style={{
                                width: '100%',
                                height: '100%',
                            }}
                            controls
                            autoPlay
                            loop
                            inputProps={{
                                script
                            }}
                        />
                    </div>
                </div>
            </div>

            {/* Component Editor Modal */}
            <Modal
                isOpen={!!selectedComponentId}
                onClose={() => setSelectedComponentId(undefined)}
                title={
                    selectedComponent && (
                        <h2 style={{
                            ...commonStyles.heading,
                            margin: 0,
                            display: 'flex',
                            alignItems: 'center',
                            gap: theme.spacing.sm,
                            color: theme.colors.text.primary,
                            fontSize: '20px',
                        }}>
                            <span style={{ fontSize: '1.2em' }}>
                                {selectedComponent.type === 'title' && '📑'}
                                {selectedComponent.type === 'text' && '📝'}
                                {selectedComponent.type === 'comparison' && '⚖️'}
                                {selectedComponent.type === 'countdown' && '⏲️'}
                                {selectedComponent.type === 'transition' && '🔄'}
                            </span>
                            Edit {selectedComponent.type.charAt(0).toUpperCase() + selectedComponent.type.slice(1)}
                        </h2>
                    )
                }
            >
                {selectedComponent && (
                    <ComponentEditor
                        component={selectedComponent}
                        onChange={handleComponentChange}
                        onDelete={handleComponentDelete}
                    />
                )}
            </Modal>

            <ConfigMenu 
                isOpen={isConfigOpen} 
                onClose={() => setIsConfigOpen(false)} 
                script={script}
                onScriptChange={setScript}
            />

            {/* Template Manager Modal */}
            <Modal
                isOpen={isTemplateManagerOpen}
                onClose={() => setIsTemplateManagerOpen(false)}
                title="Template Manager"
            >
                <TemplateManager
                    currentScript={script}
                    onTemplateSelect={(newScript) => {
                        setScript(newScript);
                        setIsTemplateManagerOpen(false);
                    }}
                />
            </Modal>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\TextComponentEditor.tsx ---

import React, { useState, useEffect } from 'react';
import { TextComponent } from '../../types/script';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';
import { PositioningScreen } from './PositioningScreen';

interface TextComponentEditorProps {
    component: TextComponent;
    onChange: (updated: TextComponent) => void;
}

// Predefined fonts list
const FONTS = {
    system: [
        'Arial',
        'Helvetica',
        'Times New Roman',
        'Georgia',
        'Verdana',
        'Roboto',
        'Open Sans',
        'Montserrat',
    ],
    getCustomFonts: (): string[] => {
        try {
            const savedFonts = localStorage.getItem('customFonts');
            if (savedFonts) {
                const fonts = JSON.parse(savedFonts);
                return fonts.map((font: { name: string }) => font.name);
            }
        } catch (error) {
            console.error('Error loading custom fonts:', error);
        }
        return [];
    },
};

const styles = {
    section: {
        backgroundColor: theme.colors.background.tertiary,
        padding: theme.spacing.md,
        borderRadius: theme.borderRadius.md,
        marginBottom: theme.spacing.md,
    },
    sectionTitle: {
        fontSize: '14px',
        fontWeight: 'bold',
        color: theme.colors.text.primary,
        margin: 0,
        marginBottom: theme.spacing.sm,
    },
    input: {
        width: '100%',
        padding: '10px 14px',
        borderRadius: '8px',
        border: `1px solid ${theme.colors.border}`,
        backgroundColor: theme.colors.background.tertiary,
        color: theme.colors.text.primary,
        fontSize: '14px',
        '&:focus': {
            outline: 'none',
            borderColor: theme.colors.primary,
        },
    },
    textarea: {
        ...commonStyles.input,
        minHeight: '120px',
        resize: 'vertical' as const,
        whiteSpace: 'pre-wrap',
        lineHeight: '1.5',
        padding: '12px 16px',
    },
    grid: {
        display: 'grid',
        gridTemplateColumns: 'repeat(2, 1fr)',
        gap: '20px',
    },
    previewArea: {
        width: '1920px',
        height: '1080px',
        backgroundColor: 'rgba(0, 0, 0, 0.8)',
        position: 'relative' as const,
        transform: 'scale(0.25)',
        transformOrigin: 'top left',
        cursor: 'pointer',
    },
    animationTimingGrid: {
        marginTop: '12px',
        display: 'grid',
        gap: '12px',
        gridTemplateColumns: '1fr 1fr',
    },
    animationInput: {
        width: '100%',
        padding: '8px 12px',
        borderRadius: '6px',
        border: `1px solid ${theme.colors.border}`,
        backgroundColor: theme.colors.background.tertiary,
        color: theme.colors.text.primary,
        fontSize: '14px',
        fontFamily: 'monospace',
    },
    animationLabel: {
        fontWeight: 'bold',
        marginBottom: '6px',
        color: theme.colors.text.primary,
        fontSize: '12px',
    },
};

export const TextComponentEditor: React.FC<TextComponentEditorProps> = ({
    component,
    onChange,
}) => {
    const style = component.style || {};
    const [customFonts, setCustomFonts] = useState<string[]>([]);
    const [isPositioningPopupOpen, setIsPositioningPopupOpen] = useState(false);

    useEffect(() => {
        const updateCustomFonts = () => {
            setCustomFonts(FONTS.getCustomFonts());
        };

        updateCustomFonts();
        window.addEventListener('storage', updateCustomFonts);
        return () => window.removeEventListener('storage', updateCustomFonts);
    }, []);

    const handleTextChange = (text: string) => {
        if (text && style.wordsPerLine && style.wordsPerLine > 0) {
            const cleanText = text.replace(/[\n\r]+/g, ' ').replace(/\s+/g, ' ').trim();
            const words = cleanText.split(' ');
            const lines = [];
            
            for (let i = 0; i < words.length; i += style.wordsPerLine) {
                const line = words.slice(i, i + style.wordsPerLine).join(' ');
                if (line) lines.push(line);
            }
            
            text = lines.join('\n');
        }

        onChange({
            ...component,
            text,
        });
    };

    const handleBlockStyleToggle = (value: string) => {
        console.log('Block style changed to:', value);
        
        let backgroundColor, textColor;
        if (value === 'white') {
            backgroundColor = '#FFFFFF';
            textColor = '#000000';
        } else if (value === 'black') {
            backgroundColor = '#000000';
            textColor = '#FFFFFF';
        } else {
            backgroundColor = undefined;
            textColor = '#FFFFFF';
        }

        console.log('Setting colors:', { backgroundColor, textColor });
        
        const newStyle = {
            ...style,
            blockStyle: { enabled: value !== 'disabled' },
            backgroundColor,
            color: textColor,
            textTransform: value !== 'disabled' ? 'uppercase' as const : 'none' as const,
            fontWeight: value !== 'disabled' ? 'bold' : 'normal',
            padding: value !== 'disabled' ? '20px 40px' : undefined,
            borderRadius: value !== 'disabled' ? '15px' : undefined,
            textAlign: value !== 'disabled' ? 'center' as const : (style.textAlign || 'center'),
        };
        
        console.log('New style:', newStyle);
        
        onChange({
            ...component,
            style: newStyle,
        });
    };

    const handlePositionChange = (position: { x: number; y: number }) => {
        onChange({
            ...component,
            style: {
                ...style,
                position,
            },
        });
    };

    return (
        <>
            {/* Basic Settings */}
            <div style={styles.grid}>
                <div>
                    <label style={styles.sectionTitle}>Duration (seconds)</label>
                    <input
                        type="number"
                        value={component.durationInFrames / 30}
                        onChange={(e) => onChange({
                            ...component,
                            durationInFrames: Math.max(1, parseFloat(e.target.value)) * 30,
                        })}
                        style={styles.input}
                        min="0.1"
                        step="0.1"
                    />
                </div>
                <div>
                    <label style={styles.sectionTitle}>Block Style</label>
                    <select
                        value={style.blockStyle?.enabled ? 
                            (style.backgroundColor === '#FFFFFF' ? 'white' : 'black') 
                            : 'disabled'}
                        onChange={(e) => handleBlockStyleToggle(e.target.value)}
                        style={styles.input}
                    >
                        <option value="disabled">Normal Text</option>
                        <option value="white">White Block with Black Text</option>
                        <option value="black">Black Block with White Text</option>
                    </select>
                </div>
            </div>

            {/* Content */}
            <div style={{ marginTop: theme.spacing.lg }}>
                <div style={{
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    marginBottom: theme.spacing.sm,
                }}>
                    <h3 style={styles.sectionTitle}>Content</h3>
                    <button style={{
                        backgroundColor: 'rgb(255, 75, 75)',
                        color: 'white',
                        border: 'none',
                        padding: '4px 8px',
                        borderRadius: '4px',
                        cursor: 'pointer',
                        fontSize: '13px',
                    }}>Delete</button>
                </div>
                <textarea
                    value={component.text}
                    onChange={(e) => handleTextChange(e.target.value)}
                    style={styles.textarea}
                    placeholder="Enter your text..."
                />
            </div>

            {/* Font Settings */}
            <div style={{ marginTop: theme.spacing.lg }}>
                <h3 style={styles.sectionTitle}>Font Settings</h3>
                <div style={styles.grid}>
                    <div>
                        <label style={styles.sectionTitle}>Font Family</label>
                        <select
                            value={style.fontFamily}
                            onChange={(e) => onChange({
                                ...component,
                                style: {
                                    ...style,
                                    fontFamily: e.target.value,
                                },
                            })}
                            style={styles.input}
                        >
                            <optgroup label="System Fonts">
                                {FONTS.system.map(font => (
                                    <option key={font} value={font}>{font}</option>
                                ))}
                            </optgroup>
                            {customFonts.length > 0 && (
                                <optgroup label="Custom Fonts">
                                    {customFonts.map(font => (
                                        <option key={font} value={font}>{font}</option>
                                    ))}
                                </optgroup>
                            )}
                        </select>
                    </div>
                    <div>
                        <label style={styles.sectionTitle}>Font Size (px)</label>
                        <input
                            type="number"
                            value={style.fontSize}
                            onChange={(e) => onChange({
                                ...component,
                                style: {
                                    ...style,
                                    fontSize: parseInt(e.target.value),
                                },
                            })}
                            style={styles.input}
                            min="12"
                            max="200"
                        />
                    </div>
                    <div>
                        <label style={styles.sectionTitle}>Font Weight</label>
                        <select
                            value={style.fontWeight}
                            onChange={(e) => onChange({
                                ...component,
                                style: {
                                    ...style,
                                    fontWeight: e.target.value,
                                },
                            })}
                            style={styles.input}
                        >
                            <option value="300">Light</option>
                            <option value="400">Regular</option>
                            <option value="500">Medium</option>
                            <option value="600">Semi Bold</option>
                            <option value="700">Bold</option>
                            <option value="800">Extra Bold</option>
                        </select>
                    </div>
                    <div>
                        <label style={styles.sectionTitle}>Line Height</label>
                        <select
                            value={style.lineHeight || '1.5'}
                            onChange={(e) => onChange({
                                ...component,
                                style: {
                                    ...style,
                                    lineHeight: e.target.value,
                                },
                            })}
                            style={styles.input}
                        >
                            <option value="1">Tight</option>
                            <option value="1.2">Compact</option>
                            <option value="1.5">Normal</option>
                            <option value="1.8">Relaxed</option>
                            <option value="2">Spacious</option>
                        </select>
                    </div>
                </div>
            </div>

            {/* Style Settings */}
            <div style={{ marginTop: theme.spacing.lg }}>
                <h3 style={styles.sectionTitle}>Style Settings</h3>
                <div style={styles.grid}>
                    <div>
                        <label style={styles.sectionTitle}>Text Color</label>
                        <div style={{ display: 'flex', gap: '8px' }}>
                            <input
                                type="color"
                                value={style.color || '#FFFFFF'}
                                onChange={(e) => onChange({
                                    ...component,
                                    style: {
                                        ...style,
                                        color: e.target.value,
                                    },
                                })}
                                style={{ ...styles.input, width: '50px', padding: '2px' }}
                            />
                            <input
                                type="text"
                                value={style.color || '#FFFFFF'}
                                onChange={(e) => onChange({
                                    ...component,
                                    style: {
                                        ...style,
                                        color: e.target.value,
                                    },
                                })}
                                style={{ ...styles.input, flex: 1 }}
                                placeholder="#FFFFFF"
                            />
                        </div>
                    </div>
                    <div>
                        <label style={styles.sectionTitle}>Text Alignment</label>
                        <select
                            value={style.textAlign || 'center'}
                            onChange={(e) => onChange({
                                ...component,
                                style: {
                                    ...style,
                                    textAlign: e.target.value as 'left' | 'center' | 'right' | 'justify',
                                },
                            })}
                            style={styles.input}
                        >
                            <option value="left">Left</option>
                            <option value="center">Center</option>
                            <option value="right">Right</option>
                            <option value="justify">Justify</option>
                        </select>
                    </div>
                </div>
            </div>

            {/* Animation Settings */}
            <div style={{ marginTop: theme.spacing.lg }}>
                <h3 style={styles.sectionTitle}>Animation Settings</h3>
                <div style={styles.grid}>
                    <div>
                        <label style={styles.sectionTitle}>Entrance Animation</label>
                        <select
                            value={style.animation?.in?.type || 'none'}
                            onChange={(e) => onChange({
                                ...component,
                                style: {
                                    ...style,
                                    animation: {
                                        ...style.animation,
                                        in: {
                                            ...style.animation?.in,
                                            type: e.target.value,
                                            startFrame: style.animation?.in?.startFrame || 0,
                                            endFrame: style.animation?.in?.endFrame || 30,
                                        },
                                    },
                                },
                            })}
                            style={styles.input}
                        >
                            <option value="none">None</option>
                            <option value="slide-left">Slide In from Left</option>
                            <option value="slide-right">Slide In from Right</option>
                        </select>
                        {style.animation?.in?.type && style.animation.in.type !== 'none' && (
                            <div style={styles.animationTimingGrid}>
                                <div>
                                    <label style={styles.animationLabel}>Start Frame</label>
                                    <input
                                        type="number"
                                        value={style.animation?.in?.startFrame ?? 0}
                                        onChange={(e) => {
                                            const newValue = parseInt(e.target.value);
                                            if (!isNaN(newValue)) {
                                                console.log('Updating in animation start frame to:', newValue);
                                                const updatedStyle = {
                                                    ...style,
                                                    animation: {
                                                        ...style.animation,
                                                        in: {
                                                            ...style.animation?.in,
                                                            startFrame: newValue,
                                                        },
                                                    },
                                                };
                                                console.log('Updated style:', updatedStyle);
                                                onChange({
                                                    ...component,
                                                    style: updatedStyle,
                                                });
                                            }
                                        }}
                                        style={styles.animationInput}
                                        min="0"
                                    />
                                </div>
                                <div>
                                    <label style={styles.animationLabel}>End Frame</label>
                                    <input
                                        type="number"
                                        value={style.animation?.in?.endFrame ?? 30}
                                        onChange={(e) => {
                                            const newValue = parseInt(e.target.value);
                                            if (!isNaN(newValue)) {
                                                console.log('Updating in animation end frame to:', newValue);
                                                const updatedStyle = {
                                                    ...style,
                                                    animation: {
                                                        ...style.animation,
                                                        in: {
                                                            ...style.animation?.in,
                                                            endFrame: newValue,
                                                        },
                                                    },
                                                };
                                                console.log('Updated style:', updatedStyle);
                                                onChange({
                                                    ...component,
                                                    style: updatedStyle,
                                                });
                                            }
                                        }}
                                        style={styles.animationInput}
                                        min={style.animation?.in?.startFrame ?? 0}
                                    />
                                </div>
                            </div>
                        )}
                    </div>
                    <div>
                        <label style={styles.sectionTitle}>Exit Animation</label>
                        <select
                            value={style.animation?.out?.type || 'none'}
                            onChange={(e) => {
                                const updatedStyle = {
                                    ...style,
                                    animation: {
                                        ...style.animation,
                                        out: {
                                            ...style.animation?.out,
                                            type: e.target.value,
                                            startFrame: style.animation?.out?.startFrame ?? 30,
                                            endFrame: style.animation?.out?.endFrame ?? 0,
                                        },
                                    },
                                };
                                console.log('Updated exit animation style:', updatedStyle);
                                onChange({
                                    ...component,
                                    style: updatedStyle,
                                });
                            }}
                            style={styles.input}
                        >
                            <option value="none">None</option>
                            <option value="slide-left">Slide Out to Left</option>
                            <option value="slide-right">Slide Out to Right</option>
                        </select>
                        {style.animation?.out?.type && style.animation.out.type !== 'none' && (
                            <div style={styles.animationTimingGrid}>
                                <div>
                                    <label style={styles.animationLabel}>Start Frame (from end)</label>
                                    <input
                                        type="number"
                                        value={style.animation?.out?.startFrame ?? 30}
                                        onChange={(e) => {
                                            const newValue = parseInt(e.target.value);
                                            if (!isNaN(newValue)) {
                                                console.log('Updating out animation start frame to:', newValue);
                                                const updatedStyle = {
                                                    ...style,
                                                    animation: {
                                                        ...style.animation,
                                                        out: {
                                                            ...style.animation?.out,
                                                            startFrame: newValue,
                                                        },
                                                    },
                                                };
                                                console.log('Updated style:', updatedStyle);
                                                onChange({
                                                    ...component,
                                                    style: updatedStyle,
                                                });
                                            }
                                        }}
                                        style={styles.animationInput}
                                        min={style.animation?.out?.endFrame ?? 0}
                                    />
                                </div>
                                <div>
                                    <label style={styles.animationLabel}>End Frame (from end)</label>
                                    <input
                                        type="number"
                                        value={style.animation?.out?.endFrame ?? 0}
                                        onChange={(e) => {
                                            const newValue = parseInt(e.target.value);
                                            if (!isNaN(newValue)) {
                                                console.log('Updating out animation end frame to:', newValue);
                                                const updatedStyle = {
                                                    ...style,
                                                    animation: {
                                                        ...style.animation,
                                                        out: {
                                                            ...style.animation?.out,
                                                            endFrame: newValue,
                                                        },
                                                    },
                                                };
                                                console.log('Updated style:', updatedStyle);
                                                onChange({
                                                    ...component,
                                                    style: updatedStyle,
                                                });
                                            }
                                        }}
                                        style={styles.animationInput}
                                        min="0"
                                    />
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            </div>

            {/* Position */}
            <div style={{ marginTop: theme.spacing.lg }}>
                <div style={{
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    marginBottom: theme.spacing.sm,
                }}>
                    <h3 style={styles.sectionTitle}>Position</h3>
                    <button
                        onClick={() => setIsPositioningPopupOpen(true)}
                        style={{
                            backgroundColor: theme.colors.primary,
                            color: theme.colors.text.primary,
                            border: 'none',
                            borderRadius: '4px',
                            padding: '4px 8px',
                            cursor: 'pointer',
                            fontSize: '13px',
                        }}
                    >
                        Open Large Preview
                    </button>
                </div>
                <div style={{
                    width: '200px',
                    height: '356px',
                    backgroundColor: '#1a1a1a',
                    position: 'relative',
                    borderRadius: theme.borderRadius.sm,
                    overflow: 'hidden',
                    cursor: 'pointer',
                }}
                onClick={(e) => {
                    const rect = e.currentTarget.getBoundingClientRect();
                    const x = (e.clientX - rect.left) * 5.4;
                    const y = (e.clientY - rect.top) * 5.4;
                    handlePositionChange({ x, y });
                }}>
                    {/* Grid lines */}
                    <div style={{
                        position: 'absolute',
                        inset: 0,
                        backgroundImage: `
                            linear-gradient(to right, #333 1px, transparent 1px),
                            linear-gradient(to bottom, #333 1px, transparent 1px)
                        `,
                        backgroundSize: '20px 20px',
                        opacity: 0.5,
                        pointerEvents: 'none',
                    }} />

                    {/* Center dot */}
                    <div style={{
                        position: 'absolute',
                        left: (style.position?.x || 0) / 5.4,
                        top: (style.position?.y || 0) / 5.4,
                        width: 6,
                        height: 6,
                        backgroundColor: theme.colors.primary,
                        borderRadius: '50%',
                        transform: 'translate(-50%, -50%)',
                        pointerEvents: 'none',
                        boxShadow: '0 0 0 2px rgba(255, 255, 255, 0.3)',
                    }} />
                </div>
            </div>

            {/* Positioning Popup */}
            {isPositioningPopupOpen && (
                <PositioningScreen
                    component={component}
                    onPositionChange={handlePositionChange}
                    onClose={() => setIsPositioningPopupOpen(false)}
                />
            )}
        </>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\Timeline.tsx ---

import React, { useState, useRef, useEffect } from 'react';
import { Script, BaseScriptComponent, ComponentType } from '../../types/script';
import { theme } from '../../styles/theme';
import { createComponent } from '../../utils/componentFactory';

interface TimelineProps {
    script: Script;
    onReorder: (components: BaseScriptComponent[]) => void;
    onSelect: (id: string) => void;
    selectedId?: string;
    onDelete: (id: string) => void;
    zoom?: number;
}

const TRACK_HEIGHT = 40;
const PIXELS_PER_SECOND = 100;
const FRAMES_PER_SECOND = 30;
const NUM_TRACKS = 5;

export const Timeline: React.FC<TimelineProps> = ({
    script,
    onReorder,
    onSelect,
    selectedId,
    onDelete,
    zoom = 1,
}) => {
    const [draggingId, setDraggingId] = useState<string | null>(null);
    const [dragOffset, setDragOffset] = useState(0);
    const containerRef = useRef<HTMLDivElement>(null);

    // Calculate timeline width based on the maximum end time of all components
    const timelineWidth = Math.max(
        ...script.components.map(comp => {
            const start = comp.startFrame || 0;
            const duration = comp.durationInFrames || 150;
            return (start + duration) / FRAMES_PER_SECOND * PIXELS_PER_SECOND * zoom;
        }),
        PIXELS_PER_SECOND * 10 * zoom // Minimum width of 10 seconds
    );

    useEffect(() => {
        // Scroll to show the rightmost component if it's out of view
        if (containerRef.current) {
            const maxEndTime = Math.max(...script.components.map(comp => {
                const start = comp.startFrame || 0;
                const duration = comp.durationInFrames || 150;
                return start + duration;
            }));
            const scrollPosition = (maxEndTime / FRAMES_PER_SECOND) * PIXELS_PER_SECOND * zoom;
            const clientWidth = containerRef.current.clientWidth;

            if (scrollPosition > clientWidth) {
                containerRef.current.scrollLeft = scrollPosition - clientWidth + 100;
            }
        }
    }, [script.components, zoom]);

    const handleDragStart = (e: React.DragEvent, component: BaseScriptComponent) => {
        e.stopPropagation();
        const rect = e.currentTarget.getBoundingClientRect();
        const offsetX = e.clientX - rect.left;
        setDragOffset(Math.round((offsetX / (PIXELS_PER_SECOND * zoom)) * FRAMES_PER_SECOND));
        setDraggingId(component.id);
        e.dataTransfer.effectAllowed = 'move';
    };

    const handleDrop = (e: React.DragEvent, trackIndex: number) => {
        e.preventDefault();
        e.stopPropagation();
        
        const rect = containerRef.current?.getBoundingClientRect();
        if (!rect) return;

        const scrollLeft = containerRef.current?.scrollLeft || 0;
        const x = e.clientX - rect.left + scrollLeft;
        const startFrame = Math.round((x / (PIXELS_PER_SECOND * zoom)) * FRAMES_PER_SECOND);

        if (draggingId) {
            // Update existing component position
            const updatedComponents = script.components.map(comp => {
                if (comp.id === draggingId) {
                    const newStartFrame = Math.max(0, startFrame - dragOffset);
                    const newComp = {
                        ...comp,
                        startFrame: newStartFrame,
                        track: trackIndex,
                    };
                    
                    // Only handle style for text components
                    if (comp.type === 'text' && 'style' in comp) {
                        return {
                            ...newComp,
                            style: {
                                ...comp.style,
                                position: comp.style.position
                            }
                        };
                    }
                    
                    return newComp;
                }
                return comp;
            });
            onReorder(updatedComponents);
        } else {
            // Handle new component from palette
            const componentType = e.dataTransfer.getData('componentType') as ComponentType;
            if (componentType) {
                const newComponent = createComponent(
                    componentType,
                    script.settings.defaultTextStyle,
                    script.settings.defaultCaptionStyle
                );
                newComponent.startFrame = Math.max(0, startFrame);
                newComponent.track = trackIndex;
                onReorder([...script.components, newComponent]);
            }
        }
        setDraggingId(null);
        setDragOffset(0);
    };

    const handleDrag = (e: React.DragEvent, trackIndex: number) => {
        e.preventDefault();
        e.stopPropagation();
        
        if (!draggingId || !containerRef.current || !e.clientX) return;

        const rect = containerRef.current.getBoundingClientRect();
        const scrollLeft = containerRef.current.scrollLeft;
        const x = e.clientX - rect.left + scrollLeft;
        const newStartFrame = Math.max(0, Math.round((x / (PIXELS_PER_SECOND * zoom)) * FRAMES_PER_SECOND) - dragOffset);

        // Auto-scroll when dragging near the right edge
        const SCROLL_THRESHOLD = 100; // pixels from the right edge
        const SCROLL_SPEED = 10;
        
        if (e.clientX > rect.right - SCROLL_THRESHOLD) {
            containerRef.current.scrollLeft += SCROLL_SPEED;
        }

        const updatedComponents = script.components.map(comp => {
            if (comp.id === draggingId) {
                return {
                    ...comp,
                    startFrame: newStartFrame,
                    track: trackIndex
                };
            }
            return comp;
        });

        onReorder(updatedComponents);
    };

    // Calculate timeline width including extra space for dragging
    const timelineWidthIncludingExtraSpace = Math.max(
        containerRef.current?.clientWidth || 0,
        script.components.reduce((max, comp) => {
            const endFrame = comp.startFrame + comp.durationInFrames;
            return Math.max(max, endFrame);
        }, 0) * (PIXELS_PER_SECOND * zoom) / FRAMES_PER_SECOND + 500 // Add extra space
    );

    return (
        <div 
            ref={containerRef}
            style={{
                overflow: 'auto',
                backgroundColor: theme.colors.background.tertiary,
                borderRadius: theme.borderRadius.sm,
            }}
        >
            <div style={{
                width: `${timelineWidthIncludingExtraSpace}px`,
                minHeight: TRACK_HEIGHT * NUM_TRACKS,
                position: 'relative',
            }}>
                {/* Time markers */}
                <div style={{
                    height: '20px',
                    borderBottom: `1px solid ${theme.colors.border}`,
                    position: 'relative',
                }}>
                    {Array.from({ length: Math.ceil(timelineWidthIncludingExtraSpace / PIXELS_PER_SECOND) }).map((_, i) => (
                        <div
                            key={i}
                            style={{
                                position: 'absolute',
                                left: `${i * PIXELS_PER_SECOND}px`,
                                height: '100%',
                                borderLeft: `1px solid ${theme.colors.border}`,
                            }}
                        >
                            <span style={{
                                position: 'absolute',
                                top: '2px',
                                left: '4px',
                                fontSize: '10px',
                                color: theme.colors.text.secondary,
                            }}>
                                {i}s
                            </span>
                        </div>
                    ))}
                </div>

                {/* Tracks */}
                {Array.from({ length: NUM_TRACKS }).map((_, trackIndex) => (
                    <div
                        key={trackIndex}
                        style={{
                            height: TRACK_HEIGHT,
                            borderBottom: `1px solid ${theme.colors.border}`,
                            position: 'relative',
                            backgroundColor: theme.colors.background.secondary,
                        }}
                        onDragOver={(e) => {
                            e.preventDefault();
                            handleDrag(e, trackIndex);
                        }}
                        onDrop={(e) => handleDrop(e, trackIndex)}
                    >
                        {script.components
                            .filter(comp => (comp.track || 0) === trackIndex)
                            .map(component => (
                                <div
                                    key={component.id}
                                    draggable
                                    onClick={() => onSelect(component.id)}
                                    onDragStart={(e) => handleDragStart(e, component as BaseScriptComponent)}
                                    onDragEnd={() => setDraggingId(null)}
                                    style={{
                                        position: 'absolute',
                                        left: `${((component.startFrame || 0) / FRAMES_PER_SECOND) * PIXELS_PER_SECOND * zoom}px`,
                                        width: `${((component.durationInFrames || 150) / FRAMES_PER_SECOND) * PIXELS_PER_SECOND * zoom}px`,
                                        height: TRACK_HEIGHT - 2,
                                        backgroundColor: selectedId === component.id ? theme.colors.primary : theme.colors.secondary,
                                        borderRadius: theme.borderRadius.sm,
                                        cursor: 'grab',
                                        display: 'flex',
                                        alignItems: 'center',
                                        padding: '0 8px',
                                        fontSize: '12px',
                                        color: 'white',
                                        whiteSpace: 'nowrap',
                                        overflow: 'hidden',
                                        textOverflow: 'ellipsis',
                                        transition: theme.transitions.fast,
                                    }}
                                >
                                    {component.type}
                                </div>
                        ))}
                    </div>
                ))}
            </div>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\TitleComponentEditor.tsx ---

import React from 'react';
import { TitleComponent } from '../../types/script';
import { TextField, Grid } from '@mui/material';

interface TitleComponentEditorProps {
    component: TitleComponent;
    onChange: (component: TitleComponent) => void;
}

export const TitleComponentEditor: React.FC<TitleComponentEditorProps> = ({ component, onChange }) => {
    return (
        <Grid container spacing={2}>
            <Grid item xs={12}>
                <TextField
                    fullWidth
                    label="Title Text"
                    value={component.text}
                    onChange={(e) => onChange({
                        ...component,
                        text: e.target.value
                    })}
                />
            </Grid>
            <Grid item xs={12}>
                <TextField
                    fullWidth
                    label="Subtitle"
                    value={component.subtitle || ''}
                    onChange={(e) => onChange({
                        ...component,
                        subtitle: e.target.value
                    })}
                />
            </Grid>
        </Grid>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\VideoComponentEditor.tsx ---

import React from 'react';
import { VideoComponent, AnimationOptions } from '../../types/script';
import { theme } from '../../styles/theme';

interface VideoComponentEditorProps {
    component: VideoComponent;
    onChange: (updated: VideoComponent) => void;
}

export const VideoComponentEditor: React.FC<VideoComponentEditorProps> = ({
    component,
    onChange,
}) => {
    const handleStyleChange = (updated: Partial<VideoComponent['style']>) => {
        onChange({
            ...component,
            style: {
                ...component.style,
                ...updated
            }
        });
    };

    const handleAnimationChange = (updates: Partial<AnimationOptions>) => {
        const currentAnimation = component.style?.animation || {
            type: 'none',
            direction: 'in',
            easing: 'easeInOut',
            duration: 30,
            delay: 0,
            stagger: 0
        };
        handleStyleChange({
            animation: {
                ...currentAnimation,
                ...updates,
            }
        });
    };

    const handleChromakeyChange = (updates: Partial<NonNullable<VideoComponent['style']>['chromakey']>) => {
        const currentChromakey = component.style?.chromakey || {
            enabled: false,
            color: '#00ff00',
            similarity: 0.4,
            smoothness: 0.1
        };
        handleStyleChange({
            chromakey: {
                ...currentChromakey,
                ...updates,
            }
        });
    };

    return (
        <div style={styles.container}>
            {/* Video URL */}
            <div style={styles.section}>
                <label style={styles.label}>Video URL:</label>
                <input
                    type="text"
                    value={component.videoUrl}
                    onChange={(e) => {
                        onChange({
                            ...component,
                            videoUrl: e.target.value
                        });
                    }}
                    style={styles.input}
                    placeholder="Enter video URL (supports video files and GIFs)..."
                />
            </div>

            {/* Size and Position */}
            <div style={styles.section}>
                <h4 style={styles.sectionTitle}>Size & Position</h4>
                <div style={styles.settingsGrid}>
                    <div>
                        <label style={styles.label}>Width (%):</label>
                        <input
                            type="number"
                            min="1"
                            max="100"
                            value={component.style?.width || 100}
                            onChange={(e) => handleStyleChange({ width: Number(e.target.value) })}
                            style={styles.input}
                        />
                    </div>
                    <div>
                        <label style={styles.label}>Height (%):</label>
                        <input
                            type="number"
                            min="1"
                            max="100"
                            value={component.style?.height || 100}
                            onChange={(e) => handleStyleChange({ height: Number(e.target.value) })}
                            style={styles.input}
                        />
                    </div>
                </div>

                <div style={styles.settingsGrid}>
                    <div>
                        <label style={styles.label}>X Position (%):</label>
                        <input
                            type="range"
                            min="-100"
                            max="100"
                            value={component.style?.position?.x || 0}
                            onChange={(e) => handleStyleChange({
                                position: {
                                    x: Number(e.target.value),
                                    y: component.style?.position?.y || 0
                                }
                            })}
                            style={styles.input}
                        />
                    </div>
                    <div>
                        <label style={styles.label}>Y Position (%):</label>
                        <input
                            type="range"
                            min="-100"
                            max="100"
                            value={component.style?.position?.y || 0}
                            onChange={(e) => handleStyleChange({
                                position: {
                                    x: component.style?.position?.x || 0,
                                    y: Number(e.target.value)
                                }
                            })}
                            style={styles.input}
                        />
                    </div>
                </div>
            </div>

            {/* Transform */}
            <div style={styles.section}>
                <h4 style={styles.sectionTitle}>Transform</h4>
                <div style={styles.settingsGrid}>
                    <div>
                        <label style={styles.label}>Scale:</label>
                        <input
                            type="number"
                            min="0.1"
                            max="5"
                            step="0.1"
                            value={component.style?.scale || 1}
                            onChange={(e) => handleStyleChange({ scale: Number(e.target.value) })}
                            style={styles.input}
                        />
                    </div>
                    <div>
                        <label style={styles.label}>Rotation (deg):</label>
                        <input
                            type="number"
                            min="-360"
                            max="360"
                            value={component.style?.rotation || 0}
                            onChange={(e) => handleStyleChange({ rotation: Number(e.target.value) })}
                            style={styles.input}
                        />
                    </div>
                    <div>
                        <label style={styles.label}>Opacity:</label>
                        <input
                            type="range"
                            min="0"
                            max="1"
                            step="0.1"
                            value={component.style?.opacity || 1}
                            onChange={(e) => handleStyleChange({ opacity: Number(e.target.value) })}
                            style={styles.input}
                        />
                    </div>
                </div>
            </div>

            {/* Playback Settings */}
            <div style={styles.section}>
                <h4 style={styles.sectionTitle}>Playback Settings</h4>
                <div style={styles.settingsGrid}>
                    <div>
                        <label style={styles.label}>Volume:</label>
                        <input
                            type="range"
                            min="0"
                            max="1"
                            step="0.1"
                            value={component.style?.volume || 1}
                            onChange={(e) => handleStyleChange({ volume: Number(e.target.value) })}
                            style={styles.input}
                        />
                    </div>
                    <div>
                        <label style={styles.label}>Playback Rate:</label>
                        <input
                            type="number"
                            min="0.5"
                            max="2"
                            step="0.1"
                            value={component.style?.playbackRate || 1}
                            onChange={(e) => handleStyleChange({ playbackRate: Number(e.target.value) })}
                            style={styles.input}
                        />
                    </div>
                </div>
                <div style={styles.row}>
                    <label style={styles.checkboxLabel}>
                        <input
                            type="checkbox"
                            checked={component.style?.loop || false}
                            onChange={(e) => handleStyleChange({ loop: e.target.checked })}
                        />
                        Loop Video
                    </label>
                    <label style={styles.checkboxLabel}>
                        <input
                            type="checkbox"
                            checked={component.style?.muted || false}
                            onChange={(e) => handleStyleChange({ muted: e.target.checked })}
                        />
                        Mute Audio
                    </label>
                </div>
            </div>

            {/* Animation Controls */}
            <div style={styles.section}>
                <h4 style={styles.sectionTitle}>Animation</h4>
                <div style={styles.row}>
                    <select
                        value={component.style?.animation?.type ?? 'none'}
                        onChange={(e) => handleAnimationChange({ type: e.target.value as AnimationOptions['type'] })}
                        style={styles.input}
                    >
                        <option value="none">None</option>
                        <option value="fade">Fade</option>
                        <option value="scale">Scale</option>
                        <option value="rotate">Rotate</option>
                        <option value="slide">Slide</option>
                    </select>
                </div>
                {component.style?.animation?.type !== 'none' && (
                    <>
                        <div style={styles.row}>
                            <select
                                value={component.style?.animation?.direction ?? 'in'}
                                onChange={(e) => handleAnimationChange({ direction: e.target.value as AnimationOptions['direction'] })}
                                style={styles.input}
                            >
                                <option value="in">In</option>
                                <option value="out">Out</option>
                            </select>
                            <select
                                value={component.style?.animation?.easing ?? 'easeInOut'}
                                onChange={(e) => handleAnimationChange({ easing: e.target.value as AnimationOptions['easing'] })}
                                style={styles.input}
                            >
                                <option value="linear">Linear</option>
                                <option value="easeIn">Ease In</option>
                                <option value="easeOut">Ease Out</option>
                                <option value="easeInOut">Ease In Out</option>
                            </select>
                        </div>
                        <div style={styles.row}>
                            <input
                                type="number"
                                value={component.style?.animation?.duration ?? 30}
                                onChange={(e) => handleAnimationChange({ duration: Number(e.target.value) })}
                                placeholder="Duration (frames)"
                                min="1"
                                style={styles.input}
                            />
                            <input
                                type="number"
                                value={component.style?.animation?.delay ?? 0}
                                onChange={(e) => handleAnimationChange({ delay: Number(e.target.value) })}
                                placeholder="Delay (frames)"
                                min="0"
                                style={styles.input}
                            />
                            <input
                                type="number"
                                value={component.style?.animation?.stagger ?? 0}
                                onChange={(e) => handleAnimationChange({ stagger: Number(e.target.value) })}
                                placeholder="Stagger (frames)"
                                min="0"
                                style={styles.input}
                            />
                        </div>
                    </>
                )}
            </div>

            {/* Chromakey Settings */}
            <div style={styles.section}>
                <h4 style={styles.sectionTitle}>Chromakey</h4>
                <div style={styles.row}>
                    <label style={styles.checkboxLabel}>
                        <input
                            type="checkbox"
                            checked={component.style?.chromakey?.enabled || false}
                            onChange={(e) => handleChromakeyChange({ enabled: e.target.checked })}
                        />
                        Enable Chromakey
                    </label>
                </div>
                {component.style?.chromakey?.enabled && (
                    <>
                        <div style={styles.row}>
                            <div style={{ flex: 1 }}>
                                <label style={styles.label}>Color to Remove:</label>
                                <input
                                    type="color"
                                    value={component.style.chromakey.color || '#00ff00'}
                                    onChange={(e) => handleChromakeyChange({ color: e.target.value })}
                                    style={styles.input}
                                />
                            </div>
                        </div>
                        <div style={styles.settingsGrid}>
                            <div>
                                <label style={styles.label}>Color Similarity:</label>
                                <input
                                    type="range"
                                    min="0"
                                    max="1"
                                    step="0.01"
                                    value={component.style.chromakey.similarity || 0.4}
                                    onChange={(e) => handleChromakeyChange({ similarity: Number(e.target.value) })}
                                    style={styles.input}
                                />
                            </div>
                            <div>
                                <label style={styles.label}>Edge Smoothness:</label>
                                <input
                                    type="range"
                                    min="0"
                                    max="1"
                                    step="0.01"
                                    value={component.style.chromakey.smoothness || 0.1}
                                    onChange={(e) => handleChromakeyChange({ smoothness: Number(e.target.value) })}
                                    style={styles.input}
                                />
                            </div>
                        </div>
                    </>
                )}
            </div>
        </div>
    );
};

const styles = {
    container: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.md,
        height: '100%',
        backgroundColor: 'transparent',
    },
    section: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.sm,
        padding: theme.spacing.md,
        backgroundColor: theme.colors.background.secondary,
        borderRadius: theme.borderRadius.md,
        border: `1px solid ${theme.colors.border}`,
    },
    sectionTitle: {
        margin: '0 0 8px 0',
        color: theme.colors.text.primary,
        fontSize: '1rem',
        fontWeight: 600,
    },
    label: {
        fontSize: '0.9rem',
        fontWeight: 500,
        color: theme.colors.text.primary,
    },
    input: {
        padding: '0.5rem',
        borderRadius: theme.borderRadius.sm,
        border: `1px solid ${theme.colors.border}`,
        backgroundColor: theme.colors.background.tertiary,
        color: theme.colors.text.primary,
        width: '100%',
        minWidth: 0,
    },
    settingsGrid: {
        display: 'grid',
        gridTemplateColumns: '1fr 1fr',
        gap: theme.spacing.sm,
    },
    row: {
        display: 'flex',
        gap: theme.spacing.sm,
        alignItems: 'center',
        flexWrap: 'wrap' as const,
    },
    checkboxLabel: {
        display: 'flex',
        alignItems: 'center',
        gap: theme.spacing.sm,
        fontSize: '0.9rem',
        fontWeight: 500,
        color: theme.colors.text.primary,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\VoiceComponent.tsx ---

import React, { useState } from 'react';
import { VoiceComponent } from '../../types/script';
import { generateSpeech } from '../../services/elevenLabs';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';
import { DraggablePreview } from './DraggablePreview';

interface VoiceComponentEditorProps {
    component: VoiceComponent;
    onChange: (updated: VoiceComponent) => void;
}

type VoiceStatus = 'none' | 'generating' | 'success' | 'error';

const styles = {
    container: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: '20px',
    },
    section: {
        backgroundColor: theme.colors.background.secondary,
        padding: theme.spacing.lg,
        borderRadius: theme.borderRadius.md,
        border: `1px solid ${theme.colors.border}`,
    },
    label: {
        ...commonStyles.label,
        color: theme.colors.text.primary,
        display: 'block',
        marginBottom: theme.spacing.xs,
    },
    input: {
        ...commonStyles.input,
        backgroundColor: theme.colors.background.tertiary,
        border: `1px solid ${theme.colors.border}`,
        color: theme.colors.text.primary,
        padding: theme.spacing.sm,
        borderRadius: theme.borderRadius.sm,
        width: '100%',
    },
    button: {
        ...commonStyles.button.primary,
        display: 'flex',
        alignItems: 'center',
        gap: theme.spacing.sm,
        padding: `${theme.spacing.sm} ${theme.spacing.md}`,
    },
    grid: {
        display: 'grid',
        gridTemplateColumns: '1fr 1fr',
        gap: '20px',
    },
};

export const VoiceComponentEditor: React.FC<VoiceComponentEditorProps> = ({
    component,
    onChange,
}) => {
    const [voiceStatus, setVoiceStatus] = useState<VoiceStatus>(
        component.audioUrl ? 'success' : 'none'
    );
    const [errorMessage, setErrorMessage] = useState<string>('');
    const style = component.style || {};

    const handleVoiceGeneration = async () => {
        try {
            if (!component.text) {
                setErrorMessage('Please enter text for voice generation');
                return;
            }

            setVoiceStatus('generating');
            setErrorMessage('');
            
            const { audioUrl, wordTimings } = await generateSpeech({
                text: component.text,
                voiceId: component.voiceSettings?.voiceId || 'GhJYgP4Lrji0pwS3kQwv',
                settings: {
                    stability: component.voiceSettings?.stability || 0.75,
                    similarity_boost: component.voiceSettings?.similarity_boost || 0.75,
                },
            });

            onChange({
                ...component,
                audioUrl,
                wordTimings,
            });
            setVoiceStatus('success');
        } catch (error) {
            console.error('Voice generation failed:', error);
            setVoiceStatus('error');
            setErrorMessage(error instanceof Error ? error.message : 'Voice generation failed');
        }
    };

    const getStatusColor = () => {
        switch (voiceStatus) {
            case 'generating': return '#ffd700';
            case 'success': return '#4caf50';
            case 'error': return '#f44336';
            default: return '#007bff';
        }
    };

    return (
        <div style={styles.container}>
            {/* Voice Generation Section */}
            <div style={styles.section}>
                <h4 style={{ marginTop: 0 }}>Voice Generation</h4>
                <div style={{ marginBottom: theme.spacing.md }}>
                    <label style={styles.label}>Voice Text:</label>
                    <textarea
                        value={component.text}
                        onChange={(e) => onChange({
                            ...component,
                            text: e.target.value,
                        })}
                        style={{
                            ...styles.input,
                            minHeight: '100px',
                        }}
                        placeholder="Enter text for voice generation..."
                    />
                </div>

                <div style={styles.grid}>
                    <div>
                        <label style={styles.label}>Voice:</label>
                        <select
                            value={component.voiceSettings?.voiceId}
                            onChange={(e) => onChange({
                                ...component,
                                voiceSettings: {
                                    ...component.voiceSettings,
                                    voiceId: e.target.value,
                                },
                            })}
                            style={styles.input}
                        >
                            <option value="GhJYgP4Lrji0pwS3kQwv">Josh (Default)</option>
                            <option value="21m00Tcm4TlvDq8ikWAM">Rachel</option>
                            <option value="AZnzlk1XvdvUeBnXmlld">Domi</option>
                            <option value="EXAVITQu4vr4xnSDxMaL">Bella</option>
                            <option value="MF3mGyEYCl7XYWbV9V6O">Elli</option>
                        </select>
                    </div>

                    <div>
                        <label style={styles.label}>Stability:</label>
                        <input
                            type="range"
                            min="0"
                            max="100"
                            value={((component.voiceSettings?.stability || 0.75) * 100)}
                            onChange={(e) => onChange({
                                ...component,
                                voiceSettings: {
                                    ...component.voiceSettings,
                                    stability: parseInt(e.target.value) / 100,
                                },
                            })}
                            style={styles.input}
                        />
                    </div>

                    <div>
                        <label style={styles.label}>Similarity Boost:</label>
                        <input
                            type="range"
                            min="0"
                            max="100"
                            value={((component.voiceSettings?.similarity_boost || 0.75) * 100)}
                            onChange={(e) => onChange({
                                ...component,
                                voiceSettings: {
                                    ...component.voiceSettings,
                                    similarity_boost: parseInt(e.target.value) / 100,
                                },
                            })}
                            style={styles.input}
                        />
                    </div>
                </div>

                <div style={{ marginTop: theme.spacing.md }}>
                    <button
                        onClick={handleVoiceGeneration}
                        disabled={voiceStatus === 'generating'}
                        style={{
                            ...styles.button,
                            backgroundColor: getStatusColor(),
                        }}
                    >
                        {voiceStatus === 'generating' && (
                            <div style={{
                                width: '16px',
                                height: '16px',
                                border: '2px solid white',
                                borderTop: '2px solid transparent',
                                borderRadius: '50%',
                                animation: 'spin 1s linear infinite',
                            }}>
                                <style>
                                    {`
                                        @keyframes spin {
                                            0% { transform: rotate(0deg); }
                                            100% { transform: rotate(360deg); }
                                        }
                                    `}
                                </style>
                            </div>
                        )}
                        {voiceStatus === 'generating' ? 'Generating...' : 
                         voiceStatus === 'success' ? 'Regenerate Voice' : 
                         voiceStatus === 'error' ? 'Try Again' : 
                         'Generate Voice'}
                    </button>
                    {voiceStatus === 'success' && (
                        <span style={{ color: '#4caf50', marginLeft: '10px' }}>✓ Voice generated successfully</span>
                    )}
                    {voiceStatus === 'error' && (
                        <span style={{ color: '#f44336', marginLeft: '10px' }}>⚠️ {errorMessage}</span>
                    )}
                </div>

                {/* Audio Preview */}
                {component.audioUrl && (
                    <div style={{ marginTop: theme.spacing.md }}>
                        <label style={styles.label}>Preview Audio:</label>
                        <audio
                            controls
                            src={component.audioUrl}
                            style={{ width: '100%' }}
                        />
                    </div>
                )}
            </div>

            {/* Caption Settings */}
            <div style={styles.section}>
                <div style={{ 
                    display: 'flex', 
                    alignItems: 'center', 
                    gap: theme.spacing.md,
                    marginBottom: theme.spacing.md 
                }}>
                    <h4 style={{ margin: 0 }}>Caption Settings</h4>
                    <label style={{
                        display: 'flex',
                        alignItems: 'center',
                        gap: theme.spacing.sm,
                    }}>
                        <input
                            type="checkbox"
                            checked={component.showCaptions}
                            onChange={(e) => onChange({
                                ...component,
                                showCaptions: e.target.checked,
                            })}
                        />
                        Show Captions
                    </label>
                </div>

                {component.showCaptions && (
                    <>
                        {/* Text Styling */}
                        <div style={styles.grid}>
                            <div>
                                <label style={styles.label}>Font Size:</label>
                                <input
                                    type="number"
                                    value={style.fontSize || 24}
                                    onChange={(e) => onChange({
                                        ...component,
                                        style: {
                                            ...style,
                                            fontSize: parseInt(e.target.value),
                                        },
                                    })}
                                    style={styles.input}
                                    min="12"
                                    max="72"
                                />
                            </div>

                            <div>
                                <label style={styles.label}>Font Family:</label>
                                <select
                                    value={style.fontFamily || 'Arial'}
                                    onChange={(e) => onChange({
                                        ...component,
                                        style: {
                                            ...style,
                                            fontFamily: e.target.value,
                                        },
                                    })}
                                    style={styles.input}
                                >
                                    <option value="Arial">Arial</option>
                                    <option value="Times New Roman">Times New Roman</option>
                                    <option value="Helvetica">Helvetica</option>
                                    <option value="Georgia">Georgia</option>
                                    <option value="Verdana">Verdana</option>
                                </select>
                            </div>

                            <div>
                                <label style={styles.label}>Text Color:</label>
                                <input
                                    type="color"
                                    value={style.color || '#ffffff'}
                                    onChange={(e) => onChange({
                                        ...component,
                                        style: {
                                            ...style,
                                            color: e.target.value,
                                        },
                                    })}
                                    style={styles.input}
                                />
                            </div>

                            <div>
                                <label style={styles.label}>Background Color:</label>
                                <input
                                    type="color"
                                    value={component.captionStyle?.backgroundColor || '#000000'}
                                    onChange={(e) => onChange({
                                        ...component,
                                        captionStyle: {
                                            ...component.captionStyle,
                                            backgroundColor: e.target.value,
                                        },
                                    })}
                                    style={styles.input}
                                />
                            </div>

                            <div>
                                <label style={styles.label}>Font Weight:</label>
                                <select
                                    value={style.fontWeight || 'normal'}
                                    onChange={(e) => onChange({
                                        ...component,
                                        style: {
                                            ...style,
                                            fontWeight: e.target.value,
                                        },
                                    })}
                                    style={styles.input}
                                >
                                    <option value="normal">Normal</option>
                                    <option value="bold">Bold</option>
                                    <option value="lighter">Light</option>
                                </select>
                            </div>

                            <div>
                                <label style={styles.label}>Text Alignment:</label>
                                <select
                                    value={style.textAlign || 'center'}
                                    onChange={(e) => onChange({
                                        ...component,
                                        style: {
                                            ...style,
                                            textAlign: e.target.value as 'left' | 'center' | 'right',
                                        },
                                    })}
                                    style={styles.input}
                                >
                                    <option value="left">Left</option>
                                    <option value="center">Center</option>
                                    <option value="right">Right</option>
                                </select>
                            </div>
                        </div>

                        {/* Position Preview */}
                        <div style={{ marginTop: theme.spacing.lg }}>
                            <h4 style={{ marginBottom: '10px' }}>Position & Preview</h4>
                            <DraggablePreview
                                text={component.text}
                                style={style}
                                onChange={(updates) => onChange({
                                    ...component,
                                    style: {
                                        ...style,
                                        ...updates,
                                    },
                                })}
                            />
                        </div>
                    </>
                )}
            </div>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\VoiceComponentEditor.tsx ---

import React, { useState } from 'react';
import { VoiceComponent } from '../../types/script';
import { generateSpeech, generateCaptions } from '../../services/elevenLabs';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';
import { CaptionPositioningScreen } from './CaptionPositioningScreen';

interface VoiceComponentEditorProps {
    component: VoiceComponent;
    onChange: (updated: VoiceComponent) => void;
}

type VoiceStatus = 'none' | 'generating' | 'success' | 'error';

const styles = {
    container: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: '20px',
    },
    section: {
        backgroundColor: theme.colors.background.secondary,
        padding: theme.spacing.lg,
        borderRadius: theme.borderRadius.md,
        border: `1px solid ${theme.colors.border}`,
    },
    label: {
        ...commonStyles.label,
        color: theme.colors.text.primary,
        display: 'block',
        marginBottom: theme.spacing.xs,
    },
    input: {
        ...commonStyles.input,
        backgroundColor: theme.colors.background.tertiary,
        border: `1px solid ${theme.colors.border}`,
        color: theme.colors.text.primary,
        padding: theme.spacing.sm,
        borderRadius: theme.borderRadius.sm,
        width: '100%',
    },
    button: {
        ...commonStyles.button.primary,
        display: 'flex',
        alignItems: 'center',
        gap: theme.spacing.sm,
        padding: `${theme.spacing.sm} ${theme.spacing.md}`,
    },
    grid: {
        display: 'grid',
        gridTemplateColumns: '1fr 1fr',
        gap: '20px',
    },
    modal: {
        position: 'fixed' as const,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        zIndex: 1000,
    },
    modalContent: {
        backgroundColor: '#fff',
        padding: theme.spacing.lg,
        borderRadius: theme.borderRadius.md,
        maxWidth: '90%',
        maxHeight: '90%',
        overflow: 'auto',
        position: 'relative' as const,
    },
};

export const VoiceComponentEditor: React.FC<VoiceComponentEditorProps> = ({
    component,
    onChange,
}) => {
    const [voiceStatus, setVoiceStatus] = useState<VoiceStatus>(
        component.audioUrl ? 'success' : 'none'
    );
    const [errorMessage, setErrorMessage] = useState<string>('');
    const [showPositioningScreen, setShowPositioningScreen] = useState(false);
    const style = component.style || {};

    const handleVoiceGeneration = async () => {
        try {
            if (!component.text) {
                setErrorMessage('Please enter text for voice generation');
                return;
            }

            setVoiceStatus('generating');
            setErrorMessage('');
            
            // Generate speech with the new interface
            const { audioUrl } = await generateSpeech({
                text: component.text,
                voiceId: component.voiceSettings?.voiceId || 'GhJYgP4Lrji0pwS3kQwv',
                settings: {
                    stability: component.voiceSettings?.stability || 0.75,
                    similarity_boost: component.voiceSettings?.similarity_boost || 0.75
                }
            });

            onChange({
                ...component,
                audioUrl,
                // Note: wordTimings are now included in the generateSpeech response
            });
            setVoiceStatus('success');
        } catch (error) {
            console.error('Voice generation failed:', error);
            setVoiceStatus('error');
            setErrorMessage(error instanceof Error ? error.message : 'Voice generation failed');
        }
    };

    const getStatusColor = () => {
        switch (voiceStatus) {
            case 'generating': return '#ffd700';
            case 'success': return '#4caf50';
            case 'error': return '#f44336';
            default: return '#007bff';
        }
    };

    return (
        <div style={styles.container}>
            {/* Voice Generation Section */}
            <div style={styles.section}>
                <h4 style={{ marginTop: 0 }}>Voice Generation</h4>
                <div style={{ marginBottom: theme.spacing.md }}>
                    <label style={styles.label}>Voice Text:</label>
                    <textarea
                        value={component.text}
                        onChange={(e) => onChange({
                            ...component,
                            text: e.target.value,
                        })}
                        style={{
                            ...styles.input,
                            minHeight: '100px',
                        }}
                        placeholder="Enter text for voice generation..."
                    />
                </div>

                <div style={styles.grid}>
                    <div>
                        <label style={styles.label}>Voice:</label>
                        <select
                            value={component.voiceSettings?.voiceId}
                            onChange={(e) => onChange({
                                ...component,
                                voiceSettings: {
                                    ...component.voiceSettings,
                                    voiceId: e.target.value,
                                },
                            })}
                            style={styles.input}
                        >
                            <option value="GhJYgP4Lrji0pwS3kQwv">Josh (Default)</option>
                            <option value="21m00Tcm4TlvDq8ikWAM">Rachel</option>
                            <option value="AZnzlk1XvdvUeBnXmlld">Domi</option>
                            <option value="EXAVITQu4vr4xnSDxMaL">Bella</option>
                            <option value="MF3mGyEYCl7XYWbV9V6O">Elli</option>
                        </select>
                    </div>

                    <div>
                        <label style={styles.label}>Stability:</label>
                        <input
                            type="range"
                            min="0"
                            max="100"
                            value={((component.voiceSettings?.stability || 0.75) * 100)}
                            onChange={(e) => onChange({
                                ...component,
                                voiceSettings: {
                                    ...component.voiceSettings,
                                    stability: parseInt(e.target.value) / 100,
                                },
                            })}
                            style={styles.input}
                        />
                    </div>
                </div>

                <div style={{ marginTop: theme.spacing.md }}>
                    <button
                        onClick={handleVoiceGeneration}
                        style={{
                            ...styles.button,
                            backgroundColor: getStatusColor(),
                        }}
                        disabled={voiceStatus === 'generating'}
                    >
                        {voiceStatus === 'generating' ? 'Generating...' : 'Generate Voice'}
                    </button>
                    {errorMessage && (
                        <div style={{ color: theme.colors.error, marginTop: theme.spacing.sm }}>
                            {errorMessage}
                        </div>
                    )}
                </div>

                {component.audioUrl && (
                    <div style={{ marginTop: theme.spacing.md }}>
                        <label style={styles.label}>Preview Audio:</label>
                        <audio
                            controls
                            src={component.audioUrl}
                            style={{ width: '100%' }}
                        />
                        
                        <div style={{ marginTop: theme.spacing.md }}>
                            <button
                                onClick={async () => {
                                    try {
                                        if (!component.audioUrl) return;

                                        // Get the audio file as a blob
                                        const response = await fetch(component.audioUrl);
                                        const audioBlob = await response.blob();
                                        
                                        // Create form data for transcription
                                        const formData = new FormData();
                                        formData.append('audio', audioBlob, 'speech.mp3');
                                        
                                        // Send to Whisper service
                                        const transcriptionResponse = await fetch('http://localhost:5000/transcribe', {
                                            method: 'POST',
                                            body: formData
                                        });

                                        if (!transcriptionResponse.ok) {
                                            throw new Error('Failed to generate captions');
                                        }

                                        const transcriptionData = await transcriptionResponse.json();
                                        
                                        // Update the component with captions
                                        onChange({
                                            ...component,
                                            wordTimings: transcriptionData.wordTimings,
                                            showCaptions: true,
                                            captionStyle: {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            }
                                        });
                                    } catch (error) {
                                        console.error('Error generating captions:', error);
                                        setErrorMessage('Failed to generate captions');
                                    }
                                }}
                                style={styles.button}
                                disabled={!component.audioUrl}
                            >
                                Generate Captions
                            </button>
                        </div>
                    </div>
                )}

                {/* Caption Settings */}
                {component.wordTimings && (
                    <div style={styles.section}>
                        <div style={{ 
                            display: 'flex', 
                            alignItems: 'center', 
                            gap: theme.spacing.md,
                            marginBottom: theme.spacing.md 
                        }}>
                            <h4 style={{ margin: 0 }}>Caption Settings</h4>
                            <label style={{
                                display: 'flex',
                                alignItems: 'center',
                                gap: theme.spacing.sm,
                                color: theme.colors.text.primary,
                            }}>
                                <input
                                    type="checkbox"
                                    checked={component.showCaptions}
                                    onChange={(e) => onChange({
                                        ...component,
                                        showCaptions: e.target.checked
                                    })}
                                />
                                Show Captions
                            </label>
                        </div>

                        {component.showCaptions && (
                            <div style={{ display: 'flex', flexDirection: 'column', gap: theme.spacing.md }}>
                                <div>
                                    <label style={styles.label}>Font Family:</label>
                                    <select
                                        value={component.captionStyle?.fontFamily || 'Arial'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    fontFamily: e.target.value
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    >
                                        <option value="Arial">Arial</option>
                                        <option value="Times New Roman">Times New Roman</option>
                                        <option value="Courier New">Courier New</option>
                                        <option value="Georgia">Georgia</option>
                                        <option value="Verdana">Verdana</option>
                                    </select>
                                </div>

                                <div>
                                    <label style={styles.label}>Font Size:</label>
                                    <input
                                        type="number"
                                        value={component.captionStyle?.fontSize || 24}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    fontSize: parseInt(e.target.value)
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <div>
                                    <label style={styles.label}>Font Weight:</label>
                                    <select
                                        value={component.captionStyle?.fontWeight || 'normal'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    fontWeight: e.target.value
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    >
                                        <option value="normal">Normal</option>
                                        <option value="bold">Bold</option>
                                        <option value="100">100</option>
                                        <option value="200">200</option>
                                        <option value="300">300</option>
                                        <option value="400">400</option>
                                        <option value="500">500</option>
                                        <option value="600">600</option>
                                        <option value="700">700</option>
                                        <option value="800">800</option>
                                        <option value="900">900</option>
                                    </select>
                                </div>

                                <div>
                                    <label style={styles.label}>Font Style:</label>
                                    <select
                                        value={component.captionStyle?.fontStyle || 'normal'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    fontStyle: e.target.value as 'normal' | 'italic'
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    >
                                        <option value="normal">Normal</option>
                                        <option value="italic">Italic</option>
                                    </select>
                                </div>

                                <div>
                                    <label style={styles.label}>Text Color:</label>
                                    <input
                                        type="color"
                                        value={component.captionStyle?.color || '#ffffff'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    color: e.target.value
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <div>
                                    <label style={styles.label}>Background Color:</label>
                                    <input
                                        type="color"
                                        value={component.captionStyle?.backgroundColor || 'rgba(0, 0, 0, 0.7)'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    backgroundColor: e.target.value
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <div>
                                    <label style={styles.label}>Position:</label>
                                    <select
                                        value={component.captionStyle?.position || 'bottom'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    position: e.target.value as 'top' | 'bottom'
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    >
                                        <option value="top">Top</option>
                                        <option value="bottom">Bottom</option>
                                    </select>
                                </div>

                                <div>
                                    <label style={styles.label}>Word Window:</label>
                                    <input
                                        type="number"
                                        min="1"
                                        max="10"
                                        value={component.captionStyle?.wordWindow || 1}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    wordWindow: parseInt(e.target.value)
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <div>
                                    <label style={styles.label}>Border Radius:</label>
                                    <input
                                        type="text"
                                        value={component.captionStyle?.borderRadius || '5px'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    borderRadius: e.target.value
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <div>
                                    <label style={styles.label}>Padding:</label>
                                    <input
                                        type="text"
                                        value={component.captionStyle?.padding || '10px 20px'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    padding: e.target.value
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <div>
                                    <label style={styles.label}>Box Shadow:</label>
                                    <input
                                        type="text"
                                        value={component.captionStyle?.boxShadow || 'none'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    boxShadow: e.target.value
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <div>
                                    <label style={styles.label}>Opacity:</label>
                                    <input
                                        type="range"
                                        min="0"
                                        max="1"
                                        step="0.1"
                                        value={component.captionStyle?.opacity || 1}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    opacity: parseFloat(e.target.value)
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <button
                                    onClick={() => setShowPositioningScreen(true)}
                                    style={styles.button}
                                >
                                    Open Positioning Screen
                                </button>

                                {showPositioningScreen && (
                                    <div style={styles.modal}>
                                        <div style={styles.modalContent}>
                                            <CaptionPositioningScreen
                                                style={component.captionStyle || {
                                                    fontSize: 24,
                                                    color: '#ffffff',
                                                    backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                    position: 'bottom',
                                                    wordWindow: 1
                                                }}
                                                onChange={(newStyle) => {
                                                    onChange({
                                                        ...component,
                                                        captionStyle: newStyle
                                                    });
                                                }}
                                            />
                                            <button
                                                onClick={() => setShowPositioningScreen(false)}
                                                style={styles.button}
                                            >
                                                Close
                                            </button>
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}
                    </div>
                )}
            </div>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\VoiceOverEditor.tsx ---

import React, { useState } from 'react';
import { ScriptComponent } from '../../types/script';
import { generateSpeech } from '../../services/elevenLabs';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';

interface VoiceOverEditorProps {
    component: ScriptComponent;
    onChange: (updated: ScriptComponent) => void;
}

type VoiceStatus = 'none' | 'generating' | 'success' | 'error';

const styles = {
    section: {
        backgroundColor: theme.colors.background.secondary,
        padding: theme.spacing.lg,
        borderRadius: theme.borderRadius.md,
        border: `1px solid ${theme.colors.border}`,
    },
    label: {
        ...commonStyles.label,
        color: theme.colors.text.primary,
        display: 'block',
        marginBottom: theme.spacing.xs,
    },
    input: {
        ...commonStyles.input,
        backgroundColor: theme.colors.background.tertiary,
        border: `1px solid ${theme.colors.border}`,
        color: theme.colors.text.primary,
        padding: theme.spacing.sm,
        borderRadius: theme.borderRadius.sm,
        width: '100%',
    },
    button: {
        ...commonStyles.button.primary,
        display: 'flex',
        alignItems: 'center',
        gap: theme.spacing.sm,
        padding: `${theme.spacing.sm} ${theme.spacing.md}`,
    },
};

export const VoiceOverEditor: React.FC<VoiceOverEditorProps> = ({
    component,
    onChange,
}) => {
    const [voiceStatus, setVoiceStatus] = useState<VoiceStatus>(
        component.voiceOver?.audioUrl ? 'success' : 'none'
    );
    const [errorMessage, setErrorMessage] = useState<string>('');

    const getComponentText = (comp: ScriptComponent): string => {
        switch (comp.type) {
            case 'comparison':
                return comp.question;
            case 'text':
            case 'title':
                return comp.text;
            default:
                return '';
        }
    };

    const handleVoiceGeneration = async () => {
        try {
            const text = getComponentText(component);
            if (!text) {
                setErrorMessage('No text available for voice generation');
                return;
            }

            setVoiceStatus('generating');
            setErrorMessage('');
            
            const { audioUrl, wordTimings } = await generateSpeech({
                text,
                voiceId: component.voiceOver?.voiceId || 'default',
                settings: {
                    stability: 0.75,
                    similarity_boost: 0.75,
                },
            });

            onChange({
                ...component,
                voiceOver: {
                    text,
                    audioUrl,
                    wordTimings,
                    voiceId: component.voiceOver?.voiceId || 'default',
                    settings: {
                        stability: 0.75,
                        similarity_boost: 0.75,
                    },
                },
            });
            setVoiceStatus('success');
        } catch (error) {
            console.error('Voice generation failed:', error);
            setVoiceStatus('error');
            setErrorMessage(error instanceof Error ? error.message : 'Voice generation failed');
        }
    };

    const getStatusColor = () => {
        switch (voiceStatus) {
            case 'generating': return '#ffd700';
            case 'success': return '#4caf50';
            case 'error': return '#f44336';
            default: return '#007bff';
        }
    };

    return (
        <div style={styles.section}>
            <div style={{
                display: 'flex',
                alignItems: 'center',
                gap: theme.spacing.md,
                marginBottom: theme.spacing.md,
            }}>
                <h3 style={{ margin: 0 }}>Voice Over</h3>
                <button
                    onClick={handleVoiceGeneration}
                    disabled={voiceStatus === 'generating'}
                    style={{
                        ...styles.button,
                        backgroundColor: getStatusColor(),
                    }}
                >
                    {voiceStatus === 'generating' && (
                        <div style={{
                            width: '16px',
                            height: '16px',
                            border: '2px solid white',
                            borderTop: '2px solid transparent',
                            borderRadius: '50%',
                            animation: 'spin 1s linear infinite',
                        }}>
                            <style>
                                {`
                                    @keyframes spin {
                                        0% { transform: rotate(0deg); }
                                        100% { transform: rotate(360deg); }
                                    }
                                `}
                            </style>
                        </div>
                    )}
                    {voiceStatus === 'generating' ? 'Generating...' : 
                     voiceStatus === 'success' ? 'Regenerate Voice' : 
                     voiceStatus === 'error' ? 'Try Again' : 
                     'Generate Voice'}
                </button>
                {voiceStatus === 'success' && (
                    <span style={{ color: '#4caf50' }}>✓ Voice generated successfully</span>
                )}
                {voiceStatus === 'error' && (
                    <span style={{ color: '#f44336' }}>⚠️ {errorMessage}</span>
                )}
            </div>

            {/* Caption Settings */}
            <div style={{ marginBottom: theme.spacing.md }}>
                <label style={{
                    ...styles.label,
                    display: 'flex',
                    alignItems: 'center',
                    gap: theme.spacing.sm,
                }}>
                    <input
                        type="checkbox"
                        checked={component.captions?.enabled ?? false}
                        onChange={(e) => onChange({
                            ...component,
                            captions: e.target.checked ? {
                                enabled: true,
                                displayMode: 'sync',
                                style: {
                                    fontSize: 24,
                                    color: 'white',
                                    textAlign: 'center',
                                },
                            } : undefined,
                        })}
                    />
                    Enable Captions
                </label>
            </div>

            {/* Audio Preview */}
            {component.voiceOver?.audioUrl && (
                <div style={{
                    marginTop: theme.spacing.md,
                    padding: theme.spacing.md,
                    backgroundColor: theme.colors.background.tertiary,
                    borderRadius: theme.borderRadius.md,
                }}>
                    <label style={styles.label}>Preview Audio:</label>
                    <audio
                        controls
                        src={component.voiceOver.audioUrl}
                        style={{ width: '100%' }}
                    />
                </div>
            )}
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Settings\BackgroundManager.tsx ---

import React, { useState, useEffect } from 'react';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';

interface BackgroundHistory {
    name: string;
    url: string;
    addedAt: string;
    type: 'image' | 'video' | 'none';
}

interface BackgroundManagerProps {
    onSelectBackground: (background: { 
        type: 'image' | 'video' | 'none'; 
        url?: string; 
        filePath?: string;
        durationInFrames?: number;
    }) => void;
}

export const BackgroundManager: React.FC<BackgroundManagerProps> = ({ onSelectBackground }) => {
    const [backgrounds, setBackgrounds] = useState<BackgroundHistory[]>([]);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);

    const loadBackgrounds = async () => {
        try {
            setLoading(true);
            const response = await fetch('http://localhost:3002/backgrounds/history');
            if (!response.ok) throw new Error('Failed to load backgrounds');
            const data = await response.json();
            setBackgrounds(data);
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to load backgrounds');
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        loadBackgrounds();
    }, []);

    const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (!file) return;

        const formData = new FormData();
        formData.append('file', file);

        try {
            setLoading(true);
            const response = await fetch('http://localhost:3002/set_background', {
                method: 'POST',
                body: formData,
            });

            if (!response.ok) throw new Error('Failed to upload background');
            
            const data = await response.json();
            await loadBackgrounds(); // Refresh the list
            
            // Select the newly uploaded background
            onSelectBackground({
                type: 'image',
                url: data.url,
                filePath: data.filePath
            });
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to upload background');
        } finally {
            setLoading(false);
        }
    };

    const handleRemoveBackground = async (name: string) => {
        try {
            setLoading(true);
            const response = await fetch('http://localhost:3002/remove_background', {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ name }),
            });

            if (!response.ok) throw new Error('Failed to remove background');
            await loadBackgrounds(); // Refresh the list
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to remove background');
        } finally {
            setLoading(false);
        }
    };

    return (
        <div style={styles.container}>
            <div style={styles.header}>
                <h3 style={styles.title}>Background Manager</h3>
                <input
                    type="file"
                    accept="image/*"
                    onChange={handleFileUpload}
                    style={{ display: 'none' }}
                    id="background-upload"
                />
                <label htmlFor="background-upload" style={styles.uploadButton}>
                    Upload New Background
                </label>
            </div>

            {error && <div style={styles.error}>{error}</div>}

            <div style={styles.grid}>
                {/* No Background Option */}
                <div 
                    style={styles.backgroundItem}
                    onClick={() => onSelectBackground({ type: 'none', url: '', filePath: '' })}
                >
                    <div style={styles.noBackgroundPreview}>
                        No Background
                    </div>
                    <div style={styles.backgroundName}>None</div>
                </div>

                {backgrounds.map((bg) => (
                    <div key={bg.name} style={styles.backgroundItem}>
                        <div 
                            style={styles.imagePreview}
                            onClick={() => onSelectBackground({
                                type: 'image',
                                url: bg.url,
                                filePath: bg.name
                            })}
                        >
                            <img src={bg.url} alt={bg.name} style={styles.previewImage} />
                        </div>
                        <div style={styles.backgroundInfo}>
                            <div style={styles.backgroundName}>{bg.name}</div>
                            <button
                                onClick={(e) => {
                                    e.stopPropagation();
                                    handleRemoveBackground(bg.name);
                                }}
                                style={styles.removeButton}
                            >
                                Remove
                            </button>
                        </div>
                    </div>
                ))}
            </div>

            {loading && <div style={styles.loading}>Loading...</div>}
        </div>
    );
};

const styles = {
    container: {
        padding: theme.spacing.md,
    },
    header: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: theme.spacing.lg,
    },
    title: {
        margin: 0,
        color: theme.colors.text.primary,
    },
    uploadButton: {
        ...commonStyles.button.primary,
        cursor: 'pointer',
    },
    grid: {
        display: 'grid',
        gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))',
        gap: theme.spacing.md,
        marginTop: theme.spacing.md,
    },
    backgroundItem: {
        border: `1px solid ${theme.colors.border}`,
        borderRadius: theme.borderRadius.md,
        overflow: 'hidden',
        backgroundColor: theme.colors.background.secondary,
    },
    imagePreview: {
        width: '100%',
        height: '150px',
        backgroundColor: theme.colors.background.tertiary,
        cursor: 'pointer',
        position: 'relative' as const,
    },
    noBackgroundPreview: {
        width: '100%',
        height: '150px',
        backgroundColor: theme.colors.background.tertiary,
        cursor: 'pointer',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        color: theme.colors.text.secondary,
    },
    previewImage: {
        width: '100%',
        height: '100%',
        objectFit: 'cover' as const,
    },
    backgroundInfo: {
        padding: theme.spacing.sm,
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
    },
    backgroundName: {
        color: theme.colors.text.primary,
        fontSize: '0.9em',
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap' as const,
    },
    removeButton: {
        ...commonStyles.button.secondary,
        color: theme.colors.error,
        padding: '4px 8px',
        fontSize: '0.8em',
    },
    error: {
        color: theme.colors.error,
        marginBottom: theme.spacing.md,
        padding: theme.spacing.sm,
        backgroundColor: 'rgba(244, 67, 54, 0.1)',
        borderRadius: theme.borderRadius.sm,
    },
    loading: {
        textAlign: 'center' as const,
        color: theme.colors.text.secondary,
        marginTop: theme.spacing.md,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Settings\FontManager.tsx ---

import React, { useState, useEffect } from 'react';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';

interface FontManagerProps {
    onClose: () => void;
}

interface CustomFont {
    name: string;
    url: string;
    format: 'truetype' | 'opentype';
}

const styles = {
    modal: {
        position: 'fixed' as const,
        top: '50%',
        left: '50%',
        transform: 'translate(-50%, -50%)',
        backgroundColor: theme.colors.background.secondary,
        padding: theme.spacing.xl,
        borderRadius: theme.borderRadius.lg,
        boxShadow: theme.shadows.lg,
        width: '90%',
        maxWidth: '600px',
        maxHeight: '80vh',
        overflow: 'auto',
        zIndex: 1000,
    },
    overlay: {
        position: 'fixed' as const,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.7)',
        zIndex: 999,
    },
    title: {
        margin: 0,
        marginBottom: theme.spacing.lg,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.xl,
    },
    fontList: {
        marginBottom: theme.spacing.lg,
    },
    fontItem: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        padding: theme.spacing.md,
        backgroundColor: theme.colors.background.tertiary,
        borderRadius: theme.borderRadius.sm,
        marginBottom: theme.spacing.sm,
    },
    button: {
        ...commonStyles.button,
        marginRight: theme.spacing.sm,
    },
    deleteButton: {
        backgroundColor: theme.colors.error,
        color: 'white',
        border: 'none',
        padding: `${theme.spacing.xs} ${theme.spacing.sm}`,
        borderRadius: theme.borderRadius.sm,
        cursor: 'pointer',
    },
    input: {
        display: 'none',
    },
};

export const FontManager: React.FC<FontManagerProps> = ({ onClose }) => {
    const [customFonts, setCustomFonts] = useState<CustomFont[]>([]);

    // Load fonts from background service
    useEffect(() => {
        const loadFonts = async () => {
            try {
                const response = await fetch('http://localhost:3003/fonts/dictionary');
                if (!response.ok) throw new Error('Failed to load fonts');
                const fontDict = await response.json();
                
                // Convert dictionary to array
                const fonts = Object.entries(fontDict).map(([name, data]: [string, any]) => ({
                    name,
                    url: data.url,
                    format: data.format
                }));
                setCustomFonts(fonts);

                // Load each font
                fonts.forEach(font => {
                    try {
                        const testFont = new FontFace(font.name, `url(${font.url})`);
                        testFont.load().then(loadedFont => {
                            document.fonts.add(loadedFont);
                        }).catch(error => {
                            console.error('Error loading font:', error);
                        });
                    } catch (error) {
                        console.error('Error creating font:', error);
                    }
                });
            } catch (error) {
                console.error('Error loading font dictionary:', error);
            }
        };

        loadFonts();
    }, []);

    const handleFileSelect = async (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (!file) return;

        // Check if it's an OTF or TTF file
        if (!file.name.match(/\.(otf|ttf)$/i)) {
            alert('Please select an OTF or TTF font file');
            return;
        }

        try {
            // Create form data
            const formData = new FormData();
            formData.append('file', file);

            // Upload font to font service
            const response = await fetch('http://localhost:3003/set_font', {
                method: 'POST',
                body: formData,
            });

            if (!response.ok) {
                throw new Error('Failed to upload font');
            }

            const result = await response.json();
            const { url, name } = result;
            const format = file.name.toLowerCase().endsWith('.otf') ? 'opentype' as const : 'truetype' as const;

            // Test if font can be loaded
            console.log('Loading font:', name, 'from URL:', url);
            const testFont = new FontFace(name, `url(${url})`);
            await testFont.load();
            document.fonts.add(testFont);
            console.log('Successfully loaded font:', name);

            // Add new font to list
            const newFont: CustomFont = { name, url, format };
            setCustomFonts(prev => [...prev, newFont]);

            // Force preview to reload fonts
            window.dispatchEvent(new Event('fontsUpdated'));

        } catch (error) {
            console.error('Error loading font:', error);
            alert('Error loading font. Please try another file.');
        }
    };

    const handleDelete = async (fontName: string) => {
        try {
            // Delete font from font service
            const response = await fetch('http://localhost:3003/delete_font', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ name: fontName }),
            });

            if (!response.ok) {
                throw new Error('Failed to delete font');
            }

            // Remove font from document.fonts
            const fontToRemove = Array.from(document.fonts).find(f => f.family === fontName);
            if (fontToRemove) {
                document.fonts.delete(fontToRemove);
                console.log('Removed font from document:', fontName);
            }

            // Update state
            setCustomFonts(prev => prev.filter(font => font.name !== fontName));

            // Force preview to reload fonts
            window.dispatchEvent(new Event('fontsUpdated'));

        } catch (error) {
            console.error('Error deleting font:', error);
            alert('Error deleting font. Please try again.');
        }
    };

    return (
        <>
            <div style={styles.overlay} onClick={onClose} />
            <div style={styles.modal}>
                <h2 style={styles.title}>Font Manager</h2>

                <div style={styles.fontList}>
                    {customFonts.map(font => (
                        <div key={font.name} style={styles.fontItem}>
                            <span style={{ 
                                fontFamily: `'${font.name}'`,
                                fontSize: '18px',
                            }}>
                                {font.name} - Sample Text
                            </span>
                            <button
                                style={styles.deleteButton}
                                onClick={() => handleDelete(font.name)}
                            >
                                Delete
                            </button>
                        </div>
                    ))}
                </div>

                <input
                    type="file"
                    accept=".otf,.ttf"
                    onChange={handleFileSelect}
                    id="font-file"
                    style={styles.input}
                />
                <label htmlFor="font-file" style={styles.button}>
                    Add Font
                </label>
                <button style={styles.button} onClick={onClose}>
                    Close
                </button>
            </div>
        </>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Settings\PositioningPopup.tsx ---

import React from 'react';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';

interface PositioningPopupProps {
    onClose: () => void;
    children: React.ReactNode;
}

const styles = {
    overlay: {
        position: 'fixed' as const,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.7)',
        zIndex: 9999,
    },
    modal: {
        position: 'fixed' as const,
        top: '50%',
        left: '50%',
        transform: 'translate(-50%, -50%)',
        backgroundColor: theme.colors.background.secondary,
        padding: theme.spacing.xl,
        borderRadius: theme.borderRadius.lg,
        boxShadow: theme.shadows.lg,
        width: '90vw',
        height: '90vh',
        display: 'flex',
        flexDirection: 'column' as const,
        zIndex: 10000,
    },
    header: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: theme.spacing.lg,
    },
    title: {
        margin: 0,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.xl,
    },
    closeButton: {
        ...commonStyles.button,
        padding: `${theme.spacing.xs} ${theme.spacing.sm}`,
    },
    content: {
        flex: 1,
        overflow: 'hidden',
        backgroundColor: theme.colors.background.tertiary,
        borderRadius: theme.borderRadius.md,
        position: 'relative' as const,
    },
    canvas: {
        width: '100%',
        height: '100%',
        position: 'relative' as const,
        overflow: 'hidden',
        transform: 'scale(2)',
        transformOrigin: 'top left',
    },
};

export const PositioningPopup: React.FC<PositioningPopupProps> = ({ onClose, children }) => {
    return (
        <>
            <div style={styles.overlay} onClick={onClose} />
            <div style={styles.modal}>
                <div style={styles.header}>
                    <h2 style={styles.title}>Precise Positioning</h2>
                    <button style={styles.closeButton} onClick={onClose}>
                        Close
                    </button>
                </div>
                <div style={styles.content}>
                    <div style={styles.canvas}>
                        {children}
                    </div>
                </div>
            </div>
        </>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Setup\ComparisonEditor.tsx ---

import React from 'react';
import {Comparison} from '../../types/quiz';
import { ImageSelector } from './ImageSelector';

interface ComparisonEditorProps {
  item: QuizItem;
  onChange: (item: QuizItem) => void;
  onDelete: () => void;
}

export const ComparisonEditor: React.FC<ComparisonEditorProps> = ({
  item,
  onChange,
  onDelete,
}) => {
  return (
    <div style={{
      border: '1px solid #ccc',
      padding: '20px',
      marginBottom: '20px',
      borderRadius: '8px',
    }}>
      <div style={{ marginBottom: '20px' }}>
        <label>
          Question:
          <input
            type="text"
            value={item.question}
            onChange={(e) => onChange({
              ...item,
              question: e.target.value,
              voiceover: e.target.value, // Auto-set voiceover to question
            })}
            style={{ width: '100%', padding: '8px' }}
          />
        </label>
      </div>

      <div style={{ display: 'flex', gap: '20px' }}>
        {/* Left Option */}
        <div style={{ flex: 1 }}>
          <h4>Left Option</h4>
          <input
            type="text"
            value={item.leftOption.text}
            onChange={(e) => onChange({
              ...item,
              leftOption: {
                ...item.leftOption,
                text: e.target.value,
              },
            })}
            placeholder="Left option text"
          />
          <ImageSelector
            currentImage={item.leftOption.image}
            searchTerm={item.leftOption.text}
            onSelect={(imageUrl) => onChange({
              ...item,
              leftOption: {
                ...item.leftOption,
                image: imageUrl,
              },
            })}
          />
        </div>

        {/* Right Option */}
        <div style={{ flex: 1 }}>
          <h4>Right Option</h4>
          <input
            type="text"
            value={item.rightOption.text}
            onChange={(e) => onChange({
              ...item,
              rightOption: {
                ...item.rightOption,
                text: e.target.value,
              },
            })}
            placeholder="Right option text"
          />
          <ImageSelector
            currentImage={item.rightOption.image}
            searchTerm={item.rightOption.text}
            onSelect={(imageUrl) => onChange({
              ...item,
              rightOption: {
                ...item.rightOption,
                image: imageUrl,
              },
            })}
          />
        </div>
      </div>

      <button onClick={onDelete} style={{ marginTop: '20px', color: 'red' }}>
        Delete Comparison
      </button>
    </div>
  );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Setup\ImagePicker.tsx ---

import React, { useState, useEffect } from 'react';
import { createClient } from 'pexels';

const client = createClient('rXEDE5m6pUxOXZPawHmzKj04Z29WlV2y0Us44ld2TmXwdZstXtHUIh2F');

interface ImagePickerProps {
  currentImage: string;
  searchTerm: string;
  onSelect: (imageUrl: string) => void;
}

export const ImagePicker: React.FC<ImagePickerProps> = ({
  currentImage,
  searchTerm,
  onSelect,
}) => {
  const [images, setImages] = useState<Array<{ url: string }>>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (searchTerm) {
      setLoading(true);
      client.photos.search({ query: searchTerm, per_page: 10 })
        .then(result => {
          if ('photos' in result) {
            setImages(result.photos.map(photo => ({
              url: photo.src.large
            })));
          }
          setLoading(false);
        })
        .catch(err => {
          console.error('Error fetching images:', err);
          setLoading(false);
        });
    }
  }, [searchTerm]);

  return (
    <div>
      {loading ? (
        <div>Loading images...</div>
      ) : (
        <div style={{
          display: 'grid',
          gridTemplateColumns: 'repeat(auto-fill, minmax(100px, 1fr))',
          gap: '10px',
          marginTop: '10px',
        }}>
          {images.map((image, index) => (
            <img
              key={index}
              src={image.url}
              alt={`Option ${index + 1}`}
              style={{
                width: '100%',
                height: '100px',
                objectFit: 'cover',
                cursor: 'pointer',
                border: currentImage === image.url ? '3px solid blue' : '1px solid #ccc',
              }}
              onClick={() => onSelect(image.url)}
            />
          ))}
        </div>
      )}
    </div>
  );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Setup\ImageSelector.tsx ---

import React, { useState, useEffect } from 'react';
import { createClient } from 'pexels';

const client = createClient('rXEDE5m6pUxOXZPawHmzKj04Z29WlV2y0Us44ld2TmXwdZstXtHUIh2F');

interface ImageSelectorProps {
    searchTerm: string;
    onSelect: (imageUrl: string) => void;
    currentImageUrl?: string;
}

export const ImageSelector: React.FC<ImageSelectorProps> = ({
    searchTerm,
    onSelect,
    currentImageUrl,
}) => {
    // ... rest of the component stays the same, just update property names
    // from currentImage to currentImageUrl
    // and image.url to photo.src.medium
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Setup\Setup.tsx ---

import React, { useState } from 'react';
import { Player } from '@remotion/player';
import { QuizVideo } from '../../QuizVideo';
import { QuizItem } from '../../data/quizData';
import { ComparisonEditor } from './ComparisonEditor';

export const Setup: React.FC = () => {
  const [quizItems, setQuizItems] = useState<QuizItem[]>([]);
  
  const addComparison = () => {
    setQuizItems([
      ...quizItems,
      {
        question: '',
        leftOption: {
          image: '',
          text: '',
        },
        rightOption: {
          image: '',
          text: '',
        },
        voiceover: '',
      },
    ]);
  };

  return (
    <div style={{ display: 'flex', gap: '20px', padding: '20px' }}>
      {/* Editor Section */}
      <div style={{ flex: 1 }}>
        <button onClick={addComparison}>Add Comparison</button>
        
        {quizItems.map((item, index) => (
          <ComparisonEditor
            key={index}
            item={item}
            onChange={(updatedItem) => {
              const newItems = [...quizItems];
              newItems[index] = updatedItem;
              setQuizItems(newItems);
            }}
            onDelete={() => {
              const newItems = quizItems.filter((_, i) => i !== index);
              setQuizItems(newItems);
            }}
          />
        ))}
      </div>

      {/* Preview Section */}
      <div style={{ flex: 1 }}>
        <Player
          component={QuizVideo}
          durationInFrames={1800}
          fps={30}
          compositionWidth={1080}
          compositionHeight={1920}
          style={{
            width: '100%',
            height: 'auto',
          }}
          inputProps={{
            quizConfig: {
              comparisons: quizItems
            }
          }}
        />
      </div>
    </div>
  );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\SetupPage.tsx ---

import React, {useState} from 'react';
import {Player} from '@remotion/player';
import {QuizConfig, Comparison} from '../types/quiz';
import {ComparisonEditor} from './ComparisonEditor';
import {QuizVideo} from './Video/QuizVideo';

export const SetupPage: React.FC = () => {
	const [quizConfig, setQuizConfig] = useState<QuizConfig>({
		comparisons: [],
	});

	// Calculate duration, minimum 1 second (30 frames)
	const videoDuration = Math.max(30, quizConfig.comparisons.length * 150);

	return (
		<div style={{
			display: 'grid',
			gridTemplateColumns: '1fr 1fr',
			gap: '20px',
			padding: '20px',
			height: '100vh',
			overflow: 'hidden',
		}}>
			{/* Left side - Editor Section */}
			<div style={{
				overflowY: 'auto',
				padding: '20px',
			}}>
				<h1>Quiz Video Setup</h1>
				<button
					onClick={() => {
						const newComparison: Comparison = {
							id: Date.now().toString(),
							question: '',
							leftOption: {
								text: '',
								imageUrl: '',
							},
							rightOption: {
								text: '',
								imageUrl: '',
							},
						};
						setQuizConfig(prev => ({
							...prev,
							comparisons: [...prev.comparisons, newComparison],
						}));
					}}
					style={{
						padding: '12px 24px',
						fontSize: '16px',
						cursor: 'pointer',
						backgroundColor: '#007bff',
						color: 'white',
						border: 'none',
						borderRadius: '4px',
						marginBottom: '20px',
					}}
				>
					Add New Comparison
				</button>

				<div style={{
					display: 'flex',
					flexDirection: 'column',
					gap: '20px',
				}}>
					{quizConfig.comparisons.map((comparison) => (
						<ComparisonEditor
							key={comparison.id}
							comparison={comparison}
							onChange={(updatedComparison) => {
								setQuizConfig(prev => ({
									...prev,
									comparisons: prev.comparisons.map(c => 
										c.id === updatedComparison.id ? updatedComparison : c
									),
								}));
							}}
							onDelete={() => {
								setQuizConfig(prev => ({
									...prev,
									comparisons: prev.comparisons.filter(c => c.id !== comparison.id),
								}));
							}}
						/>
					))}
				</div>
			</div>

			{/* Right side - Preview Section */}
			<div style={{
				backgroundColor: '#f8f9fa',
				padding: '20px',
				borderRadius: '8px',
				display: 'flex',
				flexDirection: 'column',
				height: '100%',
				overflowY: 'auto',
			}}>
				<h2 style={{marginBottom: '20px'}}>Preview</h2>
				
				{/* Debug Info */}
				<div style={{ 
					marginBottom: '20px', 
					padding: '10px', 
					backgroundColor: '#eee', 
					borderRadius: '4px' 
				}}>
					<h3>Debug Info:</h3>
					<pre style={{ whiteSpace: 'pre-wrap', wordBreak: 'break-word' }}>
						{JSON.stringify({
							comparisonsCount: quizConfig.comparisons.length,
							videoDuration,
							firstComparison: quizConfig.comparisons[0],
						}, null, 2)}
					</pre>
				</div>

				{/* Player Container */}
				<div style={{
					position: 'relative',
					width: '100%',
					paddingTop: '177.78%', // 16:9 aspect ratio
					backgroundColor: '#000',
					borderRadius: '8px',
					overflow: 'hidden',
				}}>
					<div style={{
						position: 'absolute',
						top: 0,
						left: 0,
						right: 0,
						bottom: 0,
					}}>
						<Player
							component={QuizVideo}
							inputProps={{
								quizConfig: quizConfig,
							}}
							durationInFrames={videoDuration}
							fps={30}
							compositionWidth={1080}
							compositionHeight={1920}
							style={{
								width: '100%',
								height: '100%',
							}}
							controls
							autoPlay
							loop
						/>
					</div>
				</div>
			</div>
		</div>
	);
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\TemplateManager\TemplateManager.tsx ---

import React, { useState, useEffect } from 'react';
import {
    Box,
    Button,
    Dialog,
    DialogTitle,
    DialogContent,
    DialogActions,
    TextField,
    List,
    ListItem,
    ListItemText,
    ListItemSecondaryAction,
    IconButton,
    Typography,
    Tooltip,
} from '@mui/material';
import DeleteIcon from '@mui/icons-material/Delete';
import DownloadIcon from '@mui/icons-material/Download';
import AddIcon from '@mui/icons-material/Add';
import { Template } from '../../types/template';
import { Script } from '../../types/script';
import {
    getTemplates,
    saveTemplate,
    deleteTemplate,
    scriptToTemplate,
    templateToScript,
} from '../../services/templateService';

interface TemplateManagerProps {
    currentScript?: Script;
    onTemplateSelect?: (script: Script) => void;
}

export const TemplateManager: React.FC<TemplateManagerProps> = ({
    currentScript,
    onTemplateSelect,
}) => {
    const [templates, setTemplates] = useState<Template[]>([]);
    const [isAddDialogOpen, setIsAddDialogOpen] = useState(false);
    const [newTemplateName, setNewTemplateName] = useState('');
    const [newTemplateDescription, setNewTemplateDescription] = useState('');

    useEffect(() => {
        loadTemplates();
    }, []);

    const loadTemplates = () => {
        const loadedTemplates = getTemplates();
        setTemplates(loadedTemplates);
    };

    const handleSaveTemplate = () => {
        if (!currentScript || !newTemplateName) return;

        const template = scriptToTemplate(
            currentScript,
            newTemplateName,
            newTemplateDescription
        );
        saveTemplate(template);
        setIsAddDialogOpen(false);
        setNewTemplateName('');
        setNewTemplateDescription('');
        loadTemplates();
    };

    const handleDeleteTemplate = (templateId: string) => {
        deleteTemplate(templateId);
        loadTemplates();
    };

    const handleTemplateSelect = (template: Template) => {
        if (onTemplateSelect) {
            const script = templateToScript(template);
            onTemplateSelect(script);
        }
    };

    const handleDownloadTemplate = (template: Template) => {
        const templateJson = JSON.stringify(template, null, 2);
        const blob = new Blob([templateJson], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${template.name.toLowerCase().replace(/\s+/g, '_')}_template.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    };

    return (
        <Box>
            <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
                <Typography variant="h6">Templates</Typography>
                <Button
                    variant="contained"
                    color="primary"
                    startIcon={<AddIcon />}
                    onClick={() => setIsAddDialogOpen(true)}
                    disabled={!currentScript}
                >
                    Save as Template
                </Button>
            </Box>

            <List>
                {templates.map((template) => (
                    <ListItem
                        key={template.id}
                        button
                        onClick={() => handleTemplateSelect(template)}
                    >
                        <ListItemText
                            primary={template.name}
                            secondary={template.description || 'No description'}
                        />
                        <ListItemSecondaryAction>
                            <Tooltip title="Download Template">
                                <IconButton
                                    edge="end"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        handleDownloadTemplate(template);
                                    }}
                                >
                                    <DownloadIcon />
                                </IconButton>
                            </Tooltip>
                            <Tooltip title="Delete Template">
                                <IconButton
                                    edge="end"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        handleDeleteTemplate(template.id);
                                    }}
                                >
                                    <DeleteIcon />
                                </IconButton>
                            </Tooltip>
                        </ListItemSecondaryAction>
                    </ListItem>
                ))}
                {templates.length === 0 && (
                    <Typography color="textSecondary" align="center" py={2}>
                        No templates saved yet
                    </Typography>
                )}
            </List>

            <Dialog
                open={isAddDialogOpen}
                onClose={() => setIsAddDialogOpen(false)}
                maxWidth="sm"
                fullWidth
            >
                <DialogTitle>Save as Template</DialogTitle>
                <DialogContent>
                    <TextField
                        autoFocus
                        margin="dense"
                        label="Template Name"
                        fullWidth
                        value={newTemplateName}
                        onChange={(e) => setNewTemplateName(e.target.value)}
                    />
                    <TextField
                        margin="dense"
                        label="Description (optional)"
                        fullWidth
                        multiline
                        rows={3}
                        value={newTemplateDescription}
                        onChange={(e) => setNewTemplateDescription(e.target.value)}
                    />
                </DialogContent>
                <DialogActions>
                    <Button onClick={() => setIsAddDialogOpen(false)}>Cancel</Button>
                    <Button
                        onClick={handleSaveTemplate}
                        color="primary"
                        disabled={!newTemplateName}
                    >
                        Save
                    </Button>
                </DialogActions>
            </Dialog>
        </Box>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Timer.tsx ---

import {useCurrentFrame, Video} from 'remotion';
import clockVideo from '../@Assets/clock.mp4';

interface TimerProps {
	startFrame: number;
}

export const Timer: React.FC<TimerProps> = ({startFrame}) => {
	const frame = useCurrentFrame();
	const relativeFrame = frame - startFrame;

	return (
		<div style={{
			position: 'absolute',
			bottom: 100,
			left: '50%',
			transform: 'translateX(-50%)',
			width: '200px', // Adjust size as needed
			height: '200px',
		}}>
			<Video
				src={clockVideo}
				startFrom={relativeFrame}
				endAt={relativeFrame + 150} // 5 seconds at 30fps
				style={{
					width: '100%',
					height: '100%',
				}}
			/>
		</div>
	);
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\AudioComponent.tsx ---

import React, { useEffect, useRef } from 'react';
import { useCurrentFrame, useVideoConfig } from 'remotion';
import { AudioComponent as AudioComponentType } from '../../types/script';

interface AudioComponentProps {
    component: AudioComponentType;
}

export const AudioComponent: React.FC<AudioComponentProps> = ({ component }) => {
    const frame = useCurrentFrame();
    const { fps } = useVideoConfig();
    const audioRef = useRef<HTMLAudioElement>(null);
    const audioContextRef = useRef<AudioContext | null>(null);
    const sourceNodeRef = useRef<MediaElementAudioSourceNode | null>(null);
    const gainNodeRef = useRef<GainNode | null>(null);

    useEffect(() => {
        if (!audioRef.current) return;

        // Initialize Web Audio API context and nodes
        if (!audioContextRef.current) {
            const AudioContextClass = window.AudioContext || (window as any).webkitAudioContext;
            audioContextRef.current = new AudioContextClass();
            sourceNodeRef.current = audioContextRef.current.createMediaElementSource(audioRef.current);
            gainNodeRef.current = audioContextRef.current.createGain();
            sourceNodeRef.current.connect(gainNodeRef.current);
            gainNodeRef.current.connect(audioContextRef.current.destination);
        }

        const audio = audioRef.current;
        const gainNode = gainNodeRef.current;
        const startTime = component.style?.startTime ?? 0;
        const currentTime = frame / fps;

        // Set volume using gain node
        if (gainNode) {
            gainNode.gain.value = component.style?.volume ?? 1;
        }

        // Set loop
        audio.loop = component.style?.loop ?? false;

        // Calculate and set current time
        const audioTime = currentTime - startTime;
        if (audioTime >= 0) {
            audio.currentTime = audioTime;
            audio.play().catch(console.error);
        } else {
            audio.pause();
        }

        // Handle duration limit
        if (component.style?.duration) {
            const duration = component.style.duration;
            if (audioTime > duration) {
                audio.pause();
            }
        }

        // Cleanup
        return () => {
            audio.pause();
            if (audioContextRef.current) {
                audioContextRef.current.close();
                audioContextRef.current = null;
                sourceNodeRef.current = null;
                gainNodeRef.current = null;
            }
        };
    }, [frame, fps, component.style?.startTime, component.style?.volume, component.style?.loop, component.style?.duration]);

    const audioUrl = typeof component.audioUrl === 'string' ? component.audioUrl : component.audioUrl.url;

    return (
        <audio
            ref={audioRef}
            src={audioUrl}
            preload="auto"
            crossOrigin="anonymous"
        />
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\CaptionRenderer.tsx ---

import React from 'react';
import { useCurrentFrame } from 'remotion';
import { WordTiming, CaptionStyle } from '../../types/script';

interface CaptionRendererProps {
    wordTimings: WordTiming[];
    style: CaptionStyle;
}

export const CaptionRenderer: React.FC<CaptionRendererProps> = ({ wordTimings, style }) => {
    const frame = useCurrentFrame();
    const fps = 30; // Standard frame rate
    const currentTime = frame / fps;

    // Find words that should be visible based on the current time and word window
    const visibleWords = wordTimings.filter(timing => {
        const isWithinTime = currentTime >= timing.start && currentTime <= timing.end;
        if (!isWithinTime) return false;

        // Find the index of the current word
        const currentIndex = wordTimings.findIndex(w => w === timing);
        const windowStart = Math.max(0, currentIndex - Math.floor(style.wordWindow / 2));
        const windowEnd = Math.min(wordTimings.length - 1, currentIndex + Math.floor(style.wordWindow / 2));

        // Check if the word is within the window
        return currentIndex >= windowStart && currentIndex <= windowEnd;
    });

    if (visibleWords.length === 0) return null;

    return (
        <div style={{
            position: 'absolute',
            bottom: style.position === 'top' ? 'auto' : '10%',
            top: style.position === 'top' ? '10%' : 'auto',
            left: '50%',
            transform: 'translateX(-50%)',
            textAlign: 'center',
            fontSize: style.fontSize,
            color: style.color,
            backgroundColor: style.backgroundColor,
            padding: '10px 20px',
            borderRadius: '5px',
            maxWidth: '80%',
            transition: 'all 0.2s ease-in-out'
        }}>
            {visibleWords.map(word => word.word).join(' ')}
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\ComparisonComponent.tsx ---

import React from 'react';
import { ComparisonComponent as ComparisonComponentType } from '../../types/script';
import { AbsoluteFill, useCurrentFrame, interpolate, spring } from 'remotion';
import { theme } from '../../styles/theme';

interface ComparisonComponentProps {
    component: ComparisonComponentType;
}

const getAnimationStyle = (
    frame: number,
    animation: ComparisonComponentType['style']['animation'],
    isSecondImage: boolean = false,
    durationInFrames: number
) => {
    if (!animation || animation.type === 'none') {
        return {};
    }

    const delay = (animation.delay || 0) + (isSecondImage ? (animation.stagger || 0) : 0);
    const duration = animation.duration || 30;
    const currentFrame = Math.max(0, frame - delay);
    const progress = interpolate(
        currentFrame,
        [0, duration, durationInFrames - duration, durationInFrames],
        [0, 1, 1, 0],
        {
            extrapolateLeft: 'clamp',
            extrapolateRight: 'clamp',
            easing: animation.easing === 'linear' ? (t) => t :
                   animation.easing === 'ease-in' ? (t) => t * t :
                   animation.easing === 'ease-out' ? (t) => 1 - Math.pow(1 - t, 2) :
                   (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2
        }
    );

    switch (animation.type) {
        case 'fade':
            return { opacity: progress };
        case 'scale':
            return { transform: `scale(${progress})` };
        case 'rotate':
            return { transform: `rotate(${interpolate(progress, [0, 1], [0, 360])}deg)` };
        case 'slide':
            const offset = 100;
            const x = animation.direction === 'left' ? -offset : 
                     animation.direction === 'right' ? offset : 0;
            const y = animation.direction === 'top' ? -offset :
                     animation.direction === 'bottom' ? offset : 0;
            return {
                transform: `translate(${interpolate(progress, [0, 1], [x, 0])}%, ${interpolate(progress, [0, 1], [y, 0])}%)`
            };
        default:
            return {};
    }
};

export const ComparisonComponent: React.FC<ComparisonComponentProps> = ({ component }) => {
    const frame = useCurrentFrame();
    const { 
        fontSize = 32, 
        fontFamily = 'Arial', 
        textColor = '#ffffff', 
        backgroundColor = 'rgba(0, 0, 0, 0.7)', 
        spacing = 20, 
        borderRadius = 8, 
        shadow = true,
        showText = true,
        imageSize = 100,
        imageGap = 20,
        forceSameSize = true,
        imagePosition = { x: 0, y: 0 },
        imageBorder,
        imageDropShadow,
        animation
    } = component.style || {};

    // Base fade animation
    const opacity = interpolate(
        frame,
        [0, 15, component.durationInFrames - 15, component.durationInFrames],
        [0, 1, 1, 0]
    );

    const imageContainerStyle = {
        display: 'flex',
        flexDirection: component.orientation === 'horizontal' ? 'row' as const : 'column' as const,
        gap: `${imageGap}px`,
        justifyContent: 'center',
        alignItems: 'center',
        transform: `translate(${imagePosition.x}%, ${imagePosition.y}%)`,
        width: '100%',
        height: '100%',
        padding: '10% 5%',
    };

    const commonImageStyle = {
        width: forceSameSize ? `${imageSize}%` : 'auto',
        height: forceSameSize ? `${imageSize}%` : 'auto',
        maxWidth: forceSameSize ? `${imageSize}%` : '100%',
        maxHeight: forceSameSize ? `${imageSize}%` : '100%',
        objectFit: forceSameSize ? 'contain' : 'cover',
        borderRadius: `${borderRadius}px`,
        border: imageBorder?.enabled ? `${imageBorder.width}px solid ${imageBorder.color}` : undefined,
        boxShadow: imageDropShadow?.enabled ? 
            `${imageDropShadow.x}px ${imageDropShadow.y}px ${imageDropShadow.blur}px ${imageDropShadow.spread}px ${imageDropShadow.color}` : 
            undefined,
    };

    return (
        <AbsoluteFill style={{ opacity }}>
            {/* Question */}
            {showText && (
                <div style={{
                    position: 'absolute',
                    top: '5%',
                    left: '50%',
                    transform: 'translateX(-50%)',
                    backgroundColor,
                    padding: '10px 20px',
                    borderRadius: borderRadius,
                    boxShadow: shadow ? '0 2px 4px rgba(0,0,0,0.2)' : undefined,
                    fontSize: `${fontSize}px`,
                    fontFamily,
                    color: textColor,
                    textAlign: 'center',
                    zIndex: 10,
                }}>
                    {component.question}
                </div>
            )}

            {/* Images Container */}
            <div style={imageContainerStyle}>
                {/* Left/Top Image */}
                <div style={{
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    gap: '10px',
                    ...getAnimationStyle(frame, animation, false, component.durationInFrames),
                }}>
                    <img
                        src={component.leftOption.imageUrl}
                        style={commonImageStyle}
                        alt={component.leftOption.text}
                    />
                    {showText && (
                        <div style={{
                            backgroundColor,
                            padding: '5px 10px',
                            borderRadius: borderRadius,
                            boxShadow: shadow ? '0 2px 4px rgba(0,0,0,0.2)' : undefined,
                            fontSize: `${fontSize * 0.8}px`,
                            fontFamily,
                            color: textColor,
                            textAlign: 'center',
                        }}>
                            {component.leftOption.text}
                        </div>
                    )}
                </div>

                {/* Right/Bottom Image */}
                <div style={{
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    gap: '10px',
                    ...getAnimationStyle(frame, animation, true, component.durationInFrames),
                }}>
                    <img
                        src={component.rightOption.imageUrl}
                        style={commonImageStyle}
                        alt={component.rightOption.text}
                    />
                    {showText && (
                        <div style={{
                            backgroundColor,
                            padding: '5px 10px',
                            borderRadius: borderRadius,
                            boxShadow: shadow ? '0 2px 4px rgba(0,0,0,0.2)' : undefined,
                            fontSize: `${fontSize * 0.8}px`,
                            fontFamily,
                            color: textColor,
                            textAlign: 'center',
                        }}>
                            {component.rightOption.text}
                        </div>
                    )}
                </div>
            </div>
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\ComparisonSequence.tsx ---

import React from 'react';
import { AbsoluteFill } from 'remotion';
import { Comparison } from '../../types/quiz';

interface ComparisonSequenceProps {
    comparison: Comparison;
}

export const ComparisonSequence: React.FC<ComparisonSequenceProps> = ({ comparison }) => {
    return (
        <AbsoluteFill>
            {/* Component content */}
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\CountdownSequence.tsx ---

import React from 'react';
import { AbsoluteFill, useCurrentFrame } from 'remotion';
import { CountdownComponent } from '../../types/script';

interface CountdownSequenceProps {
    component: CountdownComponent;
}

export const CountdownSequence: React.FC<CountdownSequenceProps> = ({ component }) => {
    const frame = useCurrentFrame();
    const style = component.style || {};
    const position = style.position || { x: 0, y: 0 };

    // Calculate current number based on frame
    const from = component.from || 10;
    const framePerNumber = component.durationInFrames ? component.durationInFrames / from : 30;
    const currentNumber = Math.max(0, Math.ceil(from - frame / framePerNumber));

    return (
        <AbsoluteFill>
            <div style={{
                position: 'absolute',
                left: position.x,
                top: position.y,
                fontSize: style.fontSize || 80,
                fontFamily: style.fontFamily || 'Arial',
                color: style.color || 'white',
                textAlign: style.textAlign || 'center',
                width: style.position?.width || 300,
                fontWeight: 'bold',
                transform: 'translate(0, 0)', // Prevent any transform issues
            }}>
                {currentNumber}
            </div>
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\ImageComponent.tsx ---

import React from 'react';
import { AbsoluteFill } from 'remotion';
import { ImageComponent as ImageComponentType } from '../../types/script';

interface ImageComponentProps {
    component: ImageComponentType;
}

export const ImageComponent: React.FC<ImageComponentProps> = ({ component }) => {
    const {
        imageUrl,
        style = {}
    } = component;

    const {
        width = 400,
        height = 400,
        position = { x: 0, y: 0 },
        scale = 1,
        rotation = 0,
        opacity = 1,
        border = { enabled: false, color: '#000000', width: 2 },
        dropShadow = { enabled: false, color: '#000000', blur: 10, spread: 0, x: 5, y: 5 }
    } = style;

    // Calculate shadow styles if enabled
    const shadowStyle = dropShadow.enabled ? {
        filter: `drop-shadow(${dropShadow.x}px ${dropShadow.y}px ${dropShadow.blur}px ${dropShadow.color})`
    } : {};

    // Calculate border styles if enabled
    const borderStyle = border.enabled ? {
        border: `${border.width}px solid ${border.color}`
    } : {};

    return (
        <AbsoluteFill>
            <div
                style={{
                    position: 'absolute',
                    left: `${position.x}px`,
                    top: `${position.y}px`,
                    width: `${width}px`,
                    height: `${height}px`,
                    transform: `scale(${scale}) rotate(${rotation}deg)`,
                    opacity,
                    ...shadowStyle,
                    ...borderStyle,
                    overflow: 'hidden',
                }}
            >
                <img
                    src={imageUrl}
                    alt="Video component"
                    style={{
                        width: '100%',
                        height: '100%',
                        objectFit: 'cover',
                    }}
                />
            </div>
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\QuizVideo.tsx ---

import React from 'react';
import {
    AbsoluteFill,
    Audio,
    Sequence,
    useVideoConfig,
} from 'remotion';
import {QuizConfig} from '../../types/quiz';
import {ComparisonSequence} from './ComparisonSequence';

interface QuizVideoProps {
    quizConfig: QuizConfig;
}

export const QuizVideo: React.FC<QuizVideoProps> = ({quizConfig}) => {
    const {fps} = useVideoConfig();
    const SEQUENCE_DURATION = 5 * fps;

    // Handle empty state
    if (!quizConfig.comparisons.length) {
        return (
            <AbsoluteFill style={{
                backgroundColor: '#1a1a1a',
                display: 'flex',
                justifyContent: 'center',
                alignItems: 'center',
            }}>
                <h1 style={{color: 'white'}}>Add a comparison to start</h1>
            </AbsoluteFill>
        );
    }

    return (
        <AbsoluteFill style={{backgroundColor: '#1a1a1a'}}>
            {quizConfig.comparisons.map((comparison, index) => (
                <Sequence
                    key={comparison.id}
                    from={index * SEQUENCE_DURATION}
                    durationInFrames={SEQUENCE_DURATION}
                >
                    <ComparisonSequence comparison={comparison} />
                </Sequence>
            ))}
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\RemotionSubtitleCaption.tsx ---

import React, { useEffect } from 'react';
import { useCurrentFrame, useVideoConfig } from 'remotion';
import { SubtitleSequence } from 'remotion-subtitle';
import {
    BounceCaption,
    ColorfulCaption,
    ExplosiveCaption,
    FadeCaption,
    FireCaption,
    GlitchCaption,
    GlowingCaption,
    LightningCaption,
    NeonCaption,
    RotatingCaption,
    ShakeCaption,
    ThreeDishCaption,
    TiltShiftCaption,
    TypewriterCaption,
    WavingCaption,
    ZoomCaption,
} from 'remotion-subtitle';
import { TextStyle, WordTiming } from '../../types/script';

interface RemotionSubtitleCaptionProps {
    wordTimings: WordTiming[];
    style: TextStyle;
    startFrame: number;
}

const CAPTION_COMPONENTS = {
    bounce: BounceCaption,
    colorful: ColorfulCaption,
    explosive: ExplosiveCaption,
    fade: FadeCaption,
    fire: FireCaption,
    glitch: GlitchCaption,
    glowing: GlowingCaption,
    lightning: LightningCaption,
    neon: NeonCaption,
    rotating: RotatingCaption,
    shake: ShakeCaption,
    threeDish: ThreeDishCaption,
    tiltShift: TiltShiftCaption,
    typewriter: TypewriterCaption,
    waving: WavingCaption,
    zoom: ZoomCaption,
};

export const RemotionSubtitleCaption: React.FC<RemotionSubtitleCaptionProps> = (props) => {
    const { wordTimings, style, startFrame } = props;
    const frame = useCurrentFrame();
    const { fps } = useVideoConfig();
    const currentTime = frame / fps;
    const componentStartTime = startFrame / fps;

    // Enhanced debug logging
    const debugLog = (message: string, data?: any, trace: boolean = false, level: 'info' | 'warn' | 'error' = 'info') => {
        const timestamp = new Date().toISOString();
        const frameInfo = `[Frame: ${frame}]`;
        const componentInfo = `[RemotionSubtitleCaption]`;
        const propsSnapshot = JSON.stringify(props, null, 2);
        const callStack = new Error().stack;

        console.group(`${timestamp} ${frameInfo} ${componentInfo} ${message}`);
        console.log('Props Snapshot:', propsSnapshot);
        console.log('Current Frame:', frame);
        console.log('FPS:', fps);
        console.log('Current Time:', currentTime);
        console.log('Component Start Time:', componentStartTime);
        console.log('Data:', data);
        console.log('Call Stack:', callStack);
        if (trace) {
            console.trace('Detailed Stack Trace');
        }
        console.groupEnd();
    };

    // Log initial render
    debugLog('Component Initial Render', {
        hasWordTimings: !!wordTimings,
        wordTimingsCount: wordTimings.length,
        style,
        startFrame,
        currentTime,
        componentStartTime
    }, true);

    // Log component mount
    useEffect(() => {
        debugLog('Component Mounted', {
            wordTimingsCount: wordTimings.length,
            style,
            startFrame,
            currentTime,
            componentStartTime,
            mountTime: new Date().toISOString(),
        }, true);

        return () => {
            debugLog('Component Unmounting', {
                unmountTime: new Date().toISOString(),
                lastFrame: frame,
            }, true);
        };
    }, []);

    // Log every frame update
    useEffect(() => {
        const frameStartTime = performance.now();
        debugLog('Frame Update', {
            currentFrame: frame,
            currentTime,
            componentStartTime,
            activeWords: wordTimings.filter(timing => {
                const start = timing.start - componentStartTime;
                const end = timing.end - componentStartTime;
                return currentTime >= start && currentTime <= end;
            }).map(w => w.word)
        });
        const frameEndTime = performance.now();
        debugLog('Frame Update Complete', {
            frameDuration: frameEndTime - frameStartTime,
            frame,
        });
    }, [frame]);

    // Convert word timings to SRT format with logging
    debugLog('Converting word timings to SRT format', {
        wordTimings,
        componentStartTime
    });

    const srtContent = wordTimings
        .map((timing, index) => {
            const start = timing.start - componentStartTime;
            const end = timing.end - componentStartTime;
            const srtEntry = `${index + 1}\n${formatTime(start)} --> ${formatTime(end)}\n${timing.word}\n\n`;
            
            debugLog('Generated SRT entry:', {
                index,
                word: timing.word,
                originalStart: timing.start,
                originalEnd: timing.end,
                adjustedStart: start,
                adjustedEnd: end,
                srtEntry
            });

            return srtEntry;
        })
        .join('');

    // Get the appropriate caption component
    const CaptionComponent = style.captionStyle && CAPTION_COMPONENTS[style.captionStyle as keyof typeof CAPTION_COMPONENTS];
    
    debugLog('Caption component selection:', {
        requestedStyle: style.captionStyle,
        foundComponent: !!CaptionComponent,
        availableStyles: Object.keys(CAPTION_COMPONENTS)
    });

    if (!CaptionComponent) {
        debugLog('No caption component found for style', {
            style: style.captionStyle
        }, true);
        return null;
    }

    // Create subtitle sequence with logging
    debugLog('Creating subtitle sequence', {
        srtContent,
        style
    });

    const subtitles = new SubtitleSequence(srtContent);

    debugLog('Rendering subtitles', {
        currentFrame: frame,
        currentTime,
        style: {
            fontSize: style.fontSize || '24px',
            color: style.color || 'white',
            ...style,
        }
    }, true);

    return (
        <div style={{
            position: 'absolute',
            left: '50%',
            bottom: '10%',
            transform: 'translateX(-50%)',
            width: '80%',
            textAlign: 'center',
        }}>
            {debugLog('Rendering Subtitles', {
                currentTime,
                componentStartTime,
                activeWords: wordTimings.filter(timing => {
                    const start = timing.start - componentStartTime;
                    const end = timing.end - componentStartTime;
                    return currentTime >= start && currentTime <= end;
                }).map(w => w.word)
            })}
            {subtitles.getSequences(
                <CaptionComponent style={{
                    fontSize: style.fontSize || '24px',
                    color: style.color || 'white',
                    ...style,
                }} />,
                fps
            )}
        </div>
    );
};

// Helper function to format time in SRT format (HH:MM:SS,mmm)
function formatTime(seconds: number): string {
    const pad = (n: number, width: number) => String(n).padStart(width, '0');
    
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    const ms = Math.floor((seconds % 1) * 1000);
    
    return `${pad(hours, 2)}:${pad(minutes, 2)}:${pad(secs, 2)},${pad(ms, 3)}`;
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\ScriptVideo.tsx ---

import React, { useEffect, useState, useMemo } from 'react';
import { AbsoluteFill, Sequence, spring, useCurrentFrame, useVideoConfig, Audio } from 'remotion';
import { Script, TextComponent as TextComponentType, VoiceComponent as VoiceComponentType, AudioComponent as AudioComponentType } from '../../types/script';
import { CaptionRenderer } from './CaptionRenderer';
import { ComparisonComponent } from './ComparisonComponent';
import { VideoComponent } from './VideoComponent';
import { TextComponent } from './TextComponent';

interface ScriptVideoProps {
    script: Script;
}

const getAnimationStyle = (frame: number, fps: number, animation: string, direction: 'in' | 'out', timing: { start: number; end: number }) => {
    if (!animation) return {};

    const isOut = direction === 'out';
    const durationInFrames = timing.end - timing.start;
    const adjustedFrame = frame - timing.start;

    console.log(`Animation ${direction}:`, {
        frame,
        adjustedFrame,
        timing,
        durationInFrames,
    });

    // If we're not within the animation timeframe, return the final state
    if (adjustedFrame < 0) return isOut ? {} : { opacity: 0, transform: getInitialTransform(animation) };
    if (adjustedFrame > durationInFrames) return isOut ? { opacity: 0, transform: getFinalTransform(animation) } : {};

    switch (animation) {
        case 'slide-left': {
            const opacity = spring({
                frame: adjustedFrame,
                fps,
                from: isOut ? 1 : 0,
                to: isOut ? 0 : 1,
                durationInFrames,
            });

            const slideX = spring({
                frame: adjustedFrame,
                fps,
                from: isOut ? 0 : -200,
                to: isOut ? -200 : 0,
                durationInFrames,
                config: {
                    damping: 12,
                    mass: 0.5,
                },
            });

            return {
                opacity,
                transform: `translateX(${slideX}px)`,
            };
        }
        case 'slide-right': {
            const opacity = spring({
                frame: adjustedFrame,
                fps,
                from: isOut ? 1 : 0,
                to: isOut ? 0 : 1,
                durationInFrames,
            });

            const slideX = spring({
                frame: adjustedFrame,
                fps,
                from: isOut ? 0 : 200,
                to: isOut ? 200 : 0,
                durationInFrames,
                config: {
                    damping: 12,
                    mass: 0.5,
                },
            });

            return {
                opacity,
                transform: `translateX(${slideX}px)`,
            };
        }
        default:
            return {};
    }
};

// Helper functions to get initial and final transform states
const getInitialTransform = (animation: string) => {
    switch (animation) {
        case 'slide-left':
            return 'translateX(-200px)';
        case 'slide-right':
            return 'translateX(200px)';
        default:
            return 'none';
    }
};

const getFinalTransform = (animation: string) => {
    switch (animation) {
        case 'slide-left':
            return 'translateX(-200px)';
        case 'slide-right':
            return 'translateX(200px)';
        default:
            return 'none';
    }
};

const BACKGROUND_SERVICE_URL = 'http://localhost:3002';

export const ScriptVideo: React.FC<ScriptVideoProps> = ({ script }) => {
    // Store the background URL in state to prevent re-fetching
    const [bgUrl, setBgUrl] = useState<string | null>(null);

    useEffect(() => {
        if (script.settings?.background?.type === 'image' && script.settings.background.url) {
            // If it's already a full URL, or we want to prefix a local service
            let finalUrl = script.settings.background.url;
            if (!/^https?:\/\//.test(finalUrl)) {
                // Not a fully qualified URL, prefix the background service
                finalUrl = `${BACKGROUND_SERVICE_URL}/backgrounds/${encodeURIComponent(finalUrl)}`;
            }
            setBgUrl(finalUrl);
        } else if (script.settings?.background?.type === 'video' && script.settings.background.url) {
            // Handle video backgrounds similarly
            let finalUrl = script.settings.background.url;
            if (!/^https?:\/\//.test(finalUrl)) {
                finalUrl = `${BACKGROUND_SERVICE_URL}/backgrounds/${encodeURIComponent(finalUrl)}`;
            }
            setBgUrl(finalUrl);
        } else {
            setBgUrl(null);
        }
    }, [script.settings?.background]);

    // Memoize the background style to prevent unnecessary re-renders
    const backgroundStyle = useMemo(() => {
        if (!bgUrl) {
            return {
                backgroundColor: 'black',
            };
        }

        if (script.settings?.background?.type === 'video') {
            return {
                backgroundColor: 'black',
            };
        }

        return {
            backgroundImage: `url("${bgUrl}")`,
            backgroundSize: 'cover',
            backgroundPosition: 'center',
            backgroundRepeat: 'no-repeat',
        };
    }, [bgUrl, script.settings?.background?.type]);

    useEffect(() => {
        const loadFonts = async () => {
            try {
                // Get font dictionary from font service
                const response = await fetch('http://localhost:3003/fonts/dictionary');
                if (!response.ok) throw new Error('Failed to load font dictionary');
                const fontDict = await response.json();
                console.log('ScriptVideo: Font dictionary:', fontDict);

                // Get unique font families used in components
                const usedFonts = new Set<string>();
                script.components.forEach(comp => {
                    if (comp.type === 'text' || comp.type === 'title') {
                        const textComp = comp as { style?: { fontFamily?: string } };
                        if (textComp.style?.fontFamily) {
                            usedFonts.add(textComp.style.fontFamily);
                            console.log('ScriptVideo: Found font:', textComp.style.fontFamily);
                        }
                    }
                });

                // Load each used font
                const fontLoadPromises = Array.from(usedFonts).map(async fontName => {
                    const fontData = fontDict[fontName];
                    if (fontData?.url) {
                        try {
                            console.log('ScriptVideo: Loading font:', fontName, 'from URL:', fontData.url);
                            const font = new FontFace(fontName, `url(${fontData.url})`);
                            const loadedFont = await font.load();
                            document.fonts.add(loadedFont);
                            console.log('ScriptVideo: Successfully loaded font:', fontName);
                            return true;
                        } catch (error) {
                            console.error('ScriptVideo: Error loading font:', fontName, error);
                            return false;
                        }
                    }
                    return false;
                });

                await Promise.all(fontLoadPromises);
                console.log('ScriptVideo: All fonts loaded');
            } catch (error) {
                console.error('ScriptVideo: Error loading fonts:', error);
            }
        };

        loadFonts();
    }, [script]);

    return (
        <AbsoluteFill style={backgroundStyle}>
            {script.settings?.background?.type === 'video' && bgUrl && (
                <video
                    src={bgUrl}
                    style={{
                        position: 'absolute',
                        width: '100%',
                        height: '100%',
                        objectFit: 'cover',
                    }}
                    autoPlay
                    loop
                    muted
                />
            )}
            {script.components.map((component) => {
                const key = `${component.id}-${component.startFrame}-${component.durationInFrames}`;
                return (
                    <Sequence
                        key={key}
                        from={component.startFrame || 0}
                        durationInFrames={component.durationInFrames || 150}
                    >
                        {component.type === 'text' && (
                            <TextComponent component={component as TextComponentType} />
                        )}
                        {component.type === 'comparison' && (
                            <ComparisonComponent component={component as any} />
                        )}
                        {component.type === 'video' && (
                            <VideoComponent component={component as any} />
                        )}
                        {component.type === 'voice' && (
                            <VoiceComponent component={component as VoiceComponentType} />
                        )}
                        {component.type === 'audio' && (
                            <AudioEffectComponent component={component as AudioComponentType} />
                        )}
                    </Sequence>
                );
            })}
        </AbsoluteFill>
    );
};

const TextComponent: React.FC<{ component: TextComponentType }> = ({ component }) => {
    const frame = useCurrentFrame();
    const { fps } = useVideoConfig();
    
    const animationIn = component.style?.animation?.in?.type || '';
    const animationOut = component.style?.animation?.out?.type || '';
    
    // Calculate animation timings
    const totalDuration = component.durationInFrames || 150;
    
    // For entrance animation
    const inStartFrame = component.style?.animation?.in?.startFrame || 0;
    const inEndFrame = component.style?.animation?.in?.endFrame || 30;
    const inTiming = {
        start: inStartFrame,
        end: inEndFrame,
    };
    
    // For exit animation
    const outStartFrame = totalDuration - (component.style?.animation?.out?.startFrame || 30);
    const outEndFrame = totalDuration - (component.style?.animation?.out?.endFrame || 0);
    const outTiming = {
        start: outStartFrame,
        end: outEndFrame,
    };
    
    console.log('Animation frames:', {
        frame,
        totalDuration,
        in: { start: inStartFrame, end: inEndFrame },
        out: { start: outStartFrame, end: outEndFrame },
    });
    
    const animationStyleIn = getAnimationStyle(frame, fps, animationIn, 'in', inTiming);
    const animationStyleOut = getAnimationStyle(frame, fps, animationOut, 'out', outTiming);
    
    return (
        <div style={{
            position: 'absolute',
            left: component.style?.position?.x || 0,
            top: component.style?.position?.y || 0,
            width: 'auto',
            display: 'inline-block',
            ...(component.style?.blockStyle?.enabled ? {
                backgroundColor: component.style.backgroundColor || '#FFFFFF',
                padding: '20px 40px',
                borderRadius: '15px',
                boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
                minWidth: '33%',
            } : {}),
            textAlign: component.style?.textAlign || 'center',
            color: component.style?.color || 'white',
            fontSize: component.style?.fontSize || 40,
            fontFamily: component.style?.fontFamily || 'Arial',
            fontWeight: component.style?.fontWeight || 'normal',
            textTransform: component.style?.textTransform || 'none',
            ...animationStyleIn,
            ...animationStyleOut,
            ...(component.style?.outline?.enabled ? {
                textShadow: `
                    -${component.style.outline.width}px -${component.style.outline.width}px 0 ${component.style.outline.color},
                    ${component.style.outline.width}px -${component.style.outline.width}px 0 ${component.style.outline.color},
                    -${component.style.outline.width}px ${component.style.outline.width}px 0 ${component.style.outline.color},
                    ${component.style.outline.width}px ${component.style.outline.width}px 0 ${component.style.outline.color}
                `
            } : {})
        }}>
            {component.text}
        </div>
    );
};

const VoiceComponent: React.FC<{ component: VoiceComponentType }> = ({ component }) => {
    if (!component.audioUrl) {
        console.warn('VoiceComponent: No audio URL provided');
        return null;
    }

    // Calculate volume based on style settings
    const volume = component.style?.volume ?? 1;

    // Calculate start and end times if specified
    const startTime = component.style?.startTime ?? 0;
    const duration = component.style?.duration;

    return (
        <>
            <Audio
                src={component.audioUrl}
                volume={volume}
                startFrom={startTime}
                endAt={duration ? startTime + duration : undefined}
            />
            {component.showCaptions && component.wordTimings && (
                <CaptionRenderer
                    wordTimings={component.wordTimings}
                    style={component.captionStyle || {
                        fontSize: 24,
                        color: '#ffffff',
                        backgroundColor: 'rgba(0, 0, 0, 0.7)',
                        position: 'bottom',
                        wordWindow: 1
                    }}
                />
            )}
        </>
    );
};

const AudioEffectComponent: React.FC<{ component: AudioComponentType }> = ({ component }) => {
    if (!component.audioUrl) {
        console.warn('AudioEffectComponent: No audio URL provided');
        return null;
    }

    // Get audio settings from style
    const volume = component.style?.volume ?? 1;
    const startTime = component.style?.startTime ?? 0;
    const duration = component.style?.duration;
    const loop = component.style?.loop ?? false;

    // Handle both string URLs and audio object URLs
    const audioSrc = typeof component.audioUrl === 'string' 
        ? component.audioUrl 
        : component.audioUrl.url;

    return (
        <Audio
            src={audioSrc}
            volume={volume}
            startFrom={startTime}
            endAt={duration ? startTime + duration : undefined}
            loop={loop}
        />
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\TextComponent.tsx ---

import React from 'react';
import { useCurrentFrame, useVideoConfig } from 'remotion';
import { TextComponent as TextComponentType } from '../../types/script';
import { getAnimationStyle } from '../../utils/animation';

interface TextComponentProps {
    component: TextComponentType;
}

export const TextComponent: React.FC<TextComponentProps> = ({ component }) => {
    const frame = useCurrentFrame();
    const { fps } = useVideoConfig();

    const style = component.style || {};
    const animationStyle = getAnimationStyle(frame, fps, style.animation);

    return (
        <div
            style={{
                position: 'absolute',
                left: '50%',
                top: '50%',
                transform: `translate(-50%, -50%)`,
                fontSize: style.fontSize || 32,
                fontFamily: style.fontFamily || 'Arial',
                color: style.color || '#ffffff',
                textAlign: style.textAlign || 'center',
                fontWeight: style.fontWeight || 'normal',
                lineHeight: style.lineHeight || 1.5,
                backgroundColor: style.backgroundColor,
                padding: style.padding,
                borderRadius: style.borderRadius,
                ...animationStyle,
            }}
        >
            {component.text}
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\TextSequence.tsx ---

import React from 'react';
import { AbsoluteFill } from 'remotion';
import { TextComponent } from '../../types/script';

interface TextSequenceProps {
    component: TextComponent;
}

export const TextSequence: React.FC<TextSequenceProps> = ({ component }) => {
    const style = component.style || {};
    const position = style.position || { x: 0, y: 0 };

    // Format text based on wordsPerLine
    const formatText = (text: string) => {
        if (!text || !style.wordsPerLine || style.wordsPerLine <= 0) {
            return text;
        }

        // Remove existing line breaks and extra spaces
        const cleanText = text.replace(/[\n\r]+/g, ' ').replace(/\s+/g, ' ').trim();
        const words = cleanText.split(' ');
        const lines = [];
        
        // Group words into lines
        for (let i = 0; i < words.length; i += style.wordsPerLine) {
            const line = words.slice(i, i + style.wordsPerLine).join(' ');
            if (line) lines.push(line);
        }
        
        // Join lines with newlines
        return lines.join('\n');
    };

    // Create text shadow for outline effect
    const getTextShadow = () => {
        if (!style.outline?.enabled) return 'none';

        const width = style.outline.width || 2;
        const color = style.outline.color || '#000000';
        const shadows = [];

        // Generate outline effect using multiple text shadows
        for (let x = -width; x <= width; x++) {
            for (let y = -width; y <= width; y++) {
                if (Math.abs(x) === width || Math.abs(y) === width) {
                    shadows.push(`${x}px ${y}px 0 ${color}`);
                }
            }
        }

        return shadows.join(', ');
    };

    return (
        <AbsoluteFill>
            <div style={{
                position: 'absolute',
                left: position.x,
                top: position.y,
                fontSize: style.fontSize || 40,
                fontFamily: style.fontFamily || 'Arial',
                color: style.color || 'white',
                textAlign: style.textAlign || 'center',
                width: '100%',
                maxWidth: '80%',
                margin: '0 auto',
                transform: 'translate(0, 0)', // Prevent any transform issues
                whiteSpace: 'pre-wrap', // Preserve line breaks
                fontWeight: style.fontWeight || 'normal',
                lineHeight: style.lineHeight || 1.5,
                textShadow: getTextShadow(),
            }}>
                {formatText(component.text)}
            </div>
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\TikTokCaptions.tsx ---

import React from 'react';
import {
    AbsoluteFill,
    useCurrentFrame,
    useVideoConfig,
    spring,
    interpolate,
} from 'remotion';
import { TikTokPage } from '../../types/script';

interface TikTokCaptionsProps {
    pages: TikTokPage[];
    style?: {
        backgroundColor?: string;
        textColor?: string;
        position?: 'top' | 'bottom' | 'middle';
    };
}

export const TikTokCaptions: React.FC<TikTokCaptionsProps> = ({
    pages,
    style = {},
}) => {
    const frame = useCurrentFrame();
    const { fps } = useVideoConfig();
    const currentTimeMs = (frame / fps) * 1000;

    const currentPage = pages.find((page, index) => {
        const nextPage = pages[index + 1];
        return (
            currentTimeMs >= page.startMs &&
            (!nextPage || currentTimeMs < nextPage.startMs)
        );
    });

    if (!currentPage) return null;

    const pageProgress = spring({
        frame,
        fps,
        config: {
            damping: 200,
        },
    });

    const getTokenOpacity = (token: TikTokPage['tokens'][0]) => {
        return interpolate(
            currentTimeMs,
            [token.fromMs, token.fromMs + 100, token.toMs - 100, token.toMs],
            [0, 1, 1, 0],
            {
                extrapolateLeft: 'clamp',
                extrapolateRight: 'clamp',
            }
        );
    };

    return (
        <AbsoluteFill
            style={{
                justifyContent: style.position === 'top' ? 'flex-start' : 
                    style.position === 'bottom' ? 'flex-end' : 'center',
                padding: '40px',
            }}
        >
            <div
                style={{
                    backgroundColor: style.backgroundColor || 'rgba(0, 0, 0, 0.8)',
                    color: style.textColor || 'white',
                    padding: '20px',
                    borderRadius: '12px',
                    fontSize: '32px',
                    fontWeight: 'bold',
                    textAlign: 'center',
                    opacity: pageProgress,
                    whiteSpace: 'pre',
                    display: 'inline-block',
                    margin: '0 auto',
                }}
            >
                {currentPage.tokens.map((token, i) => (
                    <span
                        key={i}
                        style={{
                            opacity: getTokenOpacity(token),
                            display: 'inline-block',
                        }}
                    >
                        {token.text}
                    </span>
                ))}
            </div>
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\TitleSequence.tsx ---

import React from 'react';
import { AbsoluteFill } from 'remotion';
import { TitleComponent } from '../../types/script';

interface TitleSequenceProps {
    component: TitleComponent;
}

export const TitleSequence: React.FC<TitleSequenceProps> = ({ component }) => {
    const style = component.style || {};
    const position = style.position || { x: 0, y: 0 };

    return (
        <AbsoluteFill>
            <div style={{
                position: 'absolute',
                left: position.x,
                top: position.y,
                fontSize: style.fontSize || 60,
                fontFamily: style.fontFamily || 'Arial',
                color: style.color || 'white',
                textAlign: style.textAlign || 'center',
                width: style.position?.width || 300,
                fontWeight: 'bold',
                transform: 'translate(0, 0)', // Prevent any transform issues
            }}>
                {component.text}
            </div>
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\TransitionSequence.tsx ---

import React from 'react';
import { AbsoluteFill } from 'remotion';
import { TransitionComponent } from '../../types/script';

interface TransitionSequenceProps {
    component: TransitionComponent;
}

export const TransitionSequence: React.FC<TransitionSequenceProps> = ({ component }) => {
    return (
        <AbsoluteFill style={{
            backgroundColor: 'black',
        }} />
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\VideoComponent.tsx ---

import React, { useEffect, useRef, useState } from 'react';
import { useCurrentFrame, useVideoConfig } from 'remotion';
import { VideoComponent as VideoComponentType } from '../../types/script';
import { getAnimationStyle } from '../../utils/animation';

interface VideoComponentProps {
    component: VideoComponentType;
}

export const VideoComponent: React.FC<VideoComponentProps> = ({ component }) => {
    const frame = useCurrentFrame();
    const { fps } = useVideoConfig();
    const videoRef = useRef<HTMLVideoElement>(null);
    const canvasRef = useRef<HTMLCanvasElement>(null);
    const animationFrameRef = useRef<number | undefined>(undefined);
    const [proxyUrl, setProxyUrl] = useState<string | null>(null);
    const [videoLoaded, setVideoLoaded] = useState(false);
    const [videoDuration, setVideoDuration] = useState(0);

    const style = component.style || {};
    const animationStyle = getAnimationStyle(frame, fps, style.animation);

    // Calculate current video time based on frame
    const videoTime = (frame / fps) + (style.startTime || 0);

    useEffect(() => {
        const proxyVideo = async () => {
            try {
                console.log('Proxying video:', component.videoUrl);
                const response = await fetch('http://localhost:3005/proxy_video', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ url: component.videoUrl }),
                });

                if (!response.ok) {
                    throw new Error('Failed to proxy video');
                }

                const data = await response.json();
                console.log('Received proxy URL:', data.url);
                setProxyUrl(data.url);
            } catch (error) {
                console.error('Error proxying video:', error);
            }
        };

        if (component.videoUrl) {
            proxyVideo();
        }

        return () => {
            setProxyUrl(null);
            setVideoLoaded(false);
        };
    }, [component.videoUrl]);

    // Sync video time with timeline
    useEffect(() => {
        const video = videoRef.current;
        if (!video || !videoLoaded) return;

        // Update video time
        if (Math.abs(video.currentTime - videoTime) > 0.1) {
            video.currentTime = videoTime;
        }

        // Update component duration when video metadata is loaded
        if (videoDuration === 0 && video.duration) {
            setVideoDuration(video.duration);
            // If this is a new video, update the component's duration
            if (!component.style?.duration) {
                const durationInFrames = Math.ceil(video.duration * fps);
                // You'll need to implement this update function in your state management
                // updateComponentDuration(component.id, durationInFrames);
            }
        }
    }, [frame, fps, videoLoaded, videoTime, videoDuration]);

    useEffect(() => {
        if (!videoRef.current || !canvasRef.current || !style.chromakey?.enabled || !proxyUrl || !videoLoaded) {
            console.log('Skipping chromakey setup. Conditions:', {
                hasVideoRef: !!videoRef.current,
                hasCanvasRef: !!canvasRef.current,
                chromakeyEnabled: style.chromakey?.enabled,
                hasProxyUrl: !!proxyUrl,
                videoLoaded
            });
            return;
        }

        console.log('Setting up chromakey effect with settings:', style.chromakey);

        const video = videoRef.current;
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        if (!ctx) {
            console.error('Failed to get canvas context');
            return;
        }

        const updateCanvasSize = () => {
            const newWidth = video.videoWidth || video.clientWidth;
            const newHeight = video.videoHeight || video.clientHeight;
            console.log('Updating canvas size:', { width: newWidth, height: newHeight });
            canvas.width = newWidth;
            canvas.height = newHeight;
        };

        const processFrame = () => {
            try {
                // Only process frame if video is at the correct time
                if (Math.abs(video.currentTime - videoTime) <= 0.1) {
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    
                    if (style.chromakey?.enabled) {
                        try {
                            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            const data = imageData.data;

                            const keyColor = style.chromakey.color || '#00ff00';
                            const r = parseInt(keyColor.slice(1, 3), 16);
                            const g = parseInt(keyColor.slice(3, 5), 16);
                            const b = parseInt(keyColor.slice(5, 7), 16);

                            const similarity = (style.chromakey.similarity || 0.4) * 255;
                            const smoothness = style.chromakey.smoothness || 0.1;

                            for (let i = 0; i < data.length; i += 4) {
                                const pixelR = data[i];
                                const pixelG = data[i + 1];
                                const pixelB = data[i + 2];

                                const diff = Math.sqrt(
                                    Math.pow(pixelR - r, 2) * 0.3 +
                                    Math.pow(pixelG - g, 2) * 0.59 +
                                    Math.pow(pixelB - b, 2) * 0.11
                                );

                                if (diff < similarity) {
                                    const alpha = Math.max(0, diff / (similarity * smoothness));
                                    data[i + 3] = Math.min(255, alpha * 255);
                                }
                            }

                            ctx.putImageData(imageData, 0, 0);
                        } catch (error) {
                            console.error('Error processing chromakey:', error);
                        }
                    }
                }

                // Request next frame
                animationFrameRef.current = requestAnimationFrame(processFrame);
            } catch (error) {
                console.error('Error processing frame:', error);
            }
        };

        updateCanvasSize();
        processFrame();

        return () => {
            if (animationFrameRef.current) {
                cancelAnimationFrame(animationFrameRef.current);
            }
        };
    }, [style.chromakey, proxyUrl, videoLoaded, videoTime]);

    const containerStyle: React.CSSProperties = {
        position: 'absolute',
        width: `${style.width || 100}%`,
        height: `${style.height || 100}%`,
        left: `${style.position?.x || 0}%`,
        top: `${style.position?.y || 0}%`,
        transform: `translate(-50%, -50%) scale(${style.scale || 1}) rotate(${style.rotation || 0}deg)`,
        opacity: style.opacity ?? 1,
        ...animationStyle,
    };

    if (!proxyUrl) {
        return <div style={containerStyle}>Loading video...</div>;
    }

    if (style.chromakey?.enabled) {
        return (
            <div style={containerStyle}>
                <video
                    ref={videoRef}
                    src={proxyUrl}
                    style={{ display: 'none' }}
                    autoPlay={false}
                    loop={false}
                    muted
                    playsInline
                    crossOrigin="anonymous"
                    onLoadedData={() => {
                        console.log('Video loaded');
                        setVideoLoaded(true);
                    }}
                />
                <canvas
                    ref={canvasRef}
                    style={{
                        width: '100%',
                        height: '100%',
                        objectFit: 'contain',
                    }}
                />
            </div>
        );
    }

    return (
        <div style={containerStyle}>
            <video
                ref={videoRef}
                src={proxyUrl}
                style={{
                    width: '100%',
                    height: '100%',
                    objectFit: 'contain',
                }}
                autoPlay={false}
                loop={false}
                muted
                playsInline
                crossOrigin="anonymous"
                onLoadedData={() => setVideoLoaded(true)}
            />
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\VideoPositioningScreen.tsx ---

import React from 'react';
import { VideoComponent } from '../../types/script';
import { theme } from '../../styles/theme';

interface VideoPositioningScreenProps {
    component: VideoComponent;
    onChange: (component: VideoComponent) => void;
}

export const VideoPositioningScreen: React.FC<VideoPositioningScreenProps> = ({ component, onChange }) => {
    const handlePositionChange = (x: number, y: number) => {
        onChange({
            ...component,
            style: {
                ...component.style,
                position: { x, y }
            }
        });
    };

    const handleSizeChange = (width: number, height: number) => {
        onChange({
            ...component,
            style: {
                ...component.style,
                width,
                height
            }
        });
    };

    const handleTimeChange = (startTime: number, duration: number) => {
        onChange({
            ...component,
            style: {
                ...component.style,
                startTime,
                duration
            }
        });
    };

    return (
        <div style={styles.container}>
            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Position</h3>
                <div style={styles.inputGroup}>
                    <label style={styles.label}>X Position (%)</label>
                    <input
                        type="number"
                        value={component.style?.position?.x || 0}
                        onChange={(e) => handlePositionChange(Number(e.target.value), component.style?.position?.y || 0)}
                        style={styles.input}
                        min={-100}
                        max={100}
                        step={1}
                    />
                </div>
                <div style={styles.inputGroup}>
                    <label style={styles.label}>Y Position (%)</label>
                    <input
                        type="number"
                        value={component.style?.position?.y || 0}
                        onChange={(e) => handlePositionChange(component.style?.position?.x || 0, Number(e.target.value))}
                        style={styles.input}
                        min={-100}
                        max={100}
                        step={1}
                    />
                </div>
            </div>

            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Size</h3>
                <div style={styles.inputGroup}>
                    <label style={styles.label}>Width (%)</label>
                    <input
                        type="number"
                        value={component.style?.width || 100}
                        onChange={(e) => handleSizeChange(Number(e.target.value), component.style?.height || 100)}
                        style={styles.input}
                        min={1}
                        max={500}
                        step={1}
                    />
                </div>
                <div style={styles.inputGroup}>
                    <label style={styles.label}>Height (%)</label>
                    <input
                        type="number"
                        value={component.style?.height || 100}
                        onChange={(e) => handleSizeChange(component.style?.width || 100, Number(e.target.value))}
                        style={styles.input}
                        min={1}
                        max={500}
                        step={1}
                    />
                </div>
            </div>

            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Time Control</h3>
                <div style={styles.inputGroup}>
                    <label style={styles.label}>Start Time (seconds)</label>
                    <input
                        type="number"
                        value={component.style?.startTime || 0}
                        onChange={(e) => handleTimeChange(Number(e.target.value), component.style?.duration || 0)}
                        style={styles.input}
                        min={0}
                        step={0.1}
                    />
                </div>
                <div style={styles.inputGroup}>
                    <label style={styles.label}>Duration (seconds)</label>
                    <input
                        type="number"
                        value={component.style?.duration || 0}
                        onChange={(e) => handleTimeChange(component.style?.startTime || 0, Number(e.target.value))}
                        style={styles.input}
                        min={0.1}
                        step={0.1}
                    />
                </div>
            </div>
        </div>
    );
};

const styles = {
    container: {
        padding: '1rem',
        backgroundColor: theme.backgroundLight,
        borderRadius: '8px',
        display: 'flex',
        flexDirection: 'column' as const,
        gap: '1rem',
    },
    section: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: '0.5rem',
    },
    sectionTitle: {
        margin: 0,
        color: theme.textPrimary,
        fontSize: '1rem',
        fontWeight: 600,
    },
    inputGroup: {
        display: 'flex',
        alignItems: 'center',
        gap: '0.5rem',
    },
    label: {
        color: theme.textSecondary,
        fontSize: '0.9rem',
        minWidth: '120px',
    },
    input: {
        padding: '0.25rem 0.5rem',
        borderRadius: '4px',
        border: `1px solid ${theme.borderColor}`,
        backgroundColor: theme.backgroundDark,
        color: theme.textPrimary,
        width: '80px',
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\common\ColorPicker.tsx ---

import React from 'react';
import { theme } from '../../styles/theme';

interface ColorPickerProps {
    label: string;
    color: string;
    onChange: (color: string) => void;
}

export const ColorPicker: React.FC<ColorPickerProps> = ({
    label,
    color,
    onChange,
}) => {
    return (
        <div style={styles.container}>
            <label style={styles.label}>{label}</label>
            <div style={styles.inputContainer}>
                <input
                    type="color"
                    value={color}
                    onChange={(e) => onChange(e.target.value)}
                    style={styles.colorInput}
                />
                <input
                    type="text"
                    value={color}
                    onChange={(e) => onChange(e.target.value)}
                    style={styles.textInput}
                />
            </div>
        </div>
    );
};

const styles = {
    container: {
        marginBottom: theme.spacing.sm,
    },
    label: {
        display: 'block',
        marginBottom: theme.spacing.xs,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
    },
    inputContainer: {
        display: 'flex',
        gap: theme.spacing.sm,
        alignItems: 'center',
    },
    colorInput: {
        width: '40px',
        height: '40px',
        padding: 0,
        border: `1px solid ${theme.colors.border}`,
        borderRadius: theme.borderRadius.sm,
        cursor: 'pointer',
    },
    textInput: {
        flex: 1,
        padding: theme.spacing.sm,
        backgroundColor: theme.colors.background.tertiary,
        border: `1px solid ${theme.colors.border}`,
        borderRadius: theme.borderRadius.sm,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\common\IconButton.tsx ---

import React, { useState } from 'react';
import { theme } from '../../styles/theme';

interface IconButtonProps {
    icon: string;
    onClick: () => void;
    tooltip?: string;
    disabled?: boolean;
    size?: 'sm' | 'md' | 'lg';
    variant?: 'primary' | 'secondary' | 'ghost';
}

export const IconButton: React.FC<IconButtonProps> = ({
    icon,
    onClick,
    tooltip,
    disabled = false,
    size = 'md',
    variant = 'ghost',
}) => {
    const [isHovered, setIsHovered] = useState(false);

    const sizeMap = {
        sm: {
            padding: theme.spacing.xs,
            fontSize: theme.fontSizes.sm,
        },
        md: {
            padding: theme.spacing.sm,
            fontSize: theme.fontSizes.md,
        },
        lg: {
            padding: theme.spacing.md,
            fontSize: theme.fontSizes.lg,
        },
    };

    const variantMap = {
        primary: {
            backgroundColor: theme.colors.primary,
            color: theme.colors.text.primary,
            hoverBg: theme.colors.accent.red,
        },
        secondary: {
            backgroundColor: theme.colors.background.tertiary,
            color: theme.colors.text.primary,
            hoverBg: theme.colors.background.secondary,
        },
        ghost: {
            backgroundColor: 'transparent',
            color: theme.colors.text.primary,
            hoverBg: theme.colors.background.tertiary,
        },
    };

    const currentVariant = variantMap[variant];

    return (
        <button
            onClick={onClick}
            disabled={disabled}
            title={tooltip}
            onMouseEnter={() => setIsHovered(true)}
            onMouseLeave={() => setIsHovered(false)}
            style={{
                border: 'none',
                borderRadius: theme.borderRadius.md,
                cursor: disabled ? 'not-allowed' : 'pointer',
                opacity: disabled ? 0.5 : 1,
                transition: theme.transitions.fast,
                backgroundColor: isHovered && !disabled ? currentVariant.hoverBg : currentVariant.backgroundColor,
                color: currentVariant.color,
                ...sizeMap[size],
                display: 'inline-flex',
                alignItems: 'center',
                justifyContent: 'center',
                minWidth: sizeMap[size].fontSize,
                minHeight: sizeMap[size].fontSize,
                padding: sizeMap[size].padding,
                outline: 'none',
                boxShadow: isHovered && !disabled ? theme.shadows.sm : 'none',
            }}
        >
            {icon}
        </button>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\common\Modal.tsx ---

import React from 'react';
import { theme } from '../../styles/theme';

interface ModalProps {
    isOpen: boolean;
    onClose: () => void;
    title: React.ReactNode;
    children: React.ReactNode;
}

export const Modal: React.FC<ModalProps> = ({ isOpen, onClose, title, children }) => {
    if (!isOpen) return null;

    return (
        <div style={{
            position: 'fixed',
            top: '48px', // Header height
            left: 0,
            width: '75%', // Match the timeline section width
            height: 'calc(100vh - 48px)',
            backgroundColor: 'rgba(0, 0, 0, 0.75)',
            display: 'flex',
            justifyContent: 'flex-start',
            alignItems: 'center',
            zIndex: 1000,
            backdropFilter: 'blur(4px)',
            padding: theme.spacing.xl,
        }}>
            <div style={{
                backgroundColor: theme.colors.background.primary,
                borderRadius: theme.borderRadius.lg,
                border: `1px solid ${theme.colors.border}`,
                boxShadow: '0 8px 32px rgba(0, 0, 0, 0.4)',
                width: '90%',
                maxWidth: '800px',
                maxHeight: '90vh',
                display: 'flex',
                flexDirection: 'column',
                overflow: 'hidden',
                marginLeft: theme.spacing.xl,
            }}>
                {/* Header */}
                <div style={{
                    padding: theme.spacing.lg,
                    borderBottom: `1px solid ${theme.colors.border}`,
                    backgroundColor: theme.colors.background.secondary,
                    position: 'relative',
                }}>
                    <button
                        onClick={onClose}
                        style={{
                            position: 'absolute',
                            top: '50%',
                            right: theme.spacing.md,
                            transform: 'translateY(-50%)',
                            background: 'none',
                            border: 'none',
                            color: theme.colors.text.secondary,
                            fontSize: '24px',
                            cursor: 'pointer',
                            width: '32px',
                            height: '32px',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            borderRadius: theme.borderRadius.sm,
                            transition: 'all 0.2s ease',
                        }}
                        onMouseEnter={(e) => {
                            e.currentTarget.style.backgroundColor = theme.colors.background.tertiary;
                            e.currentTarget.style.color = theme.colors.text.primary;
                        }}
                        onMouseLeave={(e) => {
                            e.currentTarget.style.backgroundColor = 'transparent';
                            e.currentTarget.style.color = theme.colors.text.secondary;
                        }}
                    >
                        ×
                    </button>
                    <div style={{ paddingRight: '32px' }}>
                        {title}
                    </div>
                </div>

                {/* Content */}
                <div style={{
                    flex: 1,
                    overflow: 'auto',
                    padding: theme.spacing.lg,
                }}>
                    {children}
                </div>
            </div>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\common\Slider.tsx ---

import React from 'react';
import { theme } from '../../styles/theme';

interface SliderProps {
    label: string;
    value: number;
    onChange: (value: number) => void;
    min: number;
    max: number;
    step?: number;
}

export const Slider: React.FC<SliderProps> = ({
    label,
    value,
    onChange,
    min,
    max,
    step = 1,
}) => {
    return (
        <div style={styles.container}>
            <div style={styles.header}>
                <label style={styles.label}>{label}</label>
                <input
                    type="number"
                    value={value}
                    onChange={(e) => onChange(Number(e.target.value))}
                    min={min}
                    max={max}
                    step={step}
                    style={styles.numberInput}
                />
            </div>
            <input
                type="range"
                value={value}
                onChange={(e) => onChange(Number(e.target.value))}
                min={min}
                max={max}
                step={step}
                style={styles.slider}
            />
        </div>
    );
};

const styles = {
    container: {
        marginBottom: theme.spacing.sm,
    },
    header: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: theme.spacing.xs,
    },
    label: {
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
    },
    numberInput: {
        width: '60px',
        padding: theme.spacing.xs,
        backgroundColor: theme.colors.background.tertiary,
        border: `1px solid ${theme.colors.border}`,
        borderRadius: theme.borderRadius.sm,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
        textAlign: 'right' as const,
    },
    slider: {
        width: '100%',
        height: '2px',
        WebkitAppearance: 'none',
        background: theme.colors.primary,
        outline: 'none',
        opacity: 0.7,
        transition: 'opacity 0.2s',
        cursor: 'pointer',
        '&:hover': {
            opacity: 1,
        },
        '&::-webkit-slider-thumb': {
            WebkitAppearance: 'none',
            appearance: 'none',
            width: '16px',
            height: '16px',
            background: theme.colors.primary,
            borderRadius: '50%',
            cursor: 'pointer',
        },
        '&::-moz-range-thumb': {
            width: '16px',
            height: '16px',
            background: theme.colors.primary,
            borderRadius: '50%',
            cursor: 'pointer',
        },
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\common\Switch.tsx ---

import React from 'react';
import { theme } from '../../styles/theme';

interface SwitchProps {
    label: string;
    checked: boolean;
    onChange: (checked: boolean) => void;
}

export const Switch: React.FC<SwitchProps> = ({
    label,
    checked,
    onChange,
}) => {
    return (
        <div style={styles.container}>
            <label style={styles.label}>
                <input
                    type="checkbox"
                    checked={checked}
                    onChange={(e) => onChange(e.target.checked)}
                    style={styles.input}
                />
                <span style={styles.switch}>
                    <span style={{
                        ...styles.slider,
                        transform: checked ? 'translateX(20px)' : 'translateX(0)',
                        backgroundColor: checked ? theme.colors.primary : theme.colors.background.tertiary,
                    }} />
                </span>
                <span style={styles.text}>{label}</span>
            </label>
        </div>
    );
};

const styles = {
    container: {
        marginBottom: theme.spacing.sm,
    },
    label: {
        display: 'flex',
        alignItems: 'center',
        cursor: 'pointer',
        userSelect: 'none' as const,
    },
    input: {
        display: 'none',
    },
    switch: {
        position: 'relative' as const,
        display: 'inline-block',
        width: '40px',
        height: '20px',
        backgroundColor: theme.colors.background.secondary,
        borderRadius: '10px',
        marginRight: theme.spacing.sm,
    },
    slider: {
        position: 'absolute' as const,
        top: '2px',
        left: '2px',
        width: '16px',
        height: '16px',
        borderRadius: '50%',
        transition: 'transform 0.2s, background-color 0.2s',
    },
    text: {
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
    },
}; 



--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\data\quizData.ts ---

import { Photo } from 'pexels';

export interface QuizItem {
	question: string;
	leftOption: {
		image: string;
		text: string;
		pexelsPhoto?: Photo;
	};
	rightOption: {
		image: string;
		text: string;
		pexelsPhoto?: Photo;
	};
	voiceover: string;
}

export const QUIZ_DATA: QuizItem[] = [
	{
		question: 'Coffee or Tea?',
		leftOption: {
			image: '',
			text: 'Coffee',
		},
		rightOption: {
			image: '',
			text: 'Tea',
		},
		voiceover: 'Coffee or Tea?',
	},
	// Add more comparison items here
]; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\font_service.py ---

from flask import Flask, send_file, jsonify, request
from flask_cors import CORS
import os
import json
from werkzeug.utils import secure_filename

app = Flask(__name__)
CORS(app, resources={
    r"/*": {
        "origins": ["http://localhost:3000", "http://localhost:3001"],
        "methods": ["GET", "POST", "OPTIONS"],
        "allow_headers": ["Content-Type"]
    }
})

# Ensure fonts directory exists
FONTS_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'public', 'fonts')
os.makedirs(FONTS_DIR, exist_ok=True)

# Load or create font dictionary
FONT_DICT_FILE = os.path.join(FONTS_DIR, 'font_dictionary.json')

def load_font_dictionary():
    if os.path.exists(FONT_DICT_FILE):
        try:
            with open(FONT_DICT_FILE, 'r') as f:
                return json.load(f)
        except:
            return {}
    return {}

def save_font_dictionary(font_dict):
    with open(FONT_DICT_FILE, 'w') as f:
        json.dump(font_dict, f, indent=2)

# Initialize font dictionary
font_dictionary = load_font_dictionary()

@app.route('/fonts/<path:filename>')
def serve_font(filename):
    return send_file(os.path.join(FONTS_DIR, filename))

@app.route('/fonts/dictionary', methods=['GET'])
def get_font_dictionary():
    print("Serving font dictionary:", font_dictionary)
    return jsonify(font_dictionary)

@app.route('/set_font', methods=['POST'])
def set_font():
    try:
        print("Received font upload request")
        if 'file' not in request.files:
            return jsonify({'error': 'No file provided'}), 400
        
        file = request.files['file']
        if file.filename == '':
            return jsonify({'error': 'No file selected'}), 400

        if not file.filename.lower().endswith(('.otf', '.ttf')):
            return jsonify({'error': 'Invalid file type. Only .otf and .ttf files are allowed'}), 400

        filename = secure_filename(file.filename)
        filepath = os.path.join(FONTS_DIR, filename)
        file.save(filepath)
        print(f"Saved font to: {filepath}")

        # Update font dictionary
        font_name = os.path.splitext(filename)[0]
        font_url = f'http://localhost:3003/fonts/{filename}'
        font_dictionary[font_name] = {
            'url': font_url,
            'path': filepath,
            'format': 'opentype' if filename.lower().endswith('.otf') else 'truetype'
        }
        save_font_dictionary(font_dictionary)
        print(f"Updated font dictionary with: {font_name}")

        return jsonify({
            'success': True,
            'message': 'Font uploaded',
            'url': font_url,
            'name': font_name
        })
    except Exception as e:
        print(f"Error uploading font: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/delete_font', methods=['POST'])
def delete_font():
    try:
        data = request.json
        if not data or 'name' not in data:
            return jsonify({'error': 'Font name not provided'}), 400

        font_name = data['name']
        if font_name not in font_dictionary:
            return jsonify({'error': 'Font not found'}), 404

        # Delete the font file
        font_path = font_dictionary[font_name]['path']
        if os.path.exists(font_path):
            os.remove(font_path)

        # Remove from dictionary
        del font_dictionary[font_name]
        save_font_dictionary(font_dictionary)

        return jsonify({
            'success': True,
            'message': 'Font deleted'
        })
    except Exception as e:
        print(f"Error deleting font: {e}")
        return jsonify({'error': str(e)}), 500

if __name__ == '__main__':
    print("Starting font service on port 3003...")
    print(f"Fonts directory: {FONTS_DIR}")
    print(f"Font dictionary: {font_dictionary}")
    app.run(port=3003, debug=True) 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\index.ts ---

import { registerRoot } from "remotion";
import "./styles/globals.css";
import { RemotionRoot } from "./Root";

registerRoot(RemotionRoot);



--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\pages\_app.tsx ---

import type { AppProps } from 'next/app';
import '../styles/globals.css';

export default function App({ Component, pageProps }: AppProps) {
  return <Component {...pageProps} />;
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\pages\api\copy-background.ts ---

import { NextApiRequest, NextApiResponse } from 'next';
import fs from 'fs';
import path from 'path';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
    if (req.method !== 'POST') {
        return res.status(405).json({ message: 'Method not allowed' });
    }

    try {
        const { name, data } = req.body;
        
        // Extract base64 data
        const base64Data = data.split(';base64,').pop();
        const buffer = Buffer.from(base64Data, 'base64');

        // Define all possible paths where we might need the file
        const paths = [
            path.join(process.cwd(), 'public', 'backgrounds'), // Next.js public
            path.join(process.cwd(), '..', 'public', 'backgrounds'), // One level up
            path.join(process.cwd(), 'backgrounds'), // Root level
            path.join(process.cwd(), '..', 'backgrounds'), // One level up root
        ];

        // Create directories and save file in all locations
        const savedPaths = [];
        for (const dir of paths) {
            try {
                if (!fs.existsSync(dir)) {
                    fs.mkdirSync(dir, { recursive: true });
                }
                const filePath = path.join(dir, name);
                fs.writeFileSync(filePath, buffer);
                savedPaths.push(filePath);
            } catch (err) {
                console.error(`Failed to save to ${dir}:`, err);
            }
        }

        // Verify files were saved
        const verification = savedPaths.map(p => ({
            path: p,
            exists: fs.existsSync(p),
            size: fs.existsSync(p) ? fs.statSync(p).size : 0
        }));

        console.log('File save verification:', verification);

        if (verification.some(v => v.exists)) {
            res.status(200).json({ 
                message: 'File copied successfully',
                verification 
            });
        } else {
            throw new Error('Failed to save file in any location');
        }
    } catch (error) {
        console.error('Error copying file:', error);
        res.status(500).json({ message: 'Failed to copy file' });
    }
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\pages\api\get-path.ts ---

import { NextApiRequest, NextApiResponse } from 'next';
import fs from 'fs';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
    if (req.method !== 'GET') {
        return res.status(405).json({ error: 'Method not allowed' });
    }

    try {
        // Read from the exact location specified
        const filePath = 'D:\\Projects\\Remotion Couples Quiz\\path.txt';
        const backgroundPath = fs.readFileSync(filePath, 'utf8');
        
        console.log('Read background path:', backgroundPath);
        
        // Return the path as plain text
        res.setHeader('Content-Type', 'text/plain');
        return res.status(200).send(backgroundPath);
    } catch (error) {
        console.error('Error reading path:', error);
        return res.status(500).json({ error: 'Failed to read path' });
    }
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\pages\api\save-path.ts ---

import { NextApiRequest, NextApiResponse } from 'next';
import fs from 'fs';
import path from 'path';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
    if (req.method !== 'POST') {
        return res.status(405).json({ error: 'Method not allowed' });
    }

    try {
        const { selectedPath } = req.body;
        if (!selectedPath) {
            return res.status(400).json({ error: 'No path provided' });
        }

        // Write to the exact location specified
        const filePath = 'D:\\Projects\\Remotion Couples Quiz\\path.txt';
        
        // Write the path to the file
        fs.writeFileSync(filePath, selectedPath, 'utf8');
        
        console.log('Saved path to:', filePath);
        console.log('Path content:', selectedPath);

        return res.status(200).json({ success: true });
    } catch (error) {
        console.error('Error saving path:', error);
        return res.status(500).json({ error: 'Failed to save path' });
    }
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\pages\index.tsx ---

import React, { useState } from 'react';
import { Player } from '@remotion/player';
import { AppLayout } from '../components/Layout/AppLayout';
import { ComponentPalette } from '../components/ScriptEditor/ComponentPalette';
import { Script, ComponentType } from '../types/script';
import { ScriptVideo } from '../components/Video/ScriptVideo';
import { theme } from '../styles/theme';

export default function Home() {
    const [script, setScript] = useState<Script>({
        id: Date.now().toString(),
        title: 'New Quiz',
        components: [],
        captionTracks: [],
        settings: {
            defaultTextStyle: {
                fontSize: 40,
                color: 'white',
                fontFamily: 'Arial',
                textAlign: 'center',
            },
            defaultCaptionStyle: {
                fontSize: 24,
                color: 'white',
                fontFamily: 'Arial',
                textAlign: 'center',
            },
            background: {
                type: 'none',
            },
        },
    });

    const handleDragStart = (type: ComponentType) => {
        // Handle component drag start
        console.log('Dragging component:', type);
    };

    return (
        <AppLayout>
            {/* Left Sidebar Content */}
            <div style={{
                display: 'flex',
                flexDirection: 'column',
                gap: theme.spacing.lg,
            }}>
                <ComponentPalette onDragStart={handleDragStart} />
            </div>

            {/* Center Content */}
            <div style={{
                display: 'flex',
                flexDirection: 'column',
                gap: theme.spacing.lg,
            }}>
                {/* Preview */}
                <div style={{
                    flex: 1,
                    position: 'relative',
                    backgroundColor: theme.colors.background.tertiary,
                    borderRadius: theme.borderRadius.lg,
                    overflow: 'hidden',
                    padding: theme.spacing.lg,
                }}>
                    <div style={{
                        position: 'relative',
                        width: '100%',
                        height: '100%',
                        backgroundColor: '#000',
                        borderRadius: theme.borderRadius.md,
                        overflow: 'hidden',
                    }}>
                        <Player
                            component={ScriptVideo}
                            durationInFrames={300}
                            fps={30}
                            compositionWidth={1080}
                            compositionHeight={1920}
                            style={{
                                width: '100%',
                                height: '100%',
                            }}
                            controls
                            autoPlay
                            loop
                            inputProps={{
                                script,
                            }}
                        />
                    </div>
                </div>

                {/* Timeline */}
                <div style={{
                    height: '200px',
                    backgroundColor: theme.colors.background.secondary,
                    borderRadius: theme.borderRadius.lg,
                    padding: theme.spacing.lg,
                    border: `1px solid ${theme.colors.border}`,
                }}>
                    <h2 style={{
                        color: theme.colors.text.primary,
                        marginBottom: theme.spacing.md,
                        fontSize: '18px',
                    }}>Timeline</h2>
                    {/* Timeline content will go here */}
                </div>
            </div>

            {/* Right Sidebar Content */}
            <div style={{
                backgroundColor: theme.colors.background.secondary,
                borderRadius: theme.borderRadius.lg,
                padding: theme.spacing.lg,
                border: `1px solid ${theme.colors.border}`,
            }}>
                <h2 style={{
                    color: theme.colors.text.primary,
                    marginBottom: theme.spacing.md,
                    fontSize: '18px',
                }}>Properties</h2>
                {/* Properties panel content will go here */}
            </div>
        </AppLayout>
    );
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\preview-entry.ts ---

import { registerRoot } from 'remotion';
import { Preview } from './Preview';

// Register the Preview component as the root
registerRoot(Preview); 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\preview-entry.tsx ---

import React from 'react';
import { registerRoot } from 'remotion';
import { Composition } from 'remotion';
import { ScriptVideo } from './components/Video/ScriptVideo';
import { Script } from './types/script';

// Preview component that uses the background path
const Preview: React.FC = () => {
  // Get script from URL params
  const params = new URLSearchParams(window.location.search);
  const propsParam = params.get('props');
  let script: Script | undefined;
  
  try {
    if (propsParam) {
      script = JSON.parse(decodeURIComponent(propsParam));
    }
  } catch (e) {
    console.error('Failed to parse script from URL:', e);
  }

  // Fallback script if none provided
  const defaultScript: Script = {
    id: 'default',
    title: 'Default Script',
    components: [],
    captionTracks: [],
    settings: {
      defaultTextStyle: {
        fontSize: 40,
        color: 'white',
        fontFamily: 'Arial',
        textAlign: 'center'
      },
      defaultCaptionStyle: {
        fontSize: 24,
        color: 'white',
        fontFamily: 'Arial',
        textAlign: 'center'
      },
      background: {
        type: 'none'
      }
    }
  };

  return (
    <Composition
      id="ScriptVideo"
      component={ScriptVideo}
      durationInFrames={300}
      fps={30}
      width={1080}
      height={1920}
      defaultProps={{
        script: script || defaultScript
      }}
    />
  );
};

registerRoot(Preview); 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\public\fonts\font_dictionary.json ---

{
  "tiktok": {
    "url": "http://localhost:3003/fonts/tiktok.otf",
    "path": "D:\\Projects\\Remotion Couples Quiz\\my-video\\src\\public\\fonts\\tiktok.otf",
    "format": "opentype"
  }
}


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\remotion\VideoRoot.tsx ---

import React from 'react';
import { Composition } from 'remotion';
import { ScriptVideo } from '../components/Video/ScriptVideo';

export const VideoRoot: React.FC = () => {
    return (
        <Composition
            id="ScriptVideo"
            component={ScriptVideo}
            durationInFrames={1800}
            fps={30}
            width={1080}
            height={1920}
            defaultProps={{
                script: {
                    id: '',
                    title: '',
                    components: [],
                    captionTracks: [],
                    settings: {
                        defaultTextStyle: {
                            fontSize: 40,
                            color: 'white',
                            fontFamily: 'Arial',
                            textAlign: 'center'
                        },
                        defaultCaptionStyle: {
                            fontSize: 24,
                            color: 'white',
                            fontFamily: 'Arial',
                            textAlign: 'center'
                        },
                        background: {
                            type: 'none'
                        }
                    }
                }
            }}
        />
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\remotion\index.ts ---

import { registerRoot } from 'remotion';
import { VideoRoot } from './VideoRoot';

registerRoot(VideoRoot); 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\render.mjs ---

import { bundle } from '@remotion/bundler';
import { renderMedia, selectComposition } from '@remotion/renderer';
import path from 'path';
import fs from 'fs';
import os from 'os';

async function renderVideo(inputProps) {
    try {
        console.log('Starting video render...');
        console.log('Input props:', JSON.stringify(inputProps, null, 2));

        // Create a webpack bundle of the video
        const bundleLocation = await bundle({
            entryPoint: path.resolve('./src/remotion/index.ts'),
            webpackOverride: (config) => ({
                ...config,
                output: {
                    ...config.output,
                    filename: 'bundle.js',
                },
            }),
        });

        console.log('Bundle created at:', bundleLocation);

        // Select the composition
        const composition = await selectComposition({
            serveUrl: bundleLocation,
            id: 'ScriptVideo',
            inputProps: {
                script: inputProps.script
            },
        });

        // Generate output path
        const outputLocation = path.resolve(
            `./public/videos/video-${Date.now()}.mp4`
        );

        // Ensure output directory exists
        const outputDir = path.dirname(outputLocation);
        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true });
        }

        console.log('Rendering video...');
        console.log('Output location:', outputLocation);

        // Render the video
        await renderMedia({
            composition,
            serveUrl: bundleLocation,
            codec: 'h264',
            outputLocation,
            inputProps: {
                script: inputProps.script
            },
            chromiumOptions: {
                headless: true,
                enableAcceleratedRendering: true,
                disableWebSecurity: true,
            },
            onProgress: ({ progress }) => {
                console.log(`Rendering progress: ${Math.floor(progress * 100)}%`);
            },
        });

        const publicUrl = `/videos/${path.basename(outputLocation)}`;
        console.log('Render complete!');
        console.log(JSON.stringify({
            success: true,
            outputLocation: publicUrl
        }));

    } catch (err) {
        console.error('Render failed:', err);
        console.log(JSON.stringify({
            success: false,
            error: err.message
        }));
        process.exit(1);
    }
}

// Get input props from command line argument
const inputProps = JSON.parse(process.argv[2]);
renderVideo(inputProps); 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\services\audioService.ts ---

import axios from 'axios';
import { WordTiming } from '../types/script';

const ELEVEN_LABS_API_KEY = process.env.REACT_APP_ELEVEN_LABS_API_KEY;
const ELEVEN_LABS_VOICE_ID = process.env.REACT_APP_ELEVEN_LABS_VOICE_ID;

export async function generateSpeech(text: string): Promise<{ url: string, blob: Blob }> {
    // Generate audio with ElevenLabs
    const audioResponse = await axios.post(
        `https://api.elevenlabs.io/v1/text-to-speech/${ELEVEN_LABS_VOICE_ID}`,
        {
            text,
            voice_settings: {
                stability: 0.75,
                similarity_boost: 0.75
            }
        },
        {
            headers: {
                'Content-Type': 'application/json',
                'xi-api-key': ELEVEN_LABS_API_KEY
            },
            responseType: 'blob'
        }
    );

    // Create a blob URL for the audio
    const audioBlob = new Blob([audioResponse.data], { type: 'audio/mpeg' });
    return {
        url: URL.createObjectURL(audioBlob),
        blob: audioBlob
    };
}

export async function generateCaptions(audioBlob: Blob): Promise<WordTiming[]> {
    // Create form data for the transcription request
    const formData = new FormData();
    formData.append('audio', audioBlob, 'speech.mp3');

    // Send to Whisper service for transcription
    const transcriptionResponse = await axios.post('http://localhost:5000/transcribe', formData, {
        headers: {
            'Content-Type': 'multipart/form-data'
        }
    });

    return transcriptionResponse.data.wordTimings;
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\services\elevenLabs.ts ---

import axios, { AxiosError } from 'axios';
import { WordTiming } from '../types/script';
import { useApiKeys } from '../store/apiKeysStore';

interface GenerateSpeechParams {
    text: string;
    voiceId: string;
    settings?: {
        stability?: number;
        similarity_boost?: number;
    };
}

export async function generateSpeech({ text, voiceId, settings = {} }: GenerateSpeechParams): Promise<{ audioUrl: string, wordTimings: WordTiming[] }> {
    console.log('[generateSpeech] Starting with params:', { text, voiceId, settings });
    
    const { elevenLabsApiKey } = useApiKeys.getState();
    console.log('[generateSpeech] Got API key:', elevenLabsApiKey ? 'Present' : 'Missing');

    if (!elevenLabsApiKey) {
        console.error('[generateSpeech] API key is missing');
        throw new Error('ElevenLabs API key is not set. Please set it in the settings menu.');
    }

    // Prepare request body
    const requestBody = {
        text,
        voiceId,
        model_id: "eleven_monolingual_v1",
        voice_settings: {
            stability: settings.stability ?? 0.75,
            similarity_boost: settings.similarity_boost ?? 0.75
        },
        apiKey: elevenLabsApiKey
    };
    console.log('[generateSpeech] Prepared request body:', requestBody);

    try {
        // Generate audio with ElevenLabs
        console.log('[generateSpeech] Sending request to:', `http://localhost:3005/generate_voice`);
        const audioResponse = await axios.post(
            `http://localhost:3005/generate_voice`,
            requestBody
        );
        console.log('[generateSpeech] Received response:', audioResponse.data);

        return {
            audioUrl: audioResponse.data.url,
            wordTimings: audioResponse.data.wordTimings || []
        };
    } catch (error) {
        const axiosError = error as AxiosError;
        console.error('[generateSpeech] Error details:', {
            error: axiosError.message,
            response: axiosError.response?.data,
            status: axiosError.response?.status,
            headers: axiosError.response?.headers
        });
        throw error;
    }
}

export async function generateCaptions(audioBlob: Blob): Promise<WordTiming[]> {
    console.log('[generateCaptions] Starting with audio blob size:', audioBlob.size);
    
    // Create form data for the transcription request
    const formData = new FormData();
    formData.append('audio', audioBlob, 'speech.mp3');

    try {
        // Send to Whisper service for transcription
        console.log('[generateCaptions] Sending request to transcription service');
        const transcriptionResponse = await axios.post('http://localhost:5000/transcribe', formData, {
            headers: {
                'Content-Type': 'multipart/form-data'
            }
        });
        console.log('[generateCaptions] Received response:', transcriptionResponse.data);

        return transcriptionResponse.data.wordTimings;
    } catch (error) {
        const axiosError = error as AxiosError;
        console.error('[generateCaptions] Error:', axiosError.message);
        throw error;
    }
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\services\pexels.ts ---

import { createClient, Photo } from 'pexels';

const client = createClient('rXEDE5m6pUxOXZPawHmzKj04Z29WlV2y0Us44ld2TmXwdZstXtHUIh2F');

export const searchImages = async (query: string): Promise<Photo[]> => {
  try {
    const response = await client.photos.search({
      query,
      per_page: 10,
    });
    return response.photos;
  } catch (error) {
    console.error('Error fetching images:', error);
    return [];
  }
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\services\templateService.ts ---

import { Template, TemplateComponent } from '../types/template';
import { Script, ScriptComponent } from '../types/script';

// Convert a script to a template
export const scriptToTemplate = (script: Script, name: string, description?: string): Template => {
    const templateComponents: TemplateComponent[] = script.components.map(component => {
        // Remove content-specific data but keep structure and styling
        const templateComponent = { ...component } as TemplateComponent;
        
        if ('text' in templateComponent) {
            delete (templateComponent as any).text;
            templateComponent.placeholderText = 'Enter your text here';
        }
        
        if ('audioUrl' in templateComponent) {
            delete (templateComponent as any).audioUrl;
        }
        
        if ('wordTimings' in templateComponent) {
            delete (templateComponent as any).wordTimings;
        }
        
        return templateComponent;
    });

    // Don't save blob URLs in templates
    const settings = { ...script.settings };
    if (settings.background?.url?.startsWith('blob:')) {
        settings.background = {
            ...settings.background,
            url: undefined
        };
    }

    return {
        id: `template_${Date.now()}`,
        name,
        description,
        components: templateComponents,
        settings
    };
};

// Convert a template to a script
export const templateToScript = (template: Template): Script => {
    const scriptComponents: ScriptComponent[] = template.components.map(component => {
        const scriptComponent = { ...component } as ScriptComponent;
        
        if (component.placeholderText) {
            (scriptComponent as any).text = component.placeholderText;
        }
        
        return scriptComponent;
    });

    return {
        id: `script_${Date.now()}`,
        title: `Script from ${template.name}`,
        components: scriptComponents,
        settings: template.settings
    };
};

// Save template to localStorage
export const saveTemplate = (template: Template): void => {
    const templates = getTemplates();
    templates.push(template);
    localStorage.setItem('video_templates', JSON.stringify(templates));
};

// Get all saved templates
export const getTemplates = (): Template[] => {
    const templatesJson = localStorage.getItem('video_templates');
    return templatesJson ? JSON.parse(templatesJson) : [];
};

// Get template by ID
export const getTemplateById = (id: string): Template | undefined => {
    const templates = getTemplates();
    return templates.find(t => t.id === id);
};

// Delete template
export const deleteTemplate = (id: string): void => {
    const templates = getTemplates();
    const filteredTemplates = templates.filter(t => t.id !== id);
    localStorage.setItem('video_templates', JSON.stringify(filteredTemplates));
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\services\videoService.ts ---

import { Script } from '../types/script';
import axios from 'axios';

const RENDER_SERVICE_URL = 'http://localhost:29382';

interface ExportSettings {
    fps: number;
    width: number;
    height: number;
    codec: 'h264' | 'h265' | 'vp8' | 'vp9';
    quality: number;
}

export const addBackgroundToHistory = (script: Script, background: Script['settings']['background']) => {
    if (!background) return script;

    const newScript = { ...script };
    if (!newScript.settings.backgroundHistory) {
        newScript.settings.backgroundHistory = [];
    }

    // Add current background to history
    newScript.settings.backgroundHistory.push({
        ...background,
        timestamp: Date.now(),
        title: `Background ${newScript.settings.backgroundHistory.length + 1}`,
    });

    // Keep only the last 10 backgrounds
    if (newScript.settings.backgroundHistory.length > 10) {
        newScript.settings.backgroundHistory = newScript.settings.backgroundHistory.slice(-10);
    }

    return newScript;
};

export async function exportVideo(script: Script, settings: ExportSettings): Promise<{ success: boolean; outputPath: string }> {
    try {
        console.log('Starting video export process...', { script, settings });
        
        // Use our Python proxy service
        const response = await axios.post(`${RENDER_SERVICE_URL}/render`, {
            script,
            settings,
        }, {
            headers: {
                'Content-Type': 'application/json',
            },
        });

        console.log('Render API Response:', response.data);

        if (!response.data.success) {
            console.error('API Error:', response.data);
            throw new Error(response.data.error || 'Failed to render video');
        }

        const outputPath = response.data.outputPath;
        if (!outputPath) {
            console.error('API Response:', response.data);
            throw new Error('No output path received from render service');
        }

        return {
            success: true,
            outputPath,
        };
    } catch (error) {
        if (axios.isAxiosError(error)) {
            console.error('API Error Details:', {
                status: error.response?.status,
                statusText: error.response?.statusText,
                data: error.response?.data,
                headers: error.response?.headers,
            });
            throw new Error(error.response?.data?.error || error.message);
        }
        console.error('Error in video export:', error instanceof Error ? error.message : 'Unknown error');
        throw error;
    }
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\store\apiKeysStore.ts ---

import { create } from 'zustand';

interface ApiKeysState {
    elevenLabsApiKey: string;
    pexelsApiKey: string;
    setElevenLabsApiKey: (key: string) => void;
    setPexelsApiKey: (key: string) => void;
}

export const useApiKeys = create<ApiKeysState>((set) => ({
    elevenLabsApiKey: '',
    pexelsApiKey: '',
    setElevenLabsApiKey: (key) => set({ elevenLabsApiKey: key }),
    setPexelsApiKey: (key) => set({ pexelsApiKey: key }),
})); 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\store\configStore.ts ---

import { create } from 'zustand';
import { persist, PersistOptions } from 'zustand/middleware';

interface ConfigState {
    elevenLabsApiKey: string;
    pexelsApiKey: string;
    setElevenLabsApiKey: (key: string) => void;
    setPexelsApiKey: (key: string) => void;
}

type ConfigPersist = (
    config: (
        set: (state: Partial<ConfigState>) => void,
        get: () => ConfigState,
    ) => ConfigState,
    options: PersistOptions<ConfigState>
) => any;

export const useConfigStore = create<ConfigState>(
    (persist as ConfigPersist)(
        (set) => ({
            elevenLabsApiKey: '',
            pexelsApiKey: '',
            setElevenLabsApiKey: (key: string) => set({ elevenLabsApiKey: key }),
            setPexelsApiKey: (key: string) => set({ pexelsApiKey: key }),
        }),
        {
            name: 'video-maker-config',
        }
    )
); 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\styles\commonStyles.ts ---

import { theme } from './theme';

export const commonStyles = {
    card: {
        backgroundColor: theme.colors.background.secondary,
        borderRadius: theme.borderRadius.lg,
        padding: theme.spacing.lg,
        boxShadow: theme.shadows.md,
        border: `1px solid ${theme.colors.border}`,
    },
    input: {
        backgroundColor: theme.colors.background.tertiary,
        border: `1px solid ${theme.colors.border}`,
        borderRadius: theme.borderRadius.md,
        padding: theme.spacing.md,
        color: theme.colors.text.primary,
        fontSize: '14px',
        width: '100%',
        outline: 'none',
        transition: 'all 0.2s ease',
        '&:focus': {
            borderColor: theme.colors.primary,
            boxShadow: `0 0 0 2px ${theme.colors.primary}25`,
        },
    },
    button: {
        primary: {
            backgroundColor: theme.colors.primary,
            color: theme.colors.text.primary,
            border: 'none',
            borderRadius: theme.borderRadius.md,
            padding: `${theme.spacing.sm} ${theme.spacing.lg}`,
            cursor: 'pointer',
            transition: 'all 0.2s ease',
            '&:hover': {
                backgroundColor: `${theme.colors.primary}E6`,
            },
            '&:disabled': {
                opacity: 0.5,
                cursor: 'not-allowed',
            },
        },
        secondary: {
            backgroundColor: 'transparent',
            color: theme.colors.text.primary,
            border: `1px solid ${theme.colors.border}`,
            borderRadius: theme.borderRadius.md,
            padding: `${theme.spacing.sm} ${theme.spacing.lg}`,
            cursor: 'pointer',
            transition: 'all 0.2s ease',
            '&:hover': {
                backgroundColor: theme.colors.background.tertiary,
            },
        },
    },
    label: {
        color: theme.colors.text.secondary,
        fontSize: '14px',
        marginBottom: theme.spacing.xs,
        display: 'block',
    },
    heading: {
        color: theme.colors.text.primary,
        margin: `${theme.spacing.md} 0`,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\styles\globals.css ---

/* Reset and base styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html,
body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    overflow: hidden;
}

/* Scrollbar styling */
::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.1);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.2);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.3);
}

/* Button hover effects */
button {
    position: relative;
    overflow: hidden;
}

button::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 50%;
    transform: translate(-50%, -50%);
    transition: width 0.3s ease-out, height 0.3s ease-out;
}

button:hover::after {
    width: 300%;
    height: 300%;
}

/* Card hover effects */
[class*="card"] {
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

[class*="card"]:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
}

/* Input focus styles */
input:focus,
select:focus,
textarea:focus {
    outline: none;
    box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.4);
}

/* Gradient text */
.gradient-text {
    background: linear-gradient(135deg, #6366F1, #8B5CF6);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

/* Glass morphism effect */
.glass {
    background: rgba(255, 255, 255, 0.05);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
}

/* Animation classes */
.fade-in {
    animation: fadeIn 0.3s ease-in-out;
}

.slide-up {
    animation: slideUp 0.3s ease-out;
}

.scale-in {
    animation: scaleIn 0.3s ease-out;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes slideUp {
    from { transform: translateY(20px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
}

@keyframes scaleIn {
    from { transform: scale(0.95); opacity: 0; }
    to { transform: scale(1); opacity: 1; }
}

/* Tooltip styles */
[data-tooltip] {
    position: relative;
}

[data-tooltip]::before {
    content: attr(data-tooltip);
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    padding: 4px 8px;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    font-size: 12px;
    border-radius: 4px;
    white-space: nowrap;
    opacity: 0;
    visibility: hidden;
    transition: all 0.2s ease;
}

[data-tooltip]:hover::before {
    opacity: 1;
    visibility: visible;
    transform: translateX(-50%) translateY(-8px);
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\styles\theme.ts ---

export const theme = {
    colors: {
        primary: '#FF4B4B',
        secondary: '#2D2D2D',
        accent: {
            red: '#FF4B4B',
            orange: '#FF8F00',
            yellow: '#FFD600',
            green: '#00C853',
            blue: '#2196F3',
            purple: '#7C4DFF',
        },
        background: {
            primary: '#121212',
            secondary: '#1E1E1E',
            tertiary: '#252525',
            overlay: 'rgba(0, 0, 0, 0.8)',
        },
        text: {
            primary: '#FFFFFF',
            secondary: '#B3B3B3',
            accent: '#808080',
        },
        border: '#333333',
        error: '#FF4B4B',
        success: '#00C853',
        warning: '#FF8F00',
    },
    spacing: {
        xs: '4px',
        sm: '8px',
        md: '16px',
        lg: '24px',
        xl: '32px',
        xxl: '48px',
    },
    borderRadius: {
        sm: '4px',
        md: '6px',
        lg: '8px',
        xl: '12px',
        full: '9999px',
    },
    shadows: {
        sm: '0 2px 4px rgba(0, 0, 0, 0.2)',
        md: '0 4px 8px rgba(0, 0, 0, 0.3)',
        lg: '0 8px 16px rgba(0, 0, 0, 0.4)',
        xl: '0 12px 24px rgba(0, 0, 0, 0.5)',
        highlight: '0 0 0 1px rgba(255, 75, 75, 0.3)',
    },
    transitions: {
        fast: 'all 0.15s cubic-bezier(0.4, 0, 0.2, 1)',
        normal: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
        slow: 'all 0.5s cubic-bezier(0.4, 0, 0.2, 1)',
    },
    fonts: {
        heading: '"SF Pro Display", -apple-system, BlinkMacSystemFont, sans-serif',
        body: '"SF Pro Text", -apple-system, BlinkMacSystemFont, sans-serif',
        mono: '"SF Mono", "Fira Code", monospace',
    },
    fontSizes: {
        xs: '11px',
        sm: '13px',
        md: '14px',
        lg: '16px',
        xl: '18px',
        '2xl': '20px',
        '3xl': '24px',
    },
    componentColors: {
        text: '#2196F3',
        title: '#7C4DFF',
        voice: '#FF4B4B',
        comparison: '#00C853',
        countdown: '#FF8F00',
        transition: '#FFD600',
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\styles\timeline.css ---

.timeline-item {
    position: relative;
}

.timeline-item.drag-over::before {
    content: '';
    position: absolute;
    top: -2px;
    left: 0;
    right: 0;
    height: 4px;
    background-color: #007bff;
    border-radius: 2px;
}

.timeline-item.drop-zone.drag-over {
    border-color: #007bff;
    background-color: rgba(0, 123, 255, 0.1);
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\types\media.d.ts ---

declare module '*.mp4' {
    const src: string;
    export default src;
}

declare module '*.mp3' {
    const src: string;
    export default src;
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\types\quiz.ts ---

export interface ComparisonOption {
    text: string;
    imageUrl: string;
}

export interface Comparison {
    id: string;
    question: string;
    leftOption: ComparisonOption;
    rightOption: ComparisonOption;
}

export interface QuizConfig {
    comparisons: Comparison[];
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\types\script.ts ---

export interface WordTiming {
    word: string;
    start: number;
    end: number;
}

export interface CaptionStyleOptions {
    fontSize: number;
    color: string;
    backgroundColor: string;
    position: 'top' | 'bottom';
    wordWindow: number;
    // Font options
    fontFamily?: string;
    fontWeight?: number | string;
    fontStyle?: 'normal' | 'italic';
    textDecoration?: string;
    // Block style options
    padding?: string;
    margin?: string;
    borderRadius?: string;
    border?: string;
    boxShadow?: string;
    opacity?: number;
    // Positioning
    x?: number;
    y?: number;
    scale?: number;
    rotation?: number;
}

export type CaptionPreset = 
    | 'default' 
    | 'tiktok' 
    | 'subtitle' 
    | 'remotion-subtitles'
    | 'bounce'
    | 'colorful'
    | 'explosive'
    | 'fade'
    | 'fire'
    | 'glitch'
    | 'glowing'
    | 'lightning'
    | 'neon'
    | 'rotating'
    | 'shake'
    | 'threeDish'
    | 'tiltShift'
    | 'typewriter'
    | 'waving'
    | 'zoom';

export type CaptionStyle = CaptionStyleOptions | CaptionPreset;

export type TikTokToken = {
    text: string;
    fromMs: number;
    toMs: number;
};

export type TikTokPage = {
    text: string;
    startMs: number;
    tokens: TikTokToken[];
};

export type AnimationType = 'fade' | 'scale' | 'slide' | 'typewriter' | 'bounce' | 'wave';

export interface AnimationConfig {
    type: AnimationType;
    duration: number;
    delay?: number;
    direction?: 'left' | 'right' | 'up' | 'down';
    easing?: 'linear' | 'ease-in' | 'ease-out' | 'ease-in-out';
    springConfig?: {
        damping: number;
        mass?: number;
        stiffness?: number;
    };
}

export interface TextStyleBase {
    fontSize?: number;
    fontFamily?: string;
    color?: string;
    textAlign?: 'left' | 'center' | 'right';
    fontWeight?: string | number;
    textTransform?: 'none' | 'uppercase' | 'lowercase' | 'capitalize';
    letterSpacing?: number;
    lineHeight?: number;
    strokeWidth?: number;
    strokeColor?: string;
    backgroundColor?: string;
    padding?: string | number;
    borderRadius?: string | number;
    shadow?: {
        color: string;
        blur: number;
        offset?: { x: number; y: number };
    };
}

export interface TextStyle {
    fontSize?: number;
    fontFamily?: string;
    color?: string;
    textAlign?: 'left' | 'center' | 'right' | 'justify';
    fontWeight?: string | number;
    lineHeight?: string | number;
    wordsPerLine?: number;
    textTransform?: 'none' | 'uppercase' | 'lowercase' | 'capitalize';
    position?: {
        x: number;
        y: number;
    };
    blockStyle?: {
        enabled: boolean;
    };
    backgroundColor?: string;
    padding?: string;
    borderRadius?: string;
    outline?: {
        enabled: boolean;
        color: string;
        width: number;
    };
    animation?: AnimationOptions;
}

export type TextDisplayMode = 'sync' | 'instant';

export type ComponentType = 
    | 'text'
    | 'comparison'
    | 'image'
    | 'transition'
    | 'title'
    | 'question'
    | 'splitScreen'
    | 'countdown'
    | 'voice'
    | 'video'
    | 'audio';

export interface BaseScriptComponent {
    id: string;
    type: ComponentType;
    startFrame: number;
    durationInFrames: number;
    track?: number;
}

export interface AnimationOptions {
    type: 'none' | 'fade' | 'scale' | 'rotate' | 'slide';
    in?: {
        type: 'none' | 'fade' | 'scale' | 'rotate' | 'slide';
        startFrame?: number;
        endFrame?: number;
    };
    out?: {
        type: 'none' | 'fade' | 'scale' | 'rotate' | 'slide';
        startFrame?: number;
        endFrame?: number;
    };
    direction?: 'in' | 'out' | 'left' | 'right' | 'up' | 'down';
    easing?: 'linear' | 'easeIn' | 'easeOut' | 'easeInOut';
    duration: number;
    delay?: number;
    stagger?: number;
}

export interface ComparisonComponentStyle {
    fontSize?: number;
    fontFamily?: string;
    textColor?: string;
    backgroundColor?: string;
    spacing?: number;
    borderRadius?: number;
    shadow?: string;
    showText?: boolean;
    orientation?: 'horizontal' | 'vertical';
    imageSize?: number;
    imageGap?: number;
    forceSameSize?: boolean;
    imagePosition?: Partial<{
        x: number;
        y: number;
    }>;
    imageBorder?: {
        enabled: boolean;
        color: string;
        width: number;
    };
    imageDropShadow?: {
        enabled: boolean;
        color: string;
        blur: number;
        spread: number;
        x: number;
        y: number;
    };
    animation?: AnimationOptions;
}

export type ComparisonComponent = BaseScriptComponent & {
    type: 'comparison';
    question: string;
    orientation: 'horizontal' | 'vertical';
    leftOption: {
        text: string;
        imageUrl: string;
    };
    rightOption: {
        text: string;
        imageUrl: string;
    };
    style?: ComparisonComponentStyle;
};

export interface TextComponent extends BaseScriptComponent {
    type: 'text';
    text: string;
    style?: TextStyle;
}

export interface TitleComponent extends BaseScriptComponent {
    type: 'title';
    text: string;
    subtitle?: string;
    style?: TextStyle;
    background?: {
        type: 'color' | 'image';
        value: string;
    };
}

export interface CountdownComponent extends BaseScriptComponent {
    type: 'countdown';
    from: number;
    style: TextStyle;
    sound?: boolean;
}

export interface TransitionComponent extends BaseScriptComponent {
    type: 'transition';
    transitionType: 'fade' | 'slide' | 'whoosh';
    direction?: 'left' | 'right' | 'up' | 'down';
}

export interface VideoComponentStyle {
    width?: number;
    height?: number;
    position?: {
        x: number;
        y: number;
    };
    scale?: number;
    rotation?: number;
    opacity?: number;
    border?: {
        enabled: boolean;
        color: string;
        width: number;
    };
    dropShadow?: {
        enabled: boolean;
        color: string;
        blur: number;
        spread: number;
        x: number;
        y: number;
    };
    volume?: number;
    playbackRate?: number;
    loop?: boolean;
    muted?: boolean;
    chromakey?: {
        enabled: boolean;
        color: string;
        similarity: number;  // 0-1, how close colors need to be to be removed
        smoothness: number;  // 0-1, edge smoothness
    };
    animation?: AnimationOptions;
    // Add time control properties
    startTime?: number;  // Start time in seconds from the source video
    duration?: number;   // Duration in seconds to use from the source video
}

export type VideoComponent = BaseScriptComponent & {
    type: 'video';
    videoUrl: string;
    style?: VideoComponentStyle;
};

export interface AudioComponentStyle {
    volume?: number;
    loop?: boolean;
    startTime?: number;
    duration?: number;
}

export interface AudioFile {
    url: string;
    name: string;
    format: string;
    addedAt: string;
}

export interface AudioComponent extends BaseScriptComponent {
    type: 'audio';
    audioUrl: string | AudioFile;
    style?: AudioComponentStyle;
}

export interface VoiceSettings {
    voiceId: string;
    stability: number;
    similarity_boost: number;
}

export interface VoiceComponent extends BaseScriptComponent {
    type: 'voice';
    text: string;
    audioUrl?: string;
    voiceSettings?: VoiceSettings;
    wordTimings?: WordTiming[];
    showCaptions?: boolean;
    captionStyle?: CaptionStyleOptions;
    style?: VoiceStyle;
}

export interface CaptionTrack {
    id: string;
    originalComponentId?: string;  // ID of the original voice component
    isLinked: boolean;
    wordTimings: WordTiming[];
    startFrame: number;
    text: string;
}

export interface ImageComponentStyle {
    width?: number;
    height?: number;
    position?: {
        x: number;
        y: number;
    };
    scale?: number;
    rotation?: number;
    opacity?: number;
    border?: {
        enabled: boolean;
        color: string;
        width: number;
    };
    dropShadow?: {
        enabled: boolean;
        color: string;
        blur: number;
        spread: number;
        x: number;
        y: number;
    };
}

export interface ImageComponent extends BaseScriptComponent {
    type: 'image';
    imageUrl: string;
    style?: ImageComponentStyle;
}

export type Component = TextComponent | ComparisonComponent | TitleComponent | CountdownComponent | TransitionComponent | VoiceComponent | VideoComponent | AudioComponent | ImageComponent;

export interface Script {
    id: string;
    title: string;
    components: Component[];
    captionTracks: CaptionTrack[];
    settings: {
        defaultTextStyle: TextStyle;
        defaultCaptionStyle: TextStyle;
        background?: {
            type: 'none' | 'image' | 'video';
            url?: string;
            filePath?: string;
            durationInFrames?: number;
        };
        backgroundHistory?: Array<{
            type: 'none' | 'image' | 'video';
            url?: string;
            filePath?: string;
            durationInFrames?: number;
            timestamp: number;  // When this background was used
            title?: string;    // Optional user-provided title
        }>;
    };
}

export interface VoiceComponentStyle extends TextStyle {
    wordWindow?: number; // Number of words to show at once
}

export interface VoiceStyle {
    volume?: number;
    loop?: boolean;
    startTime?: number;
    duration?: number;
    animation?: AnimationOptions;
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\types\template.ts ---

import { Script, ScriptComponent, TextStyle } from './script';

export interface TemplateComponent extends Omit<ScriptComponent, 'text' | 'audioUrl' | 'wordTimings'> {
    placeholderText?: string;
    defaultStyle?: TextStyle;
}

export interface Template {
    id: string;
    name: string;
    description?: string;
    components: TemplateComponent[];
    settings: {
        defaultTextStyle: TextStyle;
        defaultCaptionStyle: TextStyle;
        background?: {
            type: 'none' | 'image' | 'video';
            placeholderUrl?: string;
            durationInFrames?: number;
        };
    };
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\utils\animation.ts ---

import { spring } from 'remotion';
import { AnimationOptions } from '../types/script';

export const getAnimationStyle = (frame: number, fps: number, animation?: AnimationOptions) => {
    if (!animation || animation.type === 'none') {
        return {};
    }

    const progress = spring({
        frame,
        fps,
        config: {
            damping: 10,
            mass: 0.5,
            stiffness: 100,
        },
        durationInFrames: animation.duration,
        delay: animation.delay || 0,
    });

    const reverseProgress = 1 - progress;
    const direction = animation.direction || 'in';
    const isIn = direction === 'in';
    const currentProgress = isIn ? progress : reverseProgress;

    switch (animation.type) {
        case 'fade':
            return {
                opacity: currentProgress,
            };
        case 'scale':
            return {
                transform: `translate(-50%, -50%) scale(${isIn ? currentProgress : 1 + (currentProgress * 0.5)})`,
            };
        case 'rotate':
            return {
                transform: `translate(-50%, -50%) rotate(${currentProgress * (isIn ? 360 : -360)}deg)`,
            };
        case 'slide':
            const offset = 100;
            const x = animation.direction === 'left' ? -offset : animation.direction === 'right' ? offset : 0;
            const y = animation.direction === 'up' ? -offset : animation.direction === 'down' ? offset : 0;
            return {
                transform: `translate(calc(-50% + ${x * currentProgress}px), calc(-50% + ${y * currentProgress}px))`,
            };
        default:
            return {};
    }
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\utils\componentFactory.ts ---

import { 
    ComponentType, 
    Component,
    BaseScriptComponent,
    TextStyle,
    TextComponent,
    ComparisonComponent,
    TitleComponent,
    CountdownComponent,
    TransitionComponent,
    VoiceComponent,
    VideoComponent,
    AudioComponent
} from '../types/script';

const DEFAULT_TEXT_STYLE: TextStyle = {
    fontSize: 40,
    color: 'white',
    fontFamily: 'Arial',
    textAlign: 'center',
    fontWeight: 'normal',
};

export const createComponent = (
    type: ComponentType,
    defaultTextStyle: TextStyle = DEFAULT_TEXT_STYLE,
    defaultCaptionStyle: TextStyle = DEFAULT_TEXT_STYLE
): Component => {
    const baseProps = {
        id: Date.now().toString(),
        durationInFrames: 150, // 5 seconds default
        startFrame: 0,
    };

    switch (type) {
        case 'title':
            return {
                ...baseProps,
                type: 'title',
                text: 'New Title',
                subtitle: '',
                style: { ...defaultTextStyle },
                background: {
                    type: 'color',
                    value: '#000000',
                },
            } as TitleComponent;

        case 'text':
            return {
                ...baseProps,
                type: 'text',
                text: 'Enter your text here',
                style: { ...defaultTextStyle },
            } as TextComponent;

        case 'comparison':
            return {
                ...baseProps,
                type: 'comparison',
                question: 'Enter your question',
                leftOption: {
                    text: 'Left Option',
                    imageUrl: '',
                },
                rightOption: {
                    text: 'Right Option',
                    imageUrl: '',
                },
            } as ComparisonComponent;

        case 'countdown':
            return {
                ...baseProps,
                type: 'countdown',
                from: 5,
                style: { ...defaultTextStyle },
                sound: true,
                durationInFrames: 150,
            } as CountdownComponent;

        case 'transition':
            return {
                ...baseProps,
                type: 'transition',
                transitionType: 'fade',
                direction: 'left',
                durationInFrames: 30,
            } as TransitionComponent;

        case 'voice':
            return {
                ...baseProps,
                type: 'voice',
                text: 'Enter text for voice generation',
                voiceSettings: {
                    voiceId: 'GhJYgP4Lrji0pwS3kQwv',
                    stability: 0.75,
                    similarity_boost: 0.75,
                },
                captionStyle: {
                    fontSize: 24,
                    color: '#ffffff',
                    backgroundColor: 'rgba(0, 0, 0, 0.7)',
                    position: 'bottom',
                    wordWindow: 1,
                },
                showCaptions: false,
                style: { ...defaultTextStyle },
            } as VoiceComponent;

        case 'video':
            return {
                ...baseProps,
                type: 'video',
                videoUrl: '',
                style: {
                    width: 100,
                    height: 100,
                    position: { x: 0, y: 0 },
                    scale: 1,
                    rotation: 0,
                    opacity: 1,
                    borderRadius: 0,
                    border: {
                        enabled: false,
                        color: '#000000',
                        width: 1,
                    },
                    dropShadow: {
                        enabled: false,
                        color: 'rgba(0,0,0,0.5)',
                        blur: 10,
                        spread: 0,
                        x: 0,
                        y: 4,
                    },
                    volume: 1,
                    playbackRate: 1,
                    loop: false,
                    muted: false,
                    animation: {
                        type: 'none',
                        duration: 30,
                        delay: 0,
                        direction: 'left',
                        easing: 'easeInOut',
                    },
                },
            } as VideoComponent;

        case 'audio':
            return {
                ...baseProps,
                type: 'audio',
                audioUrl: '',
                style: {
                    volume: 1,
                    loop: false,
                    startTime: 0,
                    duration: undefined,
                },
            } as AudioComponent;

        default:
            throw new Error(`Unknown component type: ${type}`);
    }
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\utils\fileUtils.ts ---

export async function checkFileAccessibility(url: string): Promise<boolean> {
    console.log(`=== Checking accessibility for URL: ${url} ===`);
    try {
        console.log('Sending HEAD request...');
        const response = await fetch(url, { method: 'HEAD' });
        console.log('Response status:', response.status);
        console.log('Response headers:', Object.fromEntries(response.headers.entries()));
        console.log('Response ok:', response.ok);
        return response.ok;
    } catch (error: any) {
        console.error(`Error checking accessibility for ${url}:`, error);
        console.error('Error details:', {
            name: error?.name || 'Unknown',
            message: error?.message || 'No message available',
            stack: error?.stack || 'No stack trace available'
        });
        return false;
    }
}

export async function findAccessibleUrl(urls: string[]): Promise<string | null> {
    console.log('=== Finding accessible URL ===');
    console.log('Checking URLs:', urls);
    
    for (const url of urls) {
        console.log(`\nTesting URL: ${url}`);
        if (await checkFileAccessibility(url)) {
            console.log('✅ URL is accessible:', url);
            return url;
        } else {
            console.log('❌ URL is not accessible:', url);
        }
    }
    
    console.error('No accessible URLs found among:', urls);
    return null;
} 
