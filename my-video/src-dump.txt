
+--------------------------------------------+
| Dump tree for directory: D:\Projects\Remotion Couples Quiz\my-video\src |
+--------------------------------------------+
‚îú‚îÄ‚îÄ @Assets
‚îÇ  ‚îú‚îÄ‚îÄ clock.mp4
‚îÇ  ‚îî‚îÄ‚îÄ whoosh.mp3
‚îú‚îÄ‚îÄ Composition.tsx
‚îú‚îÄ‚îÄ Preview.tsx
‚îú‚îÄ‚îÄ QuizVideo.tsx
‚îú‚îÄ‚îÄ Root.tsx
‚îú‚îÄ‚îÄ ScriptVideo.tsx
‚îú‚îÄ‚îÄ Video.tsx
‚îú‚îÄ‚îÄ components
‚îÇ  ‚îú‚îÄ‚îÄ Audio
‚îÇ  ‚îú‚îÄ‚îÄ Comparison.tsx
‚îÇ  ‚îú‚îÄ‚îÄ ComparisonEditor.tsx
‚îÇ  ‚îú‚îÄ‚îÄ ConfigMenu
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ ConfigMenu.tsx
‚îÇ  ‚îú‚îÄ‚îÄ ImageSelector.tsx
‚îÇ  ‚îú‚îÄ‚îÄ Layout
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ AppLayout.tsx
‚îÇ  ‚îú‚îÄ‚îÄ QuizSetup.tsx
‚îÇ  ‚îú‚îÄ‚îÄ ScriptEditor
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ AudioComponentEditor.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ CaptionEditor.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ CaptionPositioningScreen.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ CaptionTimeline.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ ComparisonComponentEditor.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ ComponentEditor.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ ComponentEditors.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ ComponentPalette.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ CountdownComponentEditor.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ DraggablePreview.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ ImageComponentEditor.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ PositioningScreen.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ ScriptEditor.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ TextComponentEditor.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ Timeline.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ TitleComponentEditor.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ VideoComponentEditor.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ VoiceComponent.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ VoiceComponentEditor.tsx
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ VoiceOverEditor.tsx
‚îÇ  ‚îú‚îÄ‚îÄ Settings
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ BackgroundManager.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ FontManager.tsx
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ PositioningPopup.tsx
‚îÇ  ‚îú‚îÄ‚îÄ Setup
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ ComparisonEditor.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ ImagePicker.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ ImageSelector.tsx
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ Setup.tsx
‚îÇ  ‚îú‚îÄ‚îÄ SetupPage.tsx
‚îÇ  ‚îú‚îÄ‚îÄ TemplateManager
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ TemplateManager.tsx
‚îÇ  ‚îú‚îÄ‚îÄ Timer.tsx
‚îÇ  ‚îú‚îÄ‚îÄ Video
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ AudioComponent.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ CaptionRenderer.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ ComparisonComponent.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ ComparisonSequence.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ CountdownSequence.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ ImageComponent.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ QuizVideo.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ RemotionSubtitleCaption.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ ScriptVideo.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ TextComponent.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ TextSequence.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ TikTokCaptions.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ TitleSequence.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ TransitionSequence.tsx
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ VideoComponent.tsx
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ VideoPositioningScreen.tsx
‚îÇ  ‚îî‚îÄ‚îÄ common
‚îÇ     ‚îú‚îÄ‚îÄ ColorPicker.tsx
‚îÇ     ‚îú‚îÄ‚îÄ IconButton.tsx
‚îÇ     ‚îú‚îÄ‚îÄ Modal.tsx
‚îÇ     ‚îú‚îÄ‚îÄ Slider.tsx
‚îÇ     ‚îî‚îÄ‚îÄ Switch.tsx
‚îú‚îÄ‚îÄ components-dump.txt
‚îú‚îÄ‚îÄ data
‚îÇ  ‚îî‚îÄ‚îÄ quizData.ts
‚îú‚îÄ‚îÄ font_service.py
‚îú‚îÄ‚îÄ index.ts
‚îú‚îÄ‚îÄ pages
‚îÇ  ‚îú‚îÄ‚îÄ _app.tsx
‚îÇ  ‚îú‚îÄ‚îÄ api
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ copy-background.ts
‚îÇ  ‚îÇ  ‚îú‚îÄ‚îÄ get-path.ts
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ save-path.ts
‚îÇ  ‚îî‚îÄ‚îÄ index.tsx
‚îú‚îÄ‚îÄ preview-entry.ts
‚îú‚îÄ‚îÄ preview-entry.tsx
‚îú‚îÄ‚îÄ public
‚îÇ  ‚îú‚îÄ‚îÄ audio
‚îÇ  ‚îú‚îÄ‚îÄ backgrounds
‚îÇ  ‚îî‚îÄ‚îÄ fonts
‚îÇ     ‚îú‚îÄ‚îÄ font_dictionary.json
‚îÇ     ‚îî‚îÄ‚îÄ tiktok.otf
‚îú‚îÄ‚îÄ remotion
‚îÇ  ‚îú‚îÄ‚îÄ VideoRoot.tsx
‚îÇ  ‚îî‚îÄ‚îÄ index.ts
‚îú‚îÄ‚îÄ render.mjs
‚îú‚îÄ‚îÄ services
‚îÇ  ‚îú‚îÄ‚îÄ audioService.ts
‚îÇ  ‚îú‚îÄ‚îÄ elevenLabs.ts
‚îÇ  ‚îú‚îÄ‚îÄ pexels.ts
‚îÇ  ‚îú‚îÄ‚îÄ templateService.ts
‚îÇ  ‚îî‚îÄ‚îÄ videoService.ts
‚îú‚îÄ‚îÄ store
‚îÇ  ‚îú‚îÄ‚îÄ apiKeysStore.ts
‚îÇ  ‚îî‚îÄ‚îÄ configStore.ts
‚îú‚îÄ‚îÄ styles
‚îÇ  ‚îú‚îÄ‚îÄ commonStyles.ts
‚îÇ  ‚îú‚îÄ‚îÄ globals.css
‚îÇ  ‚îú‚îÄ‚îÄ theme.ts
‚îÇ  ‚îî‚îÄ‚îÄ timeline.css
‚îú‚îÄ‚îÄ types
‚îÇ  ‚îú‚îÄ‚îÄ media.d.ts
‚îÇ  ‚îú‚îÄ‚îÄ quiz.ts
‚îÇ  ‚îú‚îÄ‚îÄ script.ts
‚îÇ  ‚îî‚îÄ‚îÄ template.ts
‚îî‚îÄ‚îÄ utils
   ‚îú‚îÄ‚îÄ animation.ts
   ‚îú‚îÄ‚îÄ componentFactory.ts
   ‚îî‚îÄ‚îÄ fileUtils.ts



--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\Composition.tsx ---

export const MyComposition = () => {
  return null;
};



--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\Preview.tsx ---

import React, { useEffect, useState } from 'react';
import { Composition } from 'remotion';
import { ScriptVideo } from './components/Video/ScriptVideo';
import { Script } from './types/script';

interface CustomFont {
    name: string;
    url: string;
    format: 'truetype' | 'opentype';
}

export const Preview: React.FC = () => {
    const [fontsLoaded, setFontsLoaded] = useState(false);
    const [renderKey, setRenderKey] = useState(0);
    const searchParams = new URLSearchParams(window.location.search);
    const scriptData = searchParams.get('props');
    
    useEffect(() => {
        const loadFonts = async () => {
            setFontsLoaded(false);
            try {
                const response = await fetch('http://localhost:3003/fonts/dictionary');
                if (!response.ok) throw new Error('Failed to load font dictionary');
                const fontDict = await response.json();
                console.log('Font dictionary:', fontDict);

                if (!scriptData) return;
                const script: Script = JSON.parse(decodeURIComponent(scriptData));

                // Get unique font families used in components
                const usedFonts = new Set<string>();
                script.components.forEach(comp => {
                    if (comp.type === 'text' || comp.type === 'title') {
                        const textComp = comp as { style?: { fontFamily?: string } };
                        if (textComp.style?.fontFamily) {
                            usedFonts.add(textComp.style.fontFamily);
                            console.log('Found font:', textComp.style.fontFamily);
                        }
                    }
                });

                // Load each used font
                const fontLoadPromises = Array.from(usedFonts).map(async fontName => {
                    const fontData = fontDict[fontName];
                    if (fontData?.url) {
                        try {
                            console.log('Loading font:', fontName, 'from URL:', fontData.url);
                            const font = new FontFace(fontName, `url(${fontData.url})`);
                            const loadedFont = await font.load();
                            document.fonts.add(loadedFont);
                            console.log('Successfully loaded font:', fontName);
                            return true;
                        } catch (error) {
                            console.error('Error loading font:', fontName, error);
                            return false;
                        }
                    }
                    return false;
                });

                // Wait for all fonts to load
                await Promise.all(fontLoadPromises);
                setFontsLoaded(true);
                setRenderKey(prev => prev + 1);
                console.log('All fonts loaded, forcing re-render');
            } catch (error) {
                console.error('Error loading fonts:', error);
                setFontsLoaded(true);
            }
        };

        loadFonts();

        // Listen for font updates
        const handleFontsUpdated = () => {
            console.log('Fonts updated, reloading...');
            loadFonts();
        };

        window.addEventListener('fontsUpdated', handleFontsUpdated);
        return () => {
            window.removeEventListener('fontsUpdated', handleFontsUpdated);
        };
    }, [scriptData]);
    
    if (!scriptData) {
        console.error('No script data provided');
        return <div>Error: No script data provided</div>;
    }

    if (!fontsLoaded) {
        return <div>Loading fonts...</div>;
    }

    try {
        const script: Script = JSON.parse(decodeURIComponent(scriptData));
        console.log('Preview rendering with script:', script);

        if (!script || typeof script !== 'object') {
            throw new Error('Invalid script data format');
        }

        if (!script.id || !script.title || !Array.isArray(script.components) || !Array.isArray(script.captionTracks)) {
            throw new Error('Missing required script properties');
        }

        const totalDuration = Math.max(
            ...script.components.map(comp => {
                const start = comp.startFrame || 0;
                const duration = comp.durationInFrames || 150;
                return start + duration;
            }),
            300
        );

        return (
            <Composition
                key={renderKey}
                id="ScriptVideo"
                component={ScriptVideo}
                durationInFrames={totalDuration}
                fps={30}
                width={1080}
                height={1920}
                defaultProps={{ script }}
            />
        );
    } catch (error) {
        console.error('Error parsing preview props:', error);
        return <div>Error: Invalid script data - {(error as Error).message}</div>;
    }
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\QuizVideo.tsx ---

import {AbsoluteFill, useCurrentFrame, interpolate} from 'remotion';
import {Intro} from './components/Intro';
import {Comparison} from './components/Comparison';
import {Outro} from './components/Outro';
import {QUIZ_DATA} from './data/quizData';

export const QuizVideo: React.FC = () => {
	const frame = useCurrentFrame();
	const introEndFrame = 150; // 5 seconds
	const outroStartFrame = 1650; // 55 seconds

	return (
		<AbsoluteFill style={{
			backgroundColor: '#1a1a1a',
		}}>
			{/* Intro Section */}
			<Intro />

			{/* Comparisons Section */}
			{QUIZ_DATA.map((item, index) => (
				<Comparison
					key={index}
					data={item}
					startFrame={150 + index * 150} // Each comparison starts 5 seconds after the previous
				/>
			))}

			{/* Outro Section */}
			<Outro />
		</AbsoluteFill>
	);
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\Root.tsx ---

import React, { useState, useRef, useEffect } from 'react';
import { Composition } from 'remotion';
import { Player, PlayerRef } from '@remotion/player';
import { ScriptVideo, ScriptVideoProps } from './components/Video/ScriptVideo';
import { Script, ComponentType, ScriptComponent } from './types/script';
import { AppLayout } from './components/Layout/AppLayout';
import { ComponentPalette } from './components/ScriptEditor/ComponentPalette';
import { Timeline } from './components/ScriptEditor/Timeline';
import { CaptionTimeline } from './components/ScriptEditor/CaptionTimeline';
import { ComponentEditor } from './components/ScriptEditor/ComponentEditor';
import { Modal } from './components/common/Modal';
import { TemplateManager } from './components/TemplateManager/TemplateManager';
import { theme } from './styles/theme';
import { commonStyles } from './styles/commonStyles';
import { IconButton } from './components/common/IconButton';
import { findAccessibleUrl } from './utils/fileUtils';

// Create an isolated video preview component
const IsolatedVideoPreview: React.FC<{ script: Script }> = ({ script }) => {
	const playerRef = useRef<PlayerRef>(null);

	return (
		<div style={{
			position: 'relative',
			width: '100%',
			height: '100%',
		}}>
			<Player
				ref={playerRef}
				component={ScriptVideo}
				durationInFrames={Math.max(
					...script.components.map(comp => {
						const start = comp.startFrame || 0;
						const duration = comp.durationInFrames || 150;
						return start + duration;
					}),
					300 // Minimum 10 seconds
				)}
				fps={30}
				compositionWidth={1080}
				compositionHeight={1920}
				style={{
					width: '100%',
					height: '100%',
				}}
				controls
				autoPlay
				loop
				inputProps={{ script }}
			/>
		</div>
	);
};

// Add error boundary
class ErrorBoundary extends React.Component<{
	children: React.ReactNode;
	onError?: (error: Error) => void;
}, { hasError: boolean }> {
	constructor(props: { children: React.ReactNode; onError?: (error: Error) => void; }) {
		super(props);
		this.state = { hasError: false };
	}

	static getDerivedStateFromError() {
		return { hasError: true };
	}

	componentDidCatch(error: Error) {
		if (this.props.onError) {
			this.props.onError(error);
		}
	}

	render() {
		if (this.state.hasError) {
			return null;
		}
		return this.props.children;
	}
}

// Wrap the video components with error boundary
const SafeVideoPreview = ({ script }: { script: Script }) => {
	const [error, setError] = useState<Error | null>(null);
	const [previewUrl, setPreviewUrl] = useState('');
	const previewContainerRef = useRef<HTMLDivElement>(null);

	// Update preview URL when script changes
	useEffect(() => {
		console.log('Updating preview URL with script:', script);
		console.log('Background settings:', script.settings.background);

		// Pass the script directly to the preview
		const scriptData = encodeURIComponent(JSON.stringify(script));
		const newPreviewUrl = `http://localhost:3001/ScriptVideo?props=${scriptData}`;
		console.log('Setting preview URL:', newPreviewUrl);
		console.log('Decoded preview data:', JSON.parse(decodeURIComponent(scriptData)));
		setPreviewUrl(newPreviewUrl);
	}, [script]);

	if (error) {
		return (
			<div style={{
				width: '100%',
				height: '100%',
				display: 'flex',
				flexDirection: 'column',
				alignItems: 'center',
				justifyContent: 'center',
				backgroundColor: theme.colors.background.primary,
				color: theme.colors.text.primary,
				padding: theme.spacing.lg,
				textAlign: 'center',
				gap: theme.spacing.md,
			}}>
				<div style={{
					fontSize: theme.fontSizes.lg,
					fontWeight: 'bold',
					marginBottom: theme.spacing.sm,
				}}>
					Preview Unavailable
				</div>
				<div style={{
					fontSize: theme.fontSizes.sm,
					color: theme.colors.text.secondary,
					maxWidth: '80%',
				}}>
					{error.message || 'There was an error loading the preview.'}
				</div>
			</div>
		);
	}

	return (
		<div 
			ref={previewContainerRef}
			style={{
				position: 'relative',
				width: '100%',
				height: '100%',
				backgroundColor: '#000',
			}}
		>
			{previewUrl && (
				<iframe
					src={previewUrl}
					style={{
						width: '100%',
						height: '100%',
						border: 'none',
					}}
					title="Video Preview"
					key={previewUrl}
				/>
			)}
		</div>
	);
};

export const RemotionRoot: React.FC = () => {
	const [script, setScript] = useState<Script>({
		id: Date.now().toString(),
		title: 'New Quiz',
		components: [],
		captionTracks: [],
		settings: {
			defaultTextStyle: {
				fontSize: 40,
				color: 'white',
				fontFamily: 'Arial',
				textAlign: 'center',
			},
			defaultCaptionStyle: {
				fontSize: 24,
				color: 'white',
				fontFamily: 'Arial',
				textAlign: 'center',
			},
			background: {
				type: 'none',
			},
		},
	});

	const [currentFrame, setCurrentFrame] = useState(0);
	const [selectedComponentId, setSelectedComponentId] = useState<string | undefined>(undefined);
	const [isTemplateManagerOpen, setIsTemplateManagerOpen] = useState(false);
	const [timelineZoom, setTimelineZoom] = useState(1);
	const [editingTextPosition, setEditingTextPosition] = useState<string | null>(null);
	const [previewKey, setPreviewKey] = useState(0);
	const [previewUrl, setPreviewUrl] = useState('');
	const [error, setError] = useState<Error | null>(null);

	const playerRef = useRef<PlayerRef>(null);
	const previewContainerRef = useRef<HTMLDivElement>(null);

	// Calculate total duration, minimum 30 frames (1 second)
	const totalDuration = Math.max(
		...script.components.map(comp => {
			const start = comp.startFrame || 0;
			const duration = comp.durationInFrames || 150; // Default 5 seconds if not specified
			return start + duration;
		}),
		300 // Minimum 10 seconds
	);

	// Get selected component
	const selectedComponent = script.components.find(c => c.id === selectedComponentId);

	// Handle messages from preview iframe
	useEffect(() => {
		const handleMessage = (event: MessageEvent) => {
			if (event.origin === 'http://localhost:3001') {
				try {
					const data = JSON.parse(event.data);
					if (data.type === 'updateTextPosition' && data.componentId && data.position) {
						setScript(prev => ({
							...prev,
							components: prev.components.map(comp => {
								if (comp.id === data.componentId && comp.type === 'text') {
									return {
										...comp,
										style: {
											...comp.style,
											position: data.position
										}
									};
								}
								return comp;
							})
						}));
					}
				} catch (err) {
					console.error('Error processing message:', err);
				}
			}
		};

		window.addEventListener('message', handleMessage);
		return () => window.removeEventListener('message', handleMessage);
	}, []);

	const handleDragStart = (type: ComponentType) => {
		console.log('Dragging component:', type);
	};

	const handleComponentChange = (updated: Script['components'][0]) => {
		const newScript = {
			...script,
			components: script.components.map(c => 
				c.id === updated.id ? updated : c
			),
		};
		setScript(newScript);
		setPreviewKey(prev => prev + 1);
	};

	const handleComponentDelete = (id: string | undefined) => {
		const newScript = {
			...script,
			components: script.components.filter(c => c.id !== id),
		};
		setScript(newScript);
		setSelectedComponentId(undefined);
		setPreviewKey(prev => prev + 1);
	};

	const handleReorder = (components: ScriptComponent[]) => {
		setScript(prev => ({
			...prev,
			components,
		}));
	};

	const updatePreviewUrl = (script: Script) => {
		console.log('Updating preview URL with script:', script);
		console.log('Background settings:', script.settings?.background);

		// Get custom fonts from localStorage
		let customFonts = [];
		try {
			const savedFonts = localStorage.getItem('customFonts');
			if (savedFonts) {
				customFonts = JSON.parse(savedFonts);
			}
		} catch (error) {
			console.error('Error loading custom fonts:', error);
		}

		// Create preview data object with both script and fonts
		const previewData = {
			script,
			customFonts
		};

		// Update preview URL with combined data
		const previewUrl = `http://localhost:3001/ScriptVideo?props=${encodeURIComponent(JSON.stringify(previewData))}`;
		console.log('Setting preview URL:', previewUrl);
		console.log('Decoded preview data:', previewData);
		setPreviewUrl(previewUrl);
	};

	return (
		<>
			<ErrorBoundary>
				<Composition
					id="ScriptVideo"
					component={ScriptVideo}
					durationInFrames={totalDuration}
					fps={30}
					width={1080}
					height={1920}
					defaultProps={{
						script
					}}
				/>
			</ErrorBoundary>
			<AppLayout script={script} onScriptChange={(newScript) => {
				setScript(newScript);
				setPreviewKey(prev => prev + 1);
			}}>
				{/* Left Sidebar - Components Panel */}
				<div style={{
					display: 'flex',
					flexDirection: 'column',
					gap: theme.spacing.lg,
					backgroundColor: theme.colors.background.secondary,
					borderRadius: theme.borderRadius.lg,
					padding: theme.spacing.lg,
					boxShadow: theme.shadows.md,
					height: 'fit-content',
					position: 'sticky',
					top: theme.spacing.lg,
					width: '250px', // Fixed width for consistency
					minWidth: '250px', // Prevent shrinking
				}}>
					<div style={{
						display: 'flex',
						justifyContent: 'space-between',
						alignItems: 'center',
						padding: `${theme.spacing.sm} ${theme.spacing.md}`,
						backgroundColor: theme.colors.background.tertiary,
						borderRadius: theme.borderRadius.md,
					}}>
						<h2 style={{
							margin: 0,
							fontSize: theme.fontSizes.xl,
							fontFamily: theme.fonts.heading,
							color: theme.colors.text.primary,
						}}>Components</h2>
						<IconButton
							icon="üìã"
							onClick={() => setIsTemplateManagerOpen(true)}
							tooltip="Templates"
							variant="ghost"
						/>
					</div>
					<ComponentPalette onDragStart={handleDragStart} />
				</div>

				{/* Center Content */}
				<div style={{
					display: 'flex',
					flexDirection: 'column',
					gap: theme.spacing.xl,
					width: '100%',
				}}>
					{/* Preview Section */}
					<div style={{
						backgroundColor: theme.colors.background.tertiary,
						borderRadius: theme.borderRadius.lg,
						overflow: 'hidden',
						padding: theme.spacing.lg,
						boxShadow: theme.shadows.lg,
						height: '65vh',
						minHeight: '500px',
					}}>
						<div style={{
							position: 'relative',
							width: '100%',
							height: '100%',
							backgroundColor: theme.colors.background.primary,
							borderRadius: theme.borderRadius.md,
							overflow: 'hidden',
							boxShadow: 'inset 0 0 10px rgba(0,0,0,0.1)',
						}}>
							<SafeVideoPreview key={previewKey} script={script} />
						</div>
					</div>

					{/* Timeline Section */}
					<div style={{
						backgroundColor: theme.colors.background.secondary,
						borderRadius: theme.borderRadius.lg,
						padding: theme.spacing.lg,
						boxShadow: theme.shadows.md,
					}}>
						{/* Timeline Controls */}
						<div style={{
							display: 'flex',
							justifyContent: 'space-between',
							alignItems: 'center',
							padding: `${theme.spacing.sm} ${theme.spacing.md}`,
							backgroundColor: theme.colors.background.tertiary,
							borderRadius: theme.borderRadius.md,
							marginBottom: theme.spacing.md,
						}}>
							<div style={{ display: 'flex', gap: theme.spacing.sm }}>
								<h3 style={{
									margin: 0,
									fontSize: theme.fontSizes.lg,
									fontFamily: theme.fonts.heading,
									color: theme.colors.text.primary,
									marginRight: theme.spacing.md,
								}}>Timeline</h3>
								<IconButton
									icon="‚èÆ"
									onClick={() => playerRef.current?.seekTo(0)}
									tooltip="Go to Start"
									variant="ghost"
								/>
								<IconButton
									icon="‚è™"
									onClick={() => {
										const frame = Math.max(0, currentFrame - 30);
										playerRef.current?.seekTo(frame);
										setCurrentFrame(frame);
									}}
									tooltip="Back 1 Second"
									variant="ghost"
								/>
								<IconButton
									icon="‚è©"
									onClick={() => {
										const frame = Math.min(300, currentFrame + 30);
										playerRef.current?.seekTo(frame);
										setCurrentFrame(frame);
									}}
									tooltip="Forward 1 Second"
									variant="ghost"
								/>
							</div>
							<div style={{ display: 'flex', gap: theme.spacing.sm }}>
								<IconButton
									icon="üîç-"
									onClick={() => setTimelineZoom(prev => Math.max(0.5, prev - 0.1))}
									tooltip="Zoom Out"
									variant="ghost"
								/>
								<IconButton
									icon="üîç+"
									onClick={() => setTimelineZoom(prev => Math.min(2, prev + 0.1))}
									tooltip="Zoom In"
									variant="ghost"
								/>
							</div>
						</div>

						{/* Main Timeline */}
						<Timeline
							script={script}
							onReorder={handleReorder}
							onSelect={setSelectedComponentId}
							selectedId={selectedComponentId}
							onDelete={handleComponentDelete}
						/>

						{/* Captions Timeline */}
						<CaptionTimeline
							script={script}
							onScriptChange={setScript}
						/>
					</div>
				</div>

				{/* Right Sidebar - Properties Panel */}
				<div style={{
					backgroundColor: theme.colors.background.secondary,
					borderRadius: theme.borderRadius.lg,
					padding: theme.spacing.lg,
					boxShadow: theme.shadows.md,
					height: 'fit-content',
					maxHeight: 'calc(100vh - 40px)',
					position: 'sticky',
					top: theme.spacing.lg,
					overflow: 'auto',
					width: '300px', // Fixed width for consistency
					minWidth: '300px', // Prevent shrinking
				}}>
					<div style={{
						padding: `${theme.spacing.sm} ${theme.spacing.md}`,
						backgroundColor: theme.colors.background.tertiary,
						borderRadius: theme.borderRadius.md,
						marginBottom: theme.spacing.lg,
					}}>
						<h2 style={{
							margin: 0,
							fontSize: theme.fontSizes.xl,
							fontFamily: theme.fonts.heading,
							color: theme.colors.text.primary,
						}}>Properties</h2>
					</div>
					{selectedComponent && (
						<ComponentEditor
							component={selectedComponent}
							onChange={handleComponentChange}
							onDelete={() => handleComponentDelete(selectedComponent.id)}
							onEditPosition={setEditingTextPosition}
						/>
					)}
				</div>
			</AppLayout>

			{/* Template Manager Modal */}
			<Modal
				isOpen={isTemplateManagerOpen}
				onClose={() => setIsTemplateManagerOpen(false)}
				title={
					<h2 style={{
						...commonStyles.heading,
						margin: 0,
						display: 'flex',
						alignItems: 'center',
						gap: theme.spacing.sm,
						color: theme.colors.text.primary,
						fontSize: theme.fontSizes.xl,
						fontFamily: theme.fonts.heading,
					}}>
						 Templates
					</h2>
				}
			>
				<TemplateManager
					currentScript={script}
					onTemplateSelect={(newScript) => {
						setScript(newScript);
						setIsTemplateManagerOpen(false);
					}}
				/>
			</Modal>

			{/* Component Editor Modal (for mobile/tablet) */}
			<Modal
				isOpen={!!selectedComponentId && window.innerWidth < 1024}
				onClose={() => setSelectedComponentId(undefined)}
				title={
					selectedComponent && (
						<h2 style={{
							...commonStyles.heading,
							margin: 0,
							display: 'flex',
							alignItems: 'center',
							gap: theme.spacing.sm,
							color: theme.colors.text.primary,
							fontSize: theme.fontSizes.xl,
							fontFamily: theme.fonts.heading,
						}}>
							<span style={{ fontSize: '1.2em' }}>
								{selectedComponent.type === 'title' && 'üìë'}
								{selectedComponent.type === 'text' && 'üìù'}
								{selectedComponent.type === 'comparison' && '‚öñÔ∏è'}
								{selectedComponent.type === 'countdown' && '‚è≤Ô∏è'}
								{selectedComponent.type === 'transition' && 'üîÑ'}
								{selectedComponent.type === 'voice' && 'üéôÔ∏è'}
							</span>
							Edit {selectedComponent.type.charAt(0).toUpperCase() + selectedComponent.type.slice(1)}
						</h2>
					)
				}
			>
				{selectedComponent && (
					<ComponentEditor
						component={selectedComponent}
						onChange={handleComponentChange}
						onDelete={() => handleComponentDelete(selectedComponent.id)}
					/>
				)}
			</Modal>
		</>
	);
};



--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\ScriptVideo.tsx ---

import {AbsoluteFill} from 'remotion';
import {loadFont} from '@remotion/google-fonts/Roboto';
import React, {useEffect} from 'react';
import {Script} from './types/script';

const {fontFamily} = loadFont();

export const ScriptVideo: React.FC<{
  script: Script;
}> = ({script}) => {
  // Ensure script has required properties
  if (!script?.components) {
    console.error('Script is missing components array:', script);
    return (
      <AbsoluteFill style={{
        backgroundColor: '#000000',
        color: '#ffffff',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        fontFamily
      }}>
        No components to render
      </AbsoluteFill>
    );
  }

  // Preload fonts
  useEffect(() => {
    const fonts = [fontFamily];
    if (script.settings?.font) {
      fonts.push(script.settings.font);
    }
    
    // Force font loading before render
    const preloadFonts = async () => {
      await Promise.all(
        fonts.map((font) => 
          document.fonts.load(`16px "${font}"`)
        )
      );
    };
    
    preloadFonts();
  }, [script.settings?.font]);

  const components = script.components || [];

  return (
    <AbsoluteFill
      style={{
        backgroundColor: script.settings?.backgroundColor || '#000000',
        fontFamily: script.settings?.font || fontFamily,
        color: script.settings?.textColor || '#ffffff',
      }}
    >
      {components.map((component) => (
        // Render your components here
        <div key={component.id}>
          {/* Component rendering logic */}
        </div>
      ))}
    </AbsoluteFill>
  );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\Video.tsx ---

import {Composition} from 'remotion';
import {QuizVideo} from './QuizVideo';

export const RemotionVideo: React.FC = () => {
	return (
		<Composition
			id="QuizVideo"
			component={QuizVideo}
			durationInFrames={1800} // 60 seconds at 30fps
			fps={30}
			width={1080}
			height={1920} // 9:16 aspect ratio for vertical video
			defaultProps={{
				quizConfig: {
					comparisons: []
				}
			}}
		/>
	);
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Comparison.tsx ---

import {
	AbsoluteFill,
	useCurrentFrame,
	interpolate,
	spring,
	useVideoConfig,
} from 'remotion';
import {Timer} from './Timer';
import {QuizItem} from '../data/quizData';

interface ComparisonProps {
	data: QuizItem;
	startFrame: number;
}

export const Comparison: React.FC<ComparisonProps> = ({data, startFrame}) => {
	const frame = useCurrentFrame();
	const {fps} = useVideoConfig();
	const relativeFrame = frame - startFrame;
	
	const opacity = spring({
		frame: relativeFrame,
		fps,
		config: {
			damping: 200,
		},
	});

	if (relativeFrame < 0 || relativeFrame > 150) return null;

	return (
		<AbsoluteFill>
			<div style={{
				opacity,
				display: 'flex',
				flexDirection: 'column',
				alignItems: 'center',
				padding: 40,
			}}>
				<h1 style={{
					fontSize: 60,
					color: 'white',
					textAlign: 'center',
					marginBottom: 40,
				}}>
					{data.question}
				</h1>
				
				<div style={{
					display: 'flex',
					width: '100%',
					justifyContent: 'space-between',
				}}>
					{/* Left Option */}
					<div style={{flex: 1, padding: 20}}>
						<img
							src={data.leftOption.image}
							style={{
								width: '100%',
								height: 'auto',
								borderRadius: 20,
							}}
						/>
						<h2 style={{
							color: 'white',
							textAlign: 'center',
							fontSize: 40,
						}}>
							{data.leftOption.text}
						</h2>
					</div>

					{/* Right Option */}
					<div style={{flex: 1, padding: 20}}>
						<img
							src={data.rightOption.image}
							style={{
								width: '100%',
								height: 'auto',
								borderRadius: 20,
							}}
						/>
						<h2 style={{
							color: 'white',
							textAlign: 'center',
							fontSize: 40,
						}}>
							{data.rightOption.text}
						</h2>
					</div>
				</div>

				<Timer startFrame={startFrame} />
			</div>
		</AbsoluteFill>
	);
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ComparisonEditor.tsx ---

import React from 'react';
import {Comparison} from '../types/quiz';
import { ImageSelector } from './ImageSelector';

interface ComparisonEditorProps {
	comparison: Comparison;
	onChange: (updatedComparison: Comparison) => void;
	onDelete: () => void;
}

export const ComparisonEditor: React.FC<ComparisonEditorProps> = ({
	comparison,
	onChange,
	onDelete,
}) => {
	return (
		<div style={{
			padding: '20px',
			border: '1px solid #ccc',
			borderRadius: '8px',
			backgroundColor: '#f8f9fa',
		}}>
			{/* Question Section */}
			<div style={{marginBottom: '20px'}}>
				<label style={{display: 'block', marginBottom: '8px', fontWeight: 'bold'}}>
					Question:
				</label>
				<input
					type="text"
					value={comparison.question}
					onChange={(e) => {
						onChange({
							...comparison,
							question: e.target.value,
						});
					}}
					style={{
						width: '100%',
						padding: '8px',
						fontSize: '16px',
						borderRadius: '4px',
						border: '1px solid #ddd',
					}}
					placeholder="Enter your question..."
				/>
			</div>

			{/* Options Section */}
			<div style={{
				display: 'grid',
				gridTemplateColumns: '1fr 1fr',
				gap: '20px',
			}}>
				{/* Left Option */}
				<div>
					<label style={{display: 'block', marginBottom: '8px', fontWeight: 'bold'}}>
						Left Option:
					</label>
					<input
						type="text"
						value={comparison.leftOption.text}
						onChange={(e) => {
							onChange({
								...comparison,
								leftOption: {
									...comparison.leftOption,
									text: e.target.value,
								},
							});
						}}
						style={{
							width: '100%',
							padding: '8px',
							fontSize: '16px',
							borderRadius: '4px',
							border: '1px solid #ddd',
							marginBottom: '10px',
						}}
						placeholder="Enter left option..."
					/>
					{/* Left Option Image Selection */}
					<ImageSelector
						searchTerm={comparison.leftOption.text}
						onSelect={(imageUrl) => {
							onChange({
								...comparison,
								leftOption: {
									...comparison.leftOption,
									imageUrl,
								},
							});
						}}
						currentImageUrl={comparison.leftOption.imageUrl}
					/>
				</div>

				{/* Right Option */}
				<div>
					<label style={{display: 'block', marginBottom: '8px', fontWeight: 'bold'}}>
						Right Option:
					</label>
					<input
						type="text"
						value={comparison.rightOption.text}
						onChange={(e) => {
							onChange({
								...comparison,
								rightOption: {
									...comparison.rightOption,
									text: e.target.value,
								},
							});
						}}
						style={{
							width: '100%',
							padding: '8px',
							fontSize: '16px',
							borderRadius: '4px',
							border: '1px solid #ddd',
							marginBottom: '10px',
						}}
						placeholder="Enter right option..."
					/>
					{/* Right Option Image Selection */}
					<ImageSelector
						searchTerm={comparison.rightOption.text}
						onSelect={(imageUrl) => {
							onChange({
								...comparison,
								rightOption: {
									...comparison.rightOption,
									imageUrl,
								},
							});
						}}
						currentImageUrl={comparison.rightOption.imageUrl}
					/>
				</div>
			</div>

			{/* Delete Button */}
			<button
				onClick={onDelete}
				style={{
					marginTop: '20px',
					padding: '8px 16px',
					backgroundColor: '#dc3545',
					color: 'white',
					border: 'none',
					borderRadius: '4px',
					cursor: 'pointer',
				}}
			>
				Delete Comparison
			</button>
		</div>
	);
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ConfigMenu\ConfigMenu.tsx ---

import React, { useState, useEffect } from 'react';
import { Modal } from '../common/Modal';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';
import { ImageSelector } from '../Setup/ImageSelector';
import { Script } from '../../types/script';
import { useConfigStore } from '../../store/configStore';
import { useVideoConfig } from 'remotion';
import { useApiKeys } from '../../store/apiKeysStore';
import { FontManager } from '../Settings/FontManager';
import { BackgroundManager } from '../Settings/BackgroundManager';

interface ConfigMenuProps {
    isOpen: boolean;
    onClose: () => void;
    script: Script;
    onScriptChange: (script: Script) => void;
}

interface ExportSettings {
    fps: number;
    width: number;
    height: number;
    codec: 'h264' | 'h265' | 'vp8' | 'vp9';
    quality: number;
}

export const ConfigMenu: React.FC<ConfigMenuProps> = ({
    isOpen,
    onClose,
    script,
    onScriptChange,
}) => {
    const fps = 30;
    const { 
        elevenLabsApiKey, 
        pexelsApiKey, 
        setElevenLabsApiKey,
        setPexelsApiKey,
    } = useApiKeys();

    const [localElevenLabsKey, setLocalElevenLabsKey] = useState(elevenLabsApiKey);
    const [localPexelsKey, setLocalPexelsKey] = useState(pexelsApiKey);
    const [showKeys, setShowKeys] = useState(false);
    const [isFontManagerOpen, setIsFontManagerOpen] = useState(false);
    const [showBackgroundManager, setShowBackgroundManager] = useState(false);
    const [saving, setSaving] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [exportSettings, setExportSettings] = useState<ExportSettings>({
        fps: 30,
        width: 1920,
        height: 1080,
        codec: 'h264',
        quality: 100
    });

    useEffect(() => {
        // Load initial config
        fetch('http://localhost:5003/config')
            .then(res => res.json())
            .then(data => {
                setLocalPexelsKey(data.pexels_api_key || '');
            })
            .catch(err => {
                console.error('Failed to load config:', err);
                setError('Failed to load configuration');
            });
    }, []);

    const handleSave = () => {
        setElevenLabsApiKey(localElevenLabsKey);
        setPexelsApiKey(localPexelsKey);
        
        // Also update the image service config
        fetch('http://localhost:5003/config', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                pexels_api_key: localPexelsKey,
            }),
        }).catch(err => {
            console.error('Failed to update image service config:', err);
        });
        
        onClose();
    };

    const handleBackgroundChange = () => {
        // Create a file input
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*,video/*';
        
        // Handle file selection
        input.onchange = async (e: Event) => {
            const file = (e.target as HTMLInputElement).files?.[0];
            if (!file) return;

            console.log('Selected file:', file.name, file.type);

            // Create form data
            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('http://localhost:3002/set_background', {
                    method: 'POST',
                    body: formData,
                });

                if (!response.ok) {
                    throw new Error('Failed to upload background');
                }

                const { filePath } = await response.json();

                // Update script with new background settings
                const backgroundType = file.type.startsWith('video/') ? 'video' as const : 'image' as const;
                const updatedScript = {
                    ...script,
                    settings: {
                        ...script.settings,
                        background: {
                            type: backgroundType,
                            url: filePath,
                            filePath: file.name,
                            ...(backgroundType === 'video' ? { durationInFrames: 300 } : {})
                        }
                    }
                };

                onScriptChange(updatedScript);
            } catch (error) {
                console.error('Error uploading background:', error);
            }
        };

        // Trigger file selection
        input.click();
    };

    const handleSaveConfig = async () => {
        setSaving(true);
        setError(null);

        try {
            const response = await fetch('http://localhost:5003/config', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    pexels_api_key: pexelsApiKey,
                }),
            });

            if (!response.ok) {
                throw new Error('Failed to save configuration');
            }

            // Show success message or update UI as needed
        } catch (err) {
            console.error('Failed to save config:', err);
            setError(err instanceof Error ? err.message : 'Failed to save configuration');
        } finally {
            setSaving(false);
        }
    };

    return (
        <>
            <Modal
                isOpen={isOpen}
                onClose={onClose}
                title={
                    <h2 style={{
                        ...commonStyles.heading,
                        margin: 0,
                        display: 'flex',
                        alignItems: 'center',
                        gap: theme.spacing.sm,
                        color: theme.colors.text.primary,
                        fontSize: '20px',
                    }}>
                        ‚öôÔ∏è Settings
                    </h2>
                }
            >
                <div style={{
                    display: 'flex',
                    flexDirection: 'column',
                    gap: theme.spacing.md,
                }}>
                    {/* API Key Settings */}
                    <div>
                        <h3 style={commonStyles.heading}>API Keys</h3>
                        <div style={{
                            display: 'flex',
                            justifyContent: 'space-between',
                            alignItems: 'center',
                            marginBottom: '10px',
                        }}>
                            <label style={{ color: theme.colors.text.primary }}>Show API Keys:</label>
                            <input
                                type="checkbox"
                                checked={showKeys}
                                onChange={(e) => setShowKeys(e.target.checked)}
                            />
                        </div>

                        <div style={{ marginBottom: '16px' }}>
                            <label style={{
                                display: 'block',
                                color: theme.colors.text.primary,
                                marginBottom: '8px',
                            }}>
                                ElevenLabs API Key:
                            </label>
                            <input
                                type={showKeys ? 'text' : 'password'}
                                value={localElevenLabsKey}
                                onChange={(e) => setLocalElevenLabsKey(e.target.value)}
                                style={{
                                    width: '100%',
                                    padding: '8px',
                                    backgroundColor: theme.colors.background.secondary,
                                    border: `1px solid ${theme.colors.border}`,
                                    borderRadius: theme.borderRadius.sm,
                                    color: theme.colors.text.primary,
                                }}
                                placeholder="Enter your ElevenLabs API key"
                            />
                        </div>

                        <div style={{ marginBottom: '16px' }}>
                            <label style={{
                                display: 'block',
                                color: theme.colors.text.primary,
                                marginBottom: '8px',
                            }}>
                                Pexels API Key:
                            </label>
                            <input
                                type={showKeys ? 'text' : 'password'}
                                value={localPexelsKey}
                                onChange={(e) => setLocalPexelsKey(e.target.value)}
                                style={{
                                    width: '100%',
                                    padding: '8px',
                                    backgroundColor: theme.colors.background.secondary,
                                    border: `1px solid ${theme.colors.border}`,
                                    borderRadius: theme.borderRadius.sm,
                                    color: theme.colors.text.primary,
                                }}
                                placeholder="Enter your Pexels API key"
                            />
                        </div>
                    </div>

                    {/* Background Settings */}
                    <div>
                        <h3 style={commonStyles.heading}>Background</h3>
                        <div style={{
                            display: 'flex',
                            flexDirection: 'column',
                            gap: theme.spacing.sm,
                        }}>
                            <button
                                onClick={() => setShowBackgroundManager(true)}
                                style={commonStyles.button.secondary}
                            >
                                Manage Backgrounds
                            </button>
                            {script.settings.background?.url && (
                                <button
                                    onClick={() => onScriptChange({
                                        ...script,
                                        settings: {
                                            ...script.settings,
                                            background: {
                                                type: 'none',
                                            },
                                        },
                                    })}
                                    style={{
                                        ...commonStyles.button.secondary,
                                        color: theme.colors.error,
                                    }}
                                >
                                    Reset to Default
                                </button>
                            )}
                            {script.settings.background?.type === 'video' && (
                                <div style={{
                                    color: theme.colors.text.secondary,
                                    fontSize: '0.9em',
                                    marginTop: theme.spacing.sm,
                                }}>
                                    Note: Video will loop if timeline exceeds video length
                                </div>
                            )}
                        </div>
                    </div>

                    {/* Font Manager Button */}
                    <div>
                        <button
                            onClick={() => setIsFontManagerOpen(true)}
                            style={{
                                ...commonStyles.button,
                                width: '100%',
                                padding: theme.spacing.md,
                                backgroundColor: theme.colors.primary,
                                color: theme.colors.text.primary,
                            }}
                        >
                            Manage Custom Fonts
                        </button>
                    </div>

                    {/* Export Settings */}
                    <div>
                        <h3 style={commonStyles.heading}>Export Settings</h3>
                        <div style={{
                            display: 'grid',
                            gridTemplateColumns: '1fr 1fr',
                            gap: theme.spacing.sm,
                        }}>
                            <div>
                                <label style={styles.label}>FPS:</label>
                                <input
                                    type="number"
                                    value={exportSettings.fps}
                                    onChange={(e) => setExportSettings({
                                        ...exportSettings,
                                        fps: Number(e.target.value)
                                    })}
                                    min={1}
                                    max={60}
                                    style={styles.input}
                                />
                            </div>
                            <div>
                                <label style={styles.label}>Quality (%):</label>
                                <input
                                    type="number"
                                    value={exportSettings.quality}
                                    onChange={(e) => setExportSettings({
                                        ...exportSettings,
                                        quality: Number(e.target.value)
                                    })}
                                    min={1}
                                    max={100}
                                    style={styles.input}
                                />
                            </div>
                            <div>
                                <label style={styles.label}>Width:</label>
                                <input
                                    type="number"
                                    value={exportSettings.width}
                                    onChange={(e) => setExportSettings({
                                        ...exportSettings,
                                        width: Number(e.target.value)
                                    })}
                                    min={100}
                                    max={3840}
                                    step={2}
                                    style={styles.input}
                                />
                            </div>
                            <div>
                                <label style={styles.label}>Height:</label>
                                <input
                                    type="number"
                                    value={exportSettings.height}
                                    onChange={(e) => setExportSettings({
                                        ...exportSettings,
                                        height: Number(e.target.value)
                                    })}
                                    min={100}
                                    max={2160}
                                    step={2}
                                    style={styles.input}
                                />
                            </div>
                            <div style={{ gridColumn: '1 / -1' }}>
                                <label style={styles.label}>Codec:</label>
                                <select
                                    value={exportSettings.codec}
                                    onChange={(e) => setExportSettings({
                                        ...exportSettings,
                                        codec: e.target.value as ExportSettings['codec']
                                    })}
                                    style={styles.select}
                                >
                                    <option value="h264">H.264</option>
                                    <option value="h265">H.265 (HEVC)</option>
                                    <option value="vp8">VP8</option>
                                    <option value="vp9">VP9</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    {/* Save Button */}
                    <div style={{
                        display: 'flex',
                        justifyContent: 'flex-end',
                        gap: theme.spacing.sm,
                        marginTop: theme.spacing.md,
                    }}>
                        <button
                            onClick={onClose}
                            style={commonStyles.button.secondary}
                        >
                            Cancel
                        </button>
                        <button
                            onClick={handleSave}
                            style={commonStyles.button.primary}
                        >
                            Save
                        </button>
                    </div>
                </div>
            </Modal>

            {/* Background Manager Modal */}
            {showBackgroundManager && (
                <Modal
                    isOpen={showBackgroundManager}
                    onClose={() => setShowBackgroundManager(false)}
                    title="Background Manager"
                >
                    <BackgroundManager
                        onSelectBackground={(background) => {
                            onScriptChange({
                                ...script,
                                settings: {
                                    ...script.settings,
                                    background: background
                                }
                            });
                            setShowBackgroundManager(false);
                        }}
                    />
                </Modal>
            )}

            {/* Font Manager Modal */}
            {isFontManagerOpen && (
                <FontManager onClose={() => setIsFontManagerOpen(false)} />
            )}
        </>
    );
};

const styles = {
    label: {
        display: 'block',
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
        marginBottom: theme.spacing.xs,
    },
    input: {
        width: '100%',
        padding: theme.spacing.sm,
        backgroundColor: theme.colors.background.secondary,
        border: `1px solid ${theme.colors.border}`,
        borderRadius: theme.borderRadius.sm,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
    },
    select: {
        width: '100%',
        padding: theme.spacing.sm,
        backgroundColor: theme.colors.background.secondary,
        border: `1px solid ${theme.colors.border}`,
        borderRadius: theme.borderRadius.sm,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ImageSelector.tsx ---

import React, { useState, useEffect } from 'react';
import { createClient, Photo } from 'pexels';
import { theme } from '../styles/theme';

const client = createClient('rXEDE5m6pUxOXZPawHmzKj04Z29WlV2y0Us44ld2TmXwdZstXtHUIh2F');

interface ImageSelectorProps {
    searchTerm: string;
    onSelect: (imageUrl: string) => void;
    currentImageUrl?: string;
    orientation?: 'portrait' | 'landscape' | 'square';
}

export const ImageSelector: React.FC<ImageSelectorProps> = ({
    searchTerm,
    onSelect,
    currentImageUrl,
    orientation = 'landscape'
}) => {
    const [images, setImages] = useState<Photo[]>([]);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [page, setPage] = useState(1);
    const [totalPages, setTotalPages] = useState(1);
    const perPage = 6;

    useEffect(() => {
        if (!searchTerm) return;

        const searchImages = async () => {
            setLoading(true);
            setError(null);
            try {
                const result = await client.photos.search({
                    query: searchTerm,
                    per_page: perPage,
                    page,
                    orientation
                });
                setImages(result.photos || []);
                setTotalPages(Math.ceil((result.total_results || 0) / perPage));
            } catch (err) {
                setError('Failed to load images');
                console.error(err);
            } finally {
                setLoading(false);
            }
        };

        searchImages();
    }, [searchTerm, page, orientation]);

    return (
        <div style={styles.container}>
            {loading && <div style={styles.loading}>Loading images...</div>}
            {error && <div style={styles.error}>{error}</div>}
            
            <div style={styles.grid}>
                {images.map((photo) => (
                    <div
                        key={photo.id}
                        style={{
                            ...styles.imageContainer,
                            border: currentImageUrl === photo.src.medium ? `3px solid ${theme.colors.primary}` : '1px solid #ddd',
                        }}
                        onClick={() => onSelect(photo.src.medium)}
                    >
                        <img
                            src={photo.src.medium}
                            alt={photo.alt || 'Option image'}
                            style={styles.image}
                        />
                        <div style={styles.imageOverlay}>
                            <span>Select</span>
                        </div>
                    </div>
                ))}
            </div>

            {totalPages > 1 && (
                <div style={styles.pagination}>
                    <button
                        onClick={() => setPage(p => Math.max(1, p - 1))}
                        disabled={page === 1}
                        style={{
                            ...styles.button,
                            opacity: page === 1 ? 0.5 : 1
                        }}
                    >
                        Previous
                    </button>
                    <span style={styles.pageInfo}>
                        Page {page} of {totalPages}
                    </span>
                    <button
                        onClick={() => setPage(p => Math.min(totalPages, p + 1))}
                        disabled={page === totalPages}
                        style={{
                            ...styles.button,
                            opacity: page === totalPages ? 0.5 : 1
                        }}
                    >
                        Next
                    </button>
                </div>
            )}
        </div>
    );
};

const styles = {
    container: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.md,
    },
    loading: {
        textAlign: 'center' as const,
        padding: theme.spacing.md,
        color: theme.colors.text.secondary,
    },
    error: {
        textAlign: 'center' as const,
        padding: theme.spacing.md,
        color: theme.colors.error,
    },
    grid: {
        display: 'grid',
        gridTemplateColumns: 'repeat(2, 1fr)',
        gap: theme.spacing.md,
    },
    imageContainer: {
        position: 'relative' as const,
        cursor: 'pointer',
        borderRadius: theme.borderRadius.md,
        overflow: 'hidden',
        aspectRatio: '16/9',
        transition: 'transform 0.2s ease-in-out',
        '&:hover': {
            transform: 'scale(1.02)',
        },
    },
    image: {
        width: '100%',
        height: '100%',
        objectFit: 'cover' as const,
    },
    imageOverlay: {
        position: 'absolute' as const,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        background: 'rgba(0, 0, 0, 0.5)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        color: '#fff',
        opacity: 0,
        transition: 'opacity 0.2s ease-in-out',
        '&:hover': {
            opacity: 1,
        },
    },
    pagination: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        gap: theme.spacing.md,
        marginTop: theme.spacing.md,
    },
    pageInfo: {
        color: theme.colors.text.secondary,
    },
    button: {
        padding: `${theme.spacing.sm} ${theme.spacing.md}`,
        backgroundColor: theme.colors.primary,
        color: '#fff',
        border: 'none',
        borderRadius: theme.borderRadius.sm,
        cursor: 'pointer',
        '&:disabled': {
            cursor: 'not-allowed',
        },
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Layout\AppLayout.tsx ---

import React, { useState } from 'react';
import { theme } from '../../styles/theme';
import { ConfigMenu } from '../ConfigMenu/ConfigMenu';
import { Script } from '../../types/script';
import { exportVideo } from '../../services/videoService';

interface AppLayoutProps {
    children: [React.ReactNode, React.ReactNode, React.ReactNode]; // Left, Center, Right content
    script: Script;
    onScriptChange: (script: Script) => void;
}

export const AppLayout: React.FC<AppLayoutProps> = ({ 
    children: [leftContent, centerContent, rightContent],
    script,
    onScriptChange,
}) => {
    const [isConfigOpen, setIsConfigOpen] = useState(false);
    const [isExporting, setIsExporting] = useState(false);

    const handleExportVideo = async () => {
        try {
            console.log('Starting video export...');
            console.log('Script data:', script);
            setIsExporting(true);
            const outputLocation = await exportVideo(script, {
                fps: 30,
                width: 1080,
                height: 1920,
                codec: 'h264',
                quality: 100
            });
            console.log('Video exported successfully to:', outputLocation);
            alert(`Video exported successfully to: ${outputLocation}`);
        } catch (error) {
            console.error('Error exporting video:', error);
            alert('Failed to export video. Check console for details.');
        } finally {
            setIsExporting(false);
        }
    };

    return (
        <div style={{
            minHeight: '100vh',
            backgroundColor: theme.colors.background.primary,
            color: theme.colors.text.primary,
            display: 'grid',
            gridTemplateRows: 'auto 1fr',
            overflowX: 'hidden',
        }}>
            {/* Header */}
            <header style={{
                backgroundColor: theme.colors.background.secondary,
                borderBottom: `1px solid ${theme.colors.border}`,
                padding: `${theme.spacing.md} ${theme.spacing.xl}`,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between',
                boxShadow: theme.shadows.md,
                position: 'sticky',
                top: 0,
                zIndex: 100,
            }}>
                <div style={{ display: 'flex', alignItems: 'center', gap: theme.spacing.md }}>
                    <h1 style={{ 
                        margin: 0, 
                        fontSize: '24px',
                        background: `linear-gradient(135deg, ${theme.colors.primary}, ${theme.colors.secondary})`,
                        WebkitBackgroundClip: 'text',
                        WebkitTextFillColor: 'transparent',
                        fontWeight: 'bold',
                    }}>
                        Couples Quiz Creator
                    </h1>
                </div>
                <nav style={{
                    display: 'flex',
                    gap: theme.spacing.lg,
                }}>
                    <button style={{
                        ...commonButtonStyle,
                        backgroundColor: 'transparent',
                        color: theme.colors.text.primary,
                    }}
                    onClick={() => setIsConfigOpen(true)}
                    >
                        ‚öôÔ∏è Settings
                    </button>
                    <button style={{
                        ...commonButtonStyle,
                        backgroundColor: theme.colors.primary,
                        color: theme.colors.text.primary,
                        opacity: isExporting ? 0.7 : 1,
                        cursor: isExporting ? 'not-allowed' : 'pointer',
                    }}
                    onClick={handleExportVideo}
                    disabled={isExporting}
                    >
                        {isExporting ? 'Exporting...' : 'Export Video'}
                    </button>
                </nav>
            </header>

            {/* Main Content */}
            <main style={{
                padding: `${theme.spacing.lg} ${theme.spacing.lg}`,
                display: 'grid',
                gridTemplateColumns: '280px 1fr minmax(500px, 800px)',
                gap: theme.spacing.lg,
                height: 'calc(100vh - 80px)', // Subtract header height
                position: 'relative',
                overflow: 'hidden', // Prevent content from expanding outside
            }}>
                {/* Left Sidebar - Component Palette */}
                <aside style={{
                    backgroundColor: theme.colors.background.secondary,
                    borderRadius: theme.borderRadius.lg,
                    padding: theme.spacing.md,
                    boxShadow: theme.shadows.md,
                    border: `1px solid ${theme.colors.border}`,
                    position: 'sticky',
                    top: '80px',
                    height: 'fit-content',
                    maxHeight: 'calc(100vh - 100px)',
                    overflowY: 'auto',
                }}>
                    {leftContent}
                </aside>

                {/* Center Content - Preview */}
                <div style={{
                    backgroundColor: theme.colors.background.secondary,
                    borderRadius: theme.borderRadius.lg,
                    padding: theme.spacing.md,
                    boxShadow: theme.shadows.md,
                    border: `1px solid ${theme.colors.border}`,
                    display: 'flex',
                    flexDirection: 'column',
                    gap: theme.spacing.md,
                    overflowY: 'auto',
                }}>
                    {centerContent}
                </div>

                {/* Right Sidebar - Properties */}
                <aside style={{
                    backgroundColor: theme.colors.background.secondary,
                    borderRadius: theme.borderRadius.lg,
                    padding: theme.spacing.md,
                    boxShadow: theme.shadows.md,
                    border: `1px solid ${theme.colors.border}`,
                    position: 'sticky',
                    top: '80px',
                    height: 'calc(100vh - 100px)',
                    overflowY: 'auto',
                }}>
                    {rightContent}
                </aside>
            </main>

            {/* Config Menu */}
            <ConfigMenu
                isOpen={isConfigOpen}
                onClose={() => setIsConfigOpen(false)}
                script={script}
                onScriptChange={onScriptChange}
            />
        </div>
    );
};

// Common styles
const commonButtonStyle = {
    padding: `${theme.spacing.sm} ${theme.spacing.lg}`,
    borderRadius: theme.borderRadius.md,
    border: 'none',
    cursor: 'pointer',
    fontWeight: 'bold',
    transition: 'all 0.2s ease',
    '&:hover': {
        opacity: 0.9,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\QuizSetup.tsx ---

import React from 'react';
import { Photo } from 'pexels';
import { ImageSelector } from './ImageSelector';
import { QuizItem } from '../data/quizData';

interface QuizSetupProps {
  onSave: (quizData: QuizItem[]) => void;
}

export const QuizSetup: React.FC<QuizSetupProps> = ({ onSave }) => {
  const [quizItems, setQuizItems] = React.useState<QuizItem[]>([]);
  const [currentItem, setCurrentItem] = React.useState(0);
  const [selectingFor, setSelectingFor] = React.useState<'left' | 'right' | null>(null);

  const handleImageSelect = (photo: Photo) => {
    if (!selectingFor) return;

    setQuizItems((prev) => {
      const updated = [...prev];
      updated[currentItem] = {
        ...updated[currentItem],
        [selectingFor === 'left' ? 'leftOption' : 'rightOption']: {
          ...updated[currentItem][selectingFor === 'left' ? 'leftOption' : 'rightOption'],
          image: photo.src.large,
          pexelsPhoto: photo,
        },
      };
      return updated;
    });

    setSelectingFor(null);
  };

  return (
    <div>
      {selectingFor && (
        <ImageSelector
          onSelect={handleImageSelect}
          searchQuery={
            selectingFor === 'left'
              ? quizItems[currentItem].leftOption.text
              : quizItems[currentItem].rightOption.text
          }
        />
      )}
      
      {/* Add your UI controls for managing quiz items here */}
    </div>
  );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\AudioComponentEditor.tsx ---

import React, { useRef, useState, useEffect } from 'react';
import { AudioComponent } from '../../types/script';
import { theme } from '../../styles/theme';

interface AudioEffect {
    name: string;
    url: string;
}

interface AudioComponentEditorProps {
    component: AudioComponent;
    onChange: (component: AudioComponent) => void;
    onDelete: () => void;
}

export const AudioComponentEditor: React.FC<AudioComponentEditorProps> = ({
    component,
    onChange,
    onDelete,
}) => {
    const fileInputRef = useRef<HTMLInputElement>(null);
    const [effects, setEffects] = useState<AudioEffect[]>([]);
    const [isLoading, setIsLoading] = useState(false);

    // Fetch available effects on mount
    useEffect(() => {
        fetchEffects();
    }, []);

    const fetchEffects = async () => {
        try {
            console.log('Fetching available audio effects...');
            const response = await fetch('http://localhost:3005/effects/dictionary');
            if (!response.ok) throw new Error('Failed to fetch effects');
            const data = await response.json();
            console.log('Available effects:', data);
            setEffects(Object.entries(data).map(([name, url]) => ({ name, url: url as string })));
        } catch (error) {
            console.error('Error fetching effects:', error);
        }
    };

    const handleStyleChange = (key: string, value: number | boolean | undefined) => {
        onChange({
            ...component,
            style: {
                ...component.style,
                [key]: value,
            },
        });
    };

    const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (!file) return;

        setIsLoading(true);
        try {
            console.log('Uploading audio file:', file.name);
            const formData = new FormData();
            formData.append('file', file);

            const response = await fetch('http://localhost:3005/effects/upload', {
                method: 'POST',
                body: formData,
            });

            if (!response.ok) throw new Error('Failed to upload audio file');
            const data = await response.json();
            console.log('Upload successful:', data);

            onChange({
                ...component,
                audioUrl: data.url,
            });

            // Refresh effects list after upload
            await fetchEffects();
        } catch (error) {
            console.error('Error uploading audio file:', error);
            alert('Failed to upload audio file. Please try again.');
        } finally {
            setIsLoading(false);
        }
    };

    const handleEffectSelect = (effect: AudioEffect) => {
        console.log('Selected effect:', effect);
        onChange({
            ...component,
            audioUrl: effect.url,
        });
    };

    const handleEffectDelete = async (effectName: string) => {
        try {
            console.log('Deleting effect:', effectName);
            const response = await fetch('http://localhost:3005/effects/delete', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ name: effectName }),
            });

            if (!response.ok) throw new Error('Failed to delete effect');
            console.log('Effect deleted successfully');
            
            // Refresh effects list after deletion
            await fetchEffects();
        } catch (error) {
            console.error('Error deleting effect:', error);
            alert('Failed to delete effect. Please try again.');
        }
    };

    return (
        <div style={{ display: 'flex', flexDirection: 'column', gap: theme.spacing.md }}>
            <div style={{
                padding: theme.spacing.md,
                backgroundColor: theme.colors.background.tertiary,
                borderRadius: theme.borderRadius.md,
            }}>
                <h3 style={{
                    margin: 0,
                    marginBottom: theme.spacing.sm,
                    fontSize: theme.fontSizes.lg,
                    color: theme.colors.text.primary,
                }}>Audio Settings</h3>

                {/* Audio Source Selection */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <label style={{
                        display: 'block',
                        marginBottom: theme.spacing.xs,
                        color: theme.colors.text.secondary,
                    }}>
                        Audio Source
                    </label>
                    <div style={{ display: 'flex', gap: theme.spacing.sm }}>
                        <button
                            onClick={() => fileInputRef.current?.click()}
                            style={{
                                padding: theme.spacing.sm,
                                backgroundColor: theme.colors.primary,
                                color: theme.colors.text.primary,
                                border: 'none',
                                borderRadius: theme.borderRadius.sm,
                                cursor: 'pointer',
                            }}
                            disabled={isLoading}
                        >
                            {isLoading ? 'Uploading...' : 'Upload Audio File'}
                        </button>
                        <input
                            ref={fileInputRef}
                            type="file"
                            accept="audio/*"
                            onChange={handleFileUpload}
                            style={{ display: 'none' }}
                        />
                    </div>

                    {/* Available Effects */}
                    {effects.length > 0 && (
                        <div style={{ 
                            marginTop: theme.spacing.md,
                            padding: theme.spacing.sm,
                            backgroundColor: theme.colors.background.secondary,
                            borderRadius: theme.borderRadius.sm,
                        }}>
                            <h4 style={{
                                margin: 0,
                                marginBottom: theme.spacing.sm,
                                color: theme.colors.text.primary,
                            }}>Available Effects</h4>
                            <div style={{ display: 'flex', flexDirection: 'column', gap: theme.spacing.xs }}>
                                {effects.map((effect) => (
                                    <div key={effect.name} style={{
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'space-between',
                                        padding: theme.spacing.xs,
                                        backgroundColor: component.audioUrl === effect.url ? theme.colors.primary : 'transparent',
                                        borderRadius: theme.borderRadius.sm,
                                        cursor: 'pointer',
                                    }}>
                                        <span
                                            onClick={() => handleEffectSelect(effect)}
                                            style={{
                                                flex: 1,
                                                color: theme.colors.text.primary,
                                            }}
                                        >
                                            {effect.name}
                                        </span>
                                        <button
                                            onClick={() => handleEffectDelete(effect.name)}
                                            style={{
                                                padding: `${theme.spacing.xs} ${theme.spacing.sm}`,
                                                backgroundColor: theme.colors.warning,
                                                color: theme.colors.text.primary,
                                                border: 'none',
                                                borderRadius: theme.borderRadius.sm,
                                                cursor: 'pointer',
                                                fontSize: '0.8em',
                                            }}
                                        >
                                            Delete
                                        </button>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}

                    {/* URL Input */}
                    <input
                        type="text"
                        value={component.audioUrl}
                        onChange={(e) => onChange({ ...component, audioUrl: e.target.value })}
                        placeholder="Or enter audio URL"
                        style={{
                            width: '100%',
                            marginTop: theme.spacing.sm,
                            padding: theme.spacing.sm,
                            borderRadius: theme.borderRadius.sm,
                            border: `1px solid ${theme.colors.border}`,
                            backgroundColor: theme.colors.background.secondary,
                            color: theme.colors.text.primary,
                        }}
                    />
                </div>

                {/* Volume Control */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <label style={{
                        display: 'block',
                        marginBottom: theme.spacing.xs,
                        color: theme.colors.text.secondary,
                    }}>
                        Volume
                    </label>
                    <input
                        type="range"
                        min="0"
                        max="1"
                        step="0.1"
                        value={component.style?.volume ?? 1}
                        onChange={(e) => handleStyleChange('volume', parseFloat(e.target.value))}
                        style={{ width: '100%' }}
                    />
                </div>

                {/* Start Time */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <label style={{
                        display: 'block',
                        marginBottom: theme.spacing.xs,
                        color: theme.colors.text.secondary,
                    }}>
                        Start Time (seconds)
                    </label>
                    <input
                        type="number"
                        min="0"
                        step="0.1"
                        value={component.style?.startTime ?? 0}
                        onChange={(e) => handleStyleChange('startTime', parseFloat(e.target.value))}
                        style={{
                            width: '100%',
                            padding: theme.spacing.sm,
                            borderRadius: theme.borderRadius.sm,
                            border: `1px solid ${theme.colors.border}`,
                            backgroundColor: theme.colors.background.secondary,
                            color: theme.colors.text.primary,
                        }}
                    />
                </div>

                {/* Duration */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <label style={{
                        display: 'block',
                        marginBottom: theme.spacing.xs,
                        color: theme.colors.text.secondary,
                    }}>
                        Duration (seconds, leave empty for full duration)
                    </label>
                    <input
                        type="number"
                        min="0"
                        step="0.1"
                        value={component.style?.duration ?? ''}
                        onChange={(e) => handleStyleChange('duration', e.target.value ? parseFloat(e.target.value) : undefined)}
                        style={{
                            width: '100%',
                            padding: theme.spacing.sm,
                            borderRadius: theme.borderRadius.sm,
                            border: `1px solid ${theme.colors.border}`,
                            backgroundColor: theme.colors.background.secondary,
                            color: theme.colors.text.primary,
                        }}
                    />
                </div>

                {/* Loop Toggle */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <label style={{
                        display: 'flex',
                        alignItems: 'center',
                        gap: theme.spacing.sm,
                        color: theme.colors.text.secondary,
                        cursor: 'pointer',
                    }}>
                        <input
                            type="checkbox"
                            checked={component.style?.loop ?? false}
                            onChange={(e) => handleStyleChange('loop', e.target.checked)}
                        />
                        Loop Audio
                    </label>
                </div>
            </div>

            {/* Delete Button */}
            <button
                onClick={onDelete}
                style={{
                    padding: theme.spacing.sm,
                    backgroundColor: theme.colors.warning,
                    color: theme.colors.text.primary,
                    border: 'none',
                    borderRadius: theme.borderRadius.sm,
                    cursor: 'pointer',
                    fontWeight: 'bold',
                }}
            >
                Delete
            </button>

            {/* Audio Preview */}
            {component.audioUrl && (
                <div style={{
                    marginTop: theme.spacing.md,
                    padding: theme.spacing.md,
                    backgroundColor: theme.colors.background.tertiary,
                    borderRadius: theme.borderRadius.md,
                }}>
                    <h4 style={{
                        margin: 0,
                        marginBottom: theme.spacing.sm,
                        color: theme.colors.text.primary,
                    }}>Preview</h4>
                    <audio
                        controls
                        src={component.audioUrl}
                        style={{ width: '100%' }}
                    />
                </div>
            )}
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\CaptionEditor.tsx ---

import React, { useState } from 'react';
import { WordTiming } from '../../types/script';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';

interface CaptionEditorProps {
    wordTimings: WordTiming[];
    onWordTimingsChange: (newTimings: WordTiming[]) => void;
    onClose: () => void;
}

export const CaptionEditor: React.FC<CaptionEditorProps> = ({
    wordTimings,
    onWordTimingsChange,
    onClose,
}) => {
    const [editingWord, setEditingWord] = useState<number | null>(null);
    const [localTimings, setLocalTimings] = useState<WordTiming[]>(wordTimings);

    const handleWordChange = (index: number, field: keyof WordTiming, value: string | number) => {
        const newTimings = [...localTimings];
        newTimings[index] = {
            ...newTimings[index],
            [field]: field === 'word' ? value : Number(value),
        };
        setLocalTimings(newTimings);
    };

    const handleSave = () => {
        onWordTimingsChange(localTimings);
        onClose();
    };

    return (
        <div style={{
            padding: theme.spacing.md,
            display: 'flex',
            flexDirection: 'column',
            gap: theme.spacing.md,
            maxHeight: '80vh',
            overflow: 'auto',
        }}>
            <div style={{
                display: 'flex',
                flexDirection: 'column',
                gap: theme.spacing.sm,
            }}>
                {localTimings.map((timing, index) => (
                    <div
                        key={index}
                        style={{
                            display: 'flex',
                            gap: theme.spacing.md,
                            alignItems: 'center',
                            padding: theme.spacing.sm,
                            backgroundColor: theme.colors.background.secondary,
                            borderRadius: theme.borderRadius.sm,
                        }}
                    >
                        <input
                            value={timing.word}
                            onChange={(e) => handleWordChange(index, 'word', e.target.value)}
                            style={{
                                flex: 2,
                                padding: '4px 8px',
                                borderRadius: theme.borderRadius.sm,
                                border: `1px solid ${theme.colors.border}`,
                                backgroundColor: theme.colors.background.tertiary,
                                color: theme.colors.text.primary,
                            }}
                        />
                        <div style={{ display: 'flex', gap: theme.spacing.sm, alignItems: 'center' }}>
                            <label>Start:</label>
                            <input
                                type="number"
                                step="0.1"
                                value={timing.start}
                                onChange={(e) => handleWordChange(index, 'start', e.target.value)}
                                style={{
                                    width: '80px',
                                    padding: '4px 8px',
                                    borderRadius: theme.borderRadius.sm,
                                    border: `1px solid ${theme.colors.border}`,
                                    backgroundColor: theme.colors.background.tertiary,
                                    color: theme.colors.text.primary,
                                }}
                            />
                        </div>
                        <div style={{ display: 'flex', gap: theme.spacing.sm, alignItems: 'center' }}>
                            <label>End:</label>
                            <input
                                type="number"
                                step="0.1"
                                value={timing.end}
                                onChange={(e) => handleWordChange(index, 'end', e.target.value)}
                                style={{
                                    width: '80px',
                                    padding: '4px 8px',
                                    borderRadius: theme.borderRadius.sm,
                                    border: `1px solid ${theme.colors.border}`,
                                    backgroundColor: theme.colors.background.tertiary,
                                    color: theme.colors.text.primary,
                                }}
                            />
                        </div>
                    </div>
                ))}
            </div>

            <div style={{
                display: 'flex',
                justifyContent: 'flex-end',
                gap: theme.spacing.md,
                marginTop: theme.spacing.md,
            }}>
                <button
                    onClick={onClose}
                    style={commonStyles.button.secondary}
                >
                    Cancel
                </button>
                <button
                    onClick={handleSave}
                    style={commonStyles.button.primary}
                >
                    Save Changes
                </button>
            </div>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\CaptionPositioningScreen.tsx ---

import React, { useState } from 'react';
import { CaptionStyleOptions } from '../../types/script';
import { theme } from '../../styles/theme';

interface CaptionPositioningScreenProps {
    style: CaptionStyleOptions;
    onChange: (style: CaptionStyleOptions) => void;
}

export const CaptionPositioningScreen: React.FC<CaptionPositioningScreenProps> = ({
    style,
    onChange,
}) => {
    const [isDragging, setIsDragging] = useState(false);
    const [startPos, setStartPos] = useState({ x: 0, y: 0 });

    const handleMouseDown = (e: React.MouseEvent) => {
        setIsDragging(true);
        setStartPos({
            x: e.clientX - (style.x || 0),
            y: e.clientY - (style.y || 0),
        });
    };

    const handleMouseMove = (e: React.MouseEvent) => {
        if (!isDragging) return;

        const newX = e.clientX - startPos.x;
        const newY = e.clientY - startPos.y;

        onChange({
            ...style,
            x: newX,
            y: newY,
        });
    };

    const handleMouseUp = () => {
        setIsDragging(false);
    };

    return (
        <div style={styles.container}>
            <div style={styles.header}>
                <h3>Caption Positioning</h3>
                <p>Drag to position the captions or use the controls below</p>
            </div>

            <div 
                style={styles.previewArea}
                onMouseMove={handleMouseMove}
                onMouseUp={handleMouseUp}
                onMouseLeave={handleMouseUp}
            >
                <div
                    style={{
                        ...styles.captionPreview,
                        transform: `translate(${style.x || 0}px, ${style.y || 0}px) scale(${style.scale || 1}) rotate(${style.rotation || 0}deg)`,
                        cursor: isDragging ? 'grabbing' : 'grab',
                        fontSize: style.fontSize,
                        color: style.color,
                        backgroundColor: style.backgroundColor,
                        fontFamily: style.fontFamily,
                        fontWeight: style.fontWeight,
                        fontStyle: style.fontStyle,
                        textDecoration: style.textDecoration,
                        padding: style.padding,
                        margin: style.margin,
                        borderRadius: style.borderRadius,
                        border: style.border,
                        boxShadow: style.boxShadow,
                        opacity: style.opacity,
                    }}
                    onMouseDown={handleMouseDown}
                >
                    Sample Caption Text
                </div>
            </div>

            <div style={styles.controls}>
                <div style={styles.controlGroup}>
                    <label>Position X:</label>
                    <input
                        type="number"
                        value={style.x || 0}
                        onChange={(e) => onChange({ ...style, x: Number(e.target.value) })}
                    />
                </div>

                <div style={styles.controlGroup}>
                    <label>Position Y:</label>
                    <input
                        type="number"
                        value={style.y || 0}
                        onChange={(e) => onChange({ ...style, y: Number(e.target.value) })}
                    />
                </div>

                <div style={styles.controlGroup}>
                    <label>Scale:</label>
                    <input
                        type="range"
                        min="0.1"
                        max="2"
                        step="0.1"
                        value={style.scale || 1}
                        onChange={(e) => onChange({ ...style, scale: Number(e.target.value) })}
                    />
                </div>

                <div style={styles.controlGroup}>
                    <label>Rotation:</label>
                    <input
                        type="range"
                        min="-180"
                        max="180"
                        value={style.rotation || 0}
                        onChange={(e) => onChange({ ...style, rotation: Number(e.target.value) })}
                    />
                </div>
            </div>
        </div>
    );
};

const styles = {
    container: {
        padding: theme.spacing.md,
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.md,
    },
    header: {
        textAlign: 'center' as const,
    },
    previewArea: {
        width: '100%',
        height: '300px',
        backgroundColor: '#f0f0f0',
        position: 'relative' as const,
        overflow: 'hidden',
        border: '1px solid #ccc',
        borderRadius: theme.borderRadius.md,
    },
    captionPreview: {
        position: 'absolute' as const,
        userSelect: 'none' as const,
        padding: '10px 20px',
        borderRadius: '5px',
        transition: 'transform 0.1s ease-out',
    },
    controls: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.sm,
    },
    controlGroup: {
        display: 'flex',
        alignItems: 'center',
        gap: theme.spacing.sm,
        '& label': {
            minWidth: '100px',
        },
        '& input': {
            flex: 1,
            padding: theme.spacing.sm,
            borderRadius: theme.borderRadius.sm,
            border: '1px solid #ccc',
        },
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\CaptionTimeline.tsx ---

import React, { useState, useRef, useEffect } from 'react';
import { CaptionTrack, Script, VoiceComponent, WordTiming } from '../../types/script';
import { theme } from '../../styles/theme';
import { Modal } from '../common/Modal';
import { CaptionEditor } from './CaptionEditor';

interface CaptionTimelineProps {
    script: Script;
    onScriptChange: (script: Script) => void;
}

const TRACK_HEIGHT = 40;
const PIXELS_PER_SECOND = 100;
const FRAMES_PER_SECOND = 30;

export const CaptionTimeline: React.FC<CaptionTimelineProps> = ({
    script,
    onScriptChange,
}) => {
    const [draggingId, setDraggingId] = useState<string | null>(null);
    const [dragOffset, setDragOffset] = useState(0);
    const [editingCaption, setEditingCaption] = useState<string | null>(null);
    const [editingWordTimings, setEditingWordTimings] = useState<{id: string, isTrack: boolean} | null>(null);
    const containerRef = useRef<HTMLDivElement>(null);

    // Calculate timeline width based on all components and caption tracks
    const timelineWidth = Math.max(
        ...script.components
            .filter(c => c.type === 'voice')
            .map(c => {
                const start = c.startFrame || 0;
                const duration = c.durationInFrames || 150;
                return (start + duration) / FRAMES_PER_SECOND * PIXELS_PER_SECOND;
            }),
        ...(script.captionTracks || []).map(track => {
            const start = track.startFrame;
            const lastWord = track.wordTimings[track.wordTimings.length - 1];
            const duration = lastWord ? (lastWord.end * FRAMES_PER_SECOND) : 150;
            return (start + duration) / FRAMES_PER_SECOND * PIXELS_PER_SECOND;
        }),
        PIXELS_PER_SECOND * 10 // Minimum width of 10 seconds
    );

    const handleUnlink = (componentId: string) => {
        // Find the voice component
        const component = script.components.find(
            c => c.id === componentId && c.type === 'voice'
        ) as VoiceComponent | undefined;

        if (!component?.wordTimings) return;

        // Create a new caption track
        const newTrack: CaptionTrack = {
            id: `caption_${Date.now()}`,
            originalComponentId: componentId,
            isLinked: false,
            wordTimings: component.wordTimings,
            startFrame: component.startFrame || 0,
            text: component.text,
        };

        // Add to caption tracks
        onScriptChange({
            ...script,
            captionTracks: [...(script.captionTracks || []), newTrack],
        });
    };

    const handleRelink = (trackId: string) => {
        const track = script.captionTracks?.find(t => t.id === trackId);
        if (!track?.originalComponentId) return;

        // Update the original component with the track's timings
        const updatedComponents = script.components.map(comp => {
            if (comp.id === track.originalComponentId && comp.type === 'voice') {
                return {
                    ...comp,
                    wordTimings: track.wordTimings,
                    startFrame: track.startFrame,
                };
            }
            return comp;
        });

        // Remove this track from caption tracks
        onScriptChange({
            ...script,
            components: updatedComponents,
            captionTracks: script.captionTracks?.filter(t => t.id !== trackId) || [],
        });
    };

    const handleDragStart = (e: React.DragEvent, track: CaptionTrack) => {
        const rect = e.currentTarget.getBoundingClientRect();
        const offsetX = e.clientX - rect.left;
        setDragOffset(Math.round((offsetX / PIXELS_PER_SECOND) * FRAMES_PER_SECOND));
        setDraggingId(track.id);
    };

    const handleDrag = (e: React.DragEvent) => {
        if (!draggingId) return;

        const rect = e.currentTarget.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const newStartFrame = Math.max(0, Math.round((x / PIXELS_PER_SECOND) * FRAMES_PER_SECOND) - dragOffset);

        const updatedTracks = script.captionTracks?.map(track => 
            track.id === draggingId ? { ...track, startFrame: newStartFrame } : track
        );

        onScriptChange({
            ...script,
            captionTracks: updatedTracks || [],
        });
    };

    const handleEditText = (trackId: string, newText: string) => {
        const updatedTracks = script.captionTracks?.map(track => 
            track.id === trackId ? { ...track, text: newText } : track
        );

        onScriptChange({
            ...script,
            captionTracks: updatedTracks || [],
        });
    };

    const handleWordTimingsChange = (id: string, isTrack: boolean, newTimings: WordTiming[]) => {
        if (isTrack) {
            // Update caption track
            const updatedTracks = script.captionTracks?.map(track => 
                track.id === id ? { ...track, wordTimings: newTimings } : track
            );
            onScriptChange({
                ...script,
                captionTracks: updatedTracks || [],
            });
        } else {
            // Update voice component
            const updatedComponents = script.components.map(comp => 
                comp.id === id && comp.type === 'voice'
                    ? { ...comp, wordTimings: newTimings }
                    : comp
            );
            onScriptChange({
                ...script,
                components: updatedComponents,
            });
        }
    };

    return (
        <>
            <div style={{
                backgroundColor: theme.colors.background.secondary,
                padding: theme.spacing.lg,
                borderRadius: theme.borderRadius.md,
                marginTop: theme.spacing.xl,
                borderTop: `2px solid ${theme.colors.border}`,
            }}>
                <div style={{
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    marginBottom: theme.spacing.lg,
                }}>
                    <h3 style={{ 
                        color: theme.colors.text.primary, 
                        margin: 0,
                        fontSize: '16px',
                        fontWeight: 'bold',
                    }}>
                        Captions Timeline
                    </h3>
                </div>

                <div 
                    ref={containerRef}
                    style={{
                        backgroundColor: theme.colors.background.tertiary,
                        borderRadius: theme.borderRadius.sm,
                        padding: theme.spacing.sm,
                    }}
                >
                    <div style={{
                        width: `${timelineWidth}px`,
                        position: 'relative',
                    }}>
                        {/* Time markers */}
                        <div style={{
                            height: '30px',
                            borderBottom: `1px solid ${theme.colors.border}`,
                            position: 'relative',
                            marginBottom: theme.spacing.sm,
                        }}>
                            {Array.from({ length: Math.ceil(timelineWidth / PIXELS_PER_SECOND) }).map((_, i) => (
                                <div
                                    key={i}
                                    style={{
                                        position: 'absolute',
                                        left: `${i * PIXELS_PER_SECOND}px`,
                                        width: '1px',
                                        height: '15px',
                                        backgroundColor: theme.colors.border,
                                    }}
                                >
                                    <span style={{
                                        position: 'absolute',
                                        top: '-20px',
                                        left: '2px',
                                        fontSize: '12px',
                                        color: theme.colors.text.secondary,
                                        fontFamily: 'monospace',
                                    }}>
                                        {i}s
                                    </span>
                                </div>
                            ))}
                        </div>

                        {/* Empty tracks */}
                        {Array.from({ length: 3 }).map((_, index) => (
                            <div
                                key={`empty-track-${index}`}
                                style={{
                                    height: TRACK_HEIGHT,
                                    borderBottom: `1px solid ${theme.colors.border}`,
                                    position: 'relative',
                                    backgroundColor: index % 2 === 0 ? theme.colors.background.secondary : 'transparent',
                                    marginBottom: theme.spacing.sm,
                                }}
                            />
                        ))}

                        {/* Voice components with captions */}
                        {script.components
                            .filter(c => c.type === 'voice' && (c as VoiceComponent).wordTimings)
                            .map((component) => {
                                const voiceComponent = component as VoiceComponent;
                                const isUnlinked = script.captionTracks?.some(
                                    t => t.originalComponentId === component.id
                                );

                                return (
                                    <div
                                        key={component.id}
                                        style={{
                                            height: TRACK_HEIGHT,
                                            borderBottom: `1px solid ${theme.colors.border}`,
                                            position: 'relative',
                                            backgroundColor: theme.colors.background.secondary,
                                            marginBottom: theme.spacing.sm,
                                        }}
                                    >
                                        <div style={{
                                            position: 'absolute',
                                            left: `${((component.startFrame || 0) / FRAMES_PER_SECOND) * PIXELS_PER_SECOND}px`,
                                            height: TRACK_HEIGHT,
                                            backgroundColor: isUnlinked ? theme.colors.background.tertiary : theme.colors.primary,
                                            padding: '0 8px',
                                            display: 'flex',
                                            alignItems: 'center',
                                            borderRadius: theme.borderRadius.sm,
                                            cursor: 'pointer',
                                            whiteSpace: 'nowrap',
                                            overflow: 'hidden',
                                            textOverflow: 'ellipsis',
                                            minWidth: '100px',
                                        }}>
                                            <span style={{ marginRight: '8px' }}>
                                                {voiceComponent.text.substring(0, 30)}...
                                            </span>
                                            {!isUnlinked && (
                                                <button
                                                    onClick={() => handleUnlink(component.id)}
                                                    style={{
                                                        padding: '4px 8px',
                                                        backgroundColor: theme.colors.secondary,
                                                        border: 'none',
                                                        borderRadius: theme.borderRadius.sm,
                                                        cursor: 'pointer',
                                                        color: 'white',
                                                        whiteSpace: 'nowrap',
                                                    }}
                                                >
                                                    Unlink
                                                </button>
                                            )}
                                        </div>
                                    </div>
                                );
                            })}

                        {/* Caption tracks */}
                        {script.captionTracks?.map((track, index) => (
                            <div
                                key={track.id}
                                style={{
                                    height: TRACK_HEIGHT,
                                    borderBottom: `1px solid ${theme.colors.border}`,
                                    position: 'relative',
                                    backgroundColor: index % 2 === 0 ? theme.colors.background.secondary : 'transparent',
                                    marginBottom: theme.spacing.sm,
                                }}
                                onDragOver={(e) => e.preventDefault()}
                                onDrop={(e) => {
                                    e.preventDefault();
                                    setDraggingId(null);
                                }}
                            >
                                <div
                                    draggable
                                    onDragStart={(e) => handleDragStart(e, track)}
                                    onDrag={handleDrag}
                                    onDragEnd={() => setDraggingId(null)}
                                    style={{
                                        position: 'absolute',
                                        left: `${(track.startFrame / FRAMES_PER_SECOND) * PIXELS_PER_SECOND}px`,
                                        height: TRACK_HEIGHT,
                                        backgroundColor: theme.colors.secondary,
                                        padding: '0 8px',
                                        display: 'flex',
                                        alignItems: 'center',
                                        borderRadius: theme.borderRadius.sm,
                                        cursor: 'grab',
                                    }}
                                >
                                    {editingCaption === track.id ? (
                                        <input
                                            value={track.text}
                                            onChange={(e) => handleEditText(track.id, e.target.value)}
                                            onBlur={() => setEditingCaption(null)}
                                            autoFocus
                                            style={{
                                                width: '200px',
                                                padding: '4px',
                                                border: 'none',
                                                borderRadius: theme.borderRadius.sm,
                                            }}
                                        />
                                    ) : (
                                        <>
                                            <span
                                                onClick={() => setEditingCaption(track.id)}
                                                style={{ marginRight: '8px', cursor: 'text' }}
                                            >
                                                {track.text.substring(0, 20)}...
                                            </span>
                                            <button
                                                onClick={() => handleRelink(track.id)}
                                                style={{
                                                    padding: '4px 8px',
                                                    backgroundColor: theme.colors.primary,
                                                    border: 'none',
                                                    borderRadius: theme.borderRadius.sm,
                                                    cursor: 'pointer',
                                                    color: 'white',
                                                }}
                                            >
                                                Relink
                                            </button>
                                        </>
                                    )}
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            </div>

            {/* Caption Editor Modal */}
            {editingWordTimings && (
                <Modal
                    isOpen={true}
                    onClose={() => setEditingWordTimings(null)}
                    title="Edit Captions"
                >
                    <CaptionEditor
                        wordTimings={
                            editingWordTimings.isTrack
                                ? script.captionTracks?.find(t => t.id === editingWordTimings.id)?.wordTimings || []
                                : (script.components.find(c => c.id === editingWordTimings.id) as VoiceComponent)?.wordTimings || []
                        }
                        onWordTimingsChange={(newTimings) => 
                            handleWordTimingsChange(editingWordTimings.id, editingWordTimings.isTrack, newTimings)
                        }
                        onClose={() => setEditingWordTimings(null)}
                    />
                </Modal>
            )}
        </>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\ComparisonComponentEditor.tsx ---

import React from 'react';
import { ComparisonComponent, AnimationOptions } from '../../types/script';
import { ImageSelector } from '../ImageSelector';
import { theme } from '../../styles/theme';

interface ComparisonComponentEditorProps {
    component: ComparisonComponent;
    onChange: (updated: ComparisonComponent) => void;
}

export const ComparisonComponentEditor: React.FC<ComparisonComponentEditorProps> = ({
    component,
    onChange,
}) => {
    const handleStyleChange = (updated: Partial<ComparisonComponent['style']>) => {
        onChange({
            ...component,
            style: {
                ...component.style,
                ...updated
            }
        });
    };

    const handleAnimationChange = (updates: Partial<AnimationOptions>) => {
        const currentAnimation = component.style?.animation || {
            type: 'none',
            direction: 'in',
            easing: 'easeInOut',
            duration: 30,
            delay: 0,
            stagger: 0
        };
        handleStyleChange({
            animation: {
                ...currentAnimation,
                ...updates,
            }
        });
    };

    const handleBorderChange = (updates: Partial<NonNullable<ComparisonComponent['style']>['imageBorder']>) => {
        const currentBorder = component.style?.imageBorder || { enabled: false, color: '#000000', width: 1 };
        handleStyleChange({
            imageBorder: {
                ...currentBorder,
                ...updates,
            }
        });
    };

    const handleShadowChange = (updates: Partial<NonNullable<ComparisonComponent['style']>['imageDropShadow']>) => {
        const currentShadow = component.style?.imageDropShadow || { enabled: false, color: '#000000', blur: 10, spread: 0, x: 0, y: 4 };
        handleStyleChange({
            imageDropShadow: {
                ...currentShadow,
                ...updates,
            }
        });
    };

    const handlePositionChange = (updates: Partial<{ x: number; y: number }>) => {
        const currentPosition = component.style?.imagePosition || { x: 0, y: 0 };
        handleStyleChange({
            imagePosition: {
                ...currentPosition,
                ...updates
            }
        });
    };

    return (
        <div style={styles.container}>
            {/* Question */}
            <div style={styles.section}>
                <label style={styles.label}>
                    Question:
                </label>
                <input
                    type="text"
                    value={component.question}
                    onChange={(e) => {
                        onChange({
                            ...component,
                            question: e.target.value || '',
                        });
                    }}
                    style={styles.input}
                    placeholder="Enter your question..."
                />
            </div>

            {/* Settings */}
            <div style={styles.section}>
                <h4 style={styles.sectionTitle}>Settings</h4>
                <div style={styles.settingsGrid}>
                    <div>
                        <label style={styles.label}>Orientation:</label>
                        <select
                            value={component.orientation || 'horizontal'}
                            onChange={(e) => {
                                onChange({
                                    ...component,
                                    orientation: e.target.value as 'horizontal' | 'vertical'
                                });
                            }}
                            style={styles.input}
                        >
                            <option value="horizontal">Side by Side</option>
                            <option value="vertical">Top and Bottom</option>
                        </select>
                    </div>

                    <div>
                        <label style={styles.label}>Duration (frames):</label>
                        <input
                            type="number"
                            min="1"
                            value={component.durationInFrames || 150}
                            onChange={(e) => {
                                onChange({
                                    ...component,
                                    durationInFrames: parseInt(e.target.value)
                                });
                            }}
                            style={styles.input}
                        />
                    </div>
                </div>

                <div style={{ marginTop: theme.spacing.md }}>
                    <label style={{
                        ...styles.label,
                        display: 'flex',
                        alignItems: 'center',
                        gap: theme.spacing.sm,
                    }}>
                        <input
                            type="checkbox"
                            checked={component.style?.showText !== false}
                            onChange={(e) => {
                                onChange({
                                    ...component,
                                    style: {
                                        ...component.style,
                                        showText: e.target.checked
                                    }
                                });
                            }}
                        />
                        Show Text Labels
                    </label>
                </div>

                {component.style?.showText !== false && (
                    <div style={{ marginTop: theme.spacing.md }}>
                        <div style={styles.settingsGrid}>
                            <div>
                                <label style={styles.label}>Font Size:</label>
                                <input
                                    type="number"
                                    value={component.style?.fontSize || 32}
                                    onChange={(e) => {
                                        onChange({
                                            ...component,
                                            style: {
                                                ...component.style,
                                                fontSize: parseInt(e.target.value)
                                            }
                                        });
                                    }}
                                    style={styles.input}
                                />
                            </div>

                            <div>
                                <label style={styles.label}>Text Color:</label>
                                <input
                                    type="color"
                                    value={component.style?.textColor || '#ffffff'}
                                    onChange={(e) => {
                                        onChange({
                                            ...component,
                                            style: {
                                                ...component.style,
                                                textColor: e.target.value
                                            }
                                        });
                                    }}
                                    style={styles.input}
                                />
                            </div>
                        </div>
                    </div>
                )}
            </div>

            {/* Image Style Settings */}
            <div style={{ marginTop: theme.spacing.md }}>
                <h4 style={styles.sectionTitle}>Image Styles</h4>
                
                {/* Border Settings */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <div style={styles.row}>
                        <input
                            type="checkbox"
                            checked={component.style?.imageBorder?.enabled ?? false}
                            onChange={(e) => handleBorderChange({ enabled: e.target.checked })}
                            style={styles.checkbox}
                        />
                        <label style={styles.label}>Enable Border</label>
                    </div>
                    {component.style?.imageBorder?.enabled && (
                        <div style={styles.row}>
                            <input
                                type="color"
                                value={component.style.imageBorder.color ?? '#000000'}
                                onChange={(e) => handleBorderChange({ color: e.target.value })}
                                style={styles.input}
                            />
                            <input
                                type="number"
                                value={component.style.imageBorder.width ?? 1}
                                onChange={(e) => handleBorderChange({ width: Number(e.target.value) })}
                                placeholder="Width"
                                min="1"
                                max="20"
                                style={styles.input}
                            />
                        </div>
                    )}
                </div>

                {/* Drop Shadow Settings */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <div style={styles.row}>
                        <input
                            type="checkbox"
                            checked={component.style?.imageDropShadow?.enabled ?? false}
                            onChange={(e) => handleShadowChange({ enabled: e.target.checked })}
                            style={styles.checkbox}
                        />
                        <label style={styles.label}>Enable Drop Shadow</label>
                    </div>
                    {component.style?.imageDropShadow?.enabled && (
                        <>
                            <div style={styles.row}>
                                <input
                                    type="color"
                                    value={component.style.imageDropShadow.color ?? '#000000'}
                                    onChange={(e) => handleShadowChange({ color: e.target.value })}
                                    style={styles.input}
                                />
                                <input
                                    type="number"
                                    value={component.style.imageDropShadow.blur ?? 10}
                                    onChange={(e) => handleShadowChange({ blur: Number(e.target.value) })}
                                    placeholder="Blur"
                                    min="0"
                                    max="50"
                                    style={styles.input}
                                />
                            </div>
                            <div style={styles.row}>
                                <input
                                    type="number"
                                    value={component.style.imageDropShadow.x ?? 0}
                                    onChange={(e) => handleShadowChange({ x: Number(e.target.value) })}
                                    placeholder="X Offset"
                                    style={styles.input}
                                />
                                <input
                                    type="number"
                                    value={component.style.imageDropShadow.y ?? 0}
                                    onChange={(e) => handleShadowChange({ y: Number(e.target.value) })}
                                    placeholder="Y Offset"
                                    style={styles.input}
                                />
                                <input
                                    type="number"
                                    value={component.style.imageDropShadow.spread ?? 0}
                                    onChange={(e) => handleShadowChange({ spread: Number(e.target.value) })}
                                    placeholder="Spread"
                                    style={styles.input}
                                />
                            </div>
                        </>
                    )}
                </div>

                {/* Layout Settings */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <h4 style={styles.sectionTitle}>Layout</h4>
                    <div style={styles.settingsGrid}>
                        <div>
                            <label style={styles.label}>Image Size (%):</label>
                            <input
                                type="number"
                                min="10"
                                max="500"
                                value={component.style?.imageSize || 100}
                                onChange={(e) => {
                                    const size = Math.max(10, Math.min(500, parseInt(e.target.value) || 100));
                                    handleStyleChange({
                                        imageSize: size
                                    });
                                }}
                                style={styles.input}
                            />
                        </div>
                        <div>
                            <label style={styles.label}>Gap Between Images (px):</label>
                            <input
                                type="number"
                                min="0"
                                max="200"
                                value={component.style?.imageGap || 20}
                                onChange={(e) => {
                                    const gap = Math.max(0, Math.min(200, parseInt(e.target.value) || 20));
                                    handleStyleChange({
                                        imageGap: gap
                                    });
                                }}
                                style={styles.input}
                            />
                        </div>
                    </div>

                    <div style={styles.row}>
                        <input
                            type="checkbox"
                            checked={component.style?.forceSameSize ?? true}
                            onChange={(e) => handleStyleChange({ forceSameSize: e.target.checked })}
                            style={styles.checkbox}
                        />
                        <label style={styles.label}>Force Images to Same Size</label>
                    </div>

                    <div style={styles.settingsGrid}>
                        <div>
                            <label style={styles.label}>Horizontal Position (%):</label>
                            <input
                                type="range"
                                min="-100"
                                max="100"
                                value={component.style?.imagePosition?.x || 0}
                                onChange={(e) => {
                                    handlePositionChange({ x: parseInt(e.target.value) });
                                }}
                                style={styles.input}
                            />
                        </div>
                        <div>
                            <label style={styles.label}>Vertical Position (%):</label>
                            <input
                                type="range"
                                min="-100"
                                max="100"
                                value={component.style?.imagePosition?.y || 0}
                                onChange={(e) => {
                                    handlePositionChange({ y: parseInt(e.target.value) });
                                }}
                                style={styles.input}
                            />
                        </div>
                    </div>
                </div>
            </div>

            {/* Animation Controls */}
            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Animation Settings</h3>
                <div style={styles.row}>
                    <select
                        value={component.style?.animation?.type ?? 'none'}
                        onChange={(e) => handleAnimationChange({ type: e.target.value as AnimationOptions['type'] })}
                        style={styles.input}
                    >
                        <option value="none">None</option>
                        <option value="fade">Fade</option>
                        <option value="scale">Scale</option>
                        <option value="rotate">Rotate</option>
                        <option value="slide">Slide</option>
                    </select>
                </div>
                {component.style?.animation?.type !== 'none' && (
                    <>
                        <div style={styles.row}>
                            <select
                                value={component.style?.animation?.direction ?? 'in'}
                                onChange={(e) => handleAnimationChange({ direction: e.target.value as AnimationOptions['direction'] })}
                                style={styles.input}
                            >
                                <option value="in">In</option>
                                <option value="out">Out</option>
                            </select>
                            <select
                                value={component.style?.animation?.easing ?? 'easeInOut'}
                                onChange={(e) => handleAnimationChange({ easing: e.target.value as AnimationOptions['easing'] })}
                                style={styles.input}
                            >
                                <option value="linear">Linear</option>
                                <option value="easeIn">Ease In</option>
                                <option value="easeOut">Ease Out</option>
                                <option value="easeInOut">Ease In Out</option>
                            </select>
                        </div>
                        <div style={styles.row}>
                            <input
                                type="number"
                                value={component.style?.animation?.duration ?? 30}
                                onChange={(e) => handleAnimationChange({ duration: Number(e.target.value) })}
                                placeholder="Duration (frames)"
                                min="1"
                                style={styles.input}
                            />
                            <input
                                type="number"
                                value={component.style?.animation?.delay ?? 0}
                                onChange={(e) => handleAnimationChange({ delay: Number(e.target.value) })}
                                placeholder="Delay (frames)"
                                min="0"
                                style={styles.input}
                            />
                            <input
                                type="number"
                                value={component.style?.animation?.stagger ?? 0}
                                onChange={(e) => handleAnimationChange({ stagger: Number(e.target.value) })}
                                placeholder="Stagger (frames)"
                                min="0"
                                style={styles.input}
                            />
                        </div>
                    </>
                )}
            </div>

            {/* Options */}
            <div style={{
                ...styles.optionsGrid,
                gridTemplateColumns: component.orientation === 'horizontal' ? '1fr 1fr' : '1fr',
            }}>
                {/* First Option */}
                <div style={styles.optionSection}>
                    <h4 style={styles.sectionTitle}>
                        {component.orientation === 'horizontal' ? 'Left Option' : 'Top Option'}
                    </h4>
                    <input
                        type="text"
                        value={component.leftOption.text}
                        onChange={(e) => {
                            onChange({
                                ...component,
                                leftOption: {
                                    ...component.leftOption,
                                    text: e.target.value || '',
                                }
                            });
                        }}
                        style={styles.input}
                        placeholder="Enter text..."
                    />
                    <ImageSelector
                        onSelect={(url) => {
                            onChange({
                                ...component,
                                leftOption: {
                                    ...component.leftOption,
                                    imageUrl: url,
                                }
                            });
                        }}
                        searchTerm={component.leftOption.text || 'image'}
                    />
                </div>

                {/* Second Option */}
                <div style={styles.optionSection}>
                    <h4 style={styles.sectionTitle}>
                        {component.orientation === 'horizontal' ? 'Right Option' : 'Bottom Option'}
                    </h4>
                    <input
                        type="text"
                        value={component.rightOption.text}
                        onChange={(e) => {
                            onChange({
                                ...component,
                                rightOption: {
                                    ...component.rightOption,
                                    text: e.target.value || '',
                                }
                            });
                        }}
                        style={styles.input}
                        placeholder="Enter text..."
                    />
                    <ImageSelector
                        onSelect={(url) => {
                            onChange({
                                ...component,
                                rightOption: {
                                    ...component.rightOption,
                                    imageUrl: url,
                                }
                            });
                        }}
                        searchTerm={component.rightOption.text || 'image'}
                    />
                </div>
            </div>
        </div>
    );
};

const styles = {
    container: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.md,
        height: '100%',
        backgroundColor: 'transparent',
    },
    section: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.sm,
        padding: theme.spacing.md,
        backgroundColor: theme.colors.background.secondary,
        borderRadius: theme.borderRadius.md,
        border: `1px solid ${theme.colors.border}`,
    },
    sectionTitle: {
        margin: '0 0 8px 0',
        color: theme.colors.text.primary,
        fontSize: '1rem',
        fontWeight: 600,
    },
    label: {
        fontSize: '0.9rem',
        fontWeight: 500,
        color: theme.colors.text.primary,
    },
    input: {
        padding: '0.5rem',
        borderRadius: theme.borderRadius.sm,
        border: `1px solid ${theme.colors.border}`,
        backgroundColor: theme.colors.background.tertiary,
        color: theme.colors.text.primary,
        width: '100%',
        minWidth: 0,
    },
    settingsGrid: {
        display: 'grid',
        gridTemplateColumns: '1fr 1fr',
        gap: theme.spacing.sm,
    },
    optionsGrid: {
        display: 'grid',
        gap: theme.spacing.md,
    },
    optionSection: {
        backgroundColor: theme.colors.background.secondary,
        padding: theme.spacing.md,
        borderRadius: theme.borderRadius.md,
        border: `1px solid ${theme.colors.border}`,
    },
    row: {
        display: 'flex',
        gap: theme.spacing.sm,
        alignItems: 'center',
        flexWrap: 'wrap' as const,
    },
    preview: {
        width: '100%',
        maxHeight: '200px',
        objectFit: 'contain' as const,
        backgroundColor: theme.colors.background.tertiary,
        borderRadius: theme.borderRadius.md,
        marginBottom: theme.spacing.sm,
    },
    checkbox: {
        margin: 0,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\ComponentEditor.tsx ---

import React, { useState } from 'react';
import { ScriptComponent, TextStyle, TextComponent, TitleComponent, CountdownComponent } from '../../types/script';
import { TextComponentEditor } from './TextComponentEditor';
import { TitleComponentEditor } from './TitleComponentEditor';
import { ComparisonComponentEditor } from './ComparisonComponentEditor';
import { CountdownComponentEditor } from './CountdownComponentEditor';
import { VoiceComponentEditor } from './VoiceComponentEditor';
import { PositioningScreen } from './PositioningScreen';
import { theme } from '../../styles/theme';
import { VideoComponentEditor } from './VideoComponentEditor';
import { AudioComponentEditor } from './AudioComponentEditor';

export interface ComponentEditorProps {
    component: ScriptComponent;
    onChange: (updated: ScriptComponent) => void;
    onDelete: () => void;
    onEditPosition?: (componentId: string | null) => void;
}

const defaultStyle: TextStyle = {
    fontSize: 40,
    fontFamily: 'Arial',
    color: '#ffffff',
    textAlign: 'center',
};

const hasStyle = (component: ScriptComponent): component is TextComponent | TitleComponent | CountdownComponent => {
    return ['text', 'title', 'countdown'].includes(component.type);
};

export const ComponentEditor: React.FC<ComponentEditorProps> = ({
    component,
    onChange,
    onDelete,
    onEditPosition,
}) => {
    const [showPositioning, setShowPositioning] = useState(false);

    // Ensure component has a style property if it's a type that requires it
    const componentWithStyle = React.useMemo(() => {
        if (hasStyle(component) && !component.style) {
            return {
                ...component,
                style: defaultStyle,
            };
        }
        return component;
    }, [component]);

    const handlePositionChange = (position: { x: number; y: number }) => {
        if (hasStyle(componentWithStyle)) {
            onChange({
                ...componentWithStyle,
                style: {
                    ...componentWithStyle.style,
                    position: {
                        x: position.x,
                        y: position.y,
                        width: componentWithStyle.style.position?.width || 300,
                    },
                },
            });
        }
    };

    const handleDelete = () => {
        onDelete();
    };

    return (
        <div style={{
            display: 'flex',
            flexDirection: 'column',
            gap: theme.spacing.md,
        }}>
            {/* Header */}
            <div style={{
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                padding: theme.spacing.sm,
                backgroundColor: theme.colors.background.tertiary,
                borderRadius: theme.borderRadius.sm,
            }}>
                <h3 style={{
                    margin: 0,
                    fontSize: theme.fontSizes.lg,
                    color: theme.colors.text.primary,
                }}>
                    {componentWithStyle.type.charAt(0).toUpperCase() + componentWithStyle.type.slice(1)} Settings
                </h3>
                <button
                    onClick={handleDelete}
                    style={{
                        backgroundColor: theme.colors.error,
                        color: 'white',
                        border: 'none',
                        padding: `${theme.spacing.xs} ${theme.spacing.sm}`,
                        borderRadius: theme.borderRadius.sm,
                        cursor: 'pointer',
                        fontSize: theme.fontSizes.sm,
                    }}
                >
                    Delete
                </button>
            </div>

            {/* Component-specific editors */}
            <div style={{
                padding: theme.spacing.sm,
                backgroundColor: theme.colors.background.tertiary,
                borderRadius: theme.borderRadius.sm,
            }}>
                {(() => {
                    switch (componentWithStyle.type) {
                        case 'text':
                            return <TextComponentEditor component={componentWithStyle as TextComponent} onChange={onChange} />;
                        case 'title':
                            return <TitleComponentEditor component={componentWithStyle as TitleComponent} onChange={onChange} />;
                        case 'comparison':
                            return <ComparisonComponentEditor component={componentWithStyle} onChange={onChange} />;
                        case 'countdown':
                            return <CountdownComponentEditor component={componentWithStyle as CountdownComponent} onChange={onChange} />;
                        case 'voice':
                            return <VoiceComponentEditor component={componentWithStyle} onChange={onChange} />;
                        case 'video':
                            return <VideoComponentEditor component={componentWithStyle} onChange={onChange} />;
                        case 'audio':
                            return <AudioComponentEditor component={componentWithStyle} onChange={onChange} onDelete={onDelete} />;
                        default:
                            return <div>Unknown component type: {componentWithStyle.type}</div>;
                    }
                })()}
            </div>

            {/* Position Toggle */}
            {hasStyle(componentWithStyle) && (
                <div style={{
                    padding: theme.spacing.sm,
                    backgroundColor: theme.colors.background.tertiary,
                    borderRadius: theme.borderRadius.sm,
                }}>
                    <button
                        onClick={() => setShowPositioning(!showPositioning)}
                        style={{
                            width: '100%',
                            backgroundColor: showPositioning ? theme.colors.primary : 'transparent',
                            color: showPositioning ? 'white' : theme.colors.text.primary,
                            border: `1px solid ${showPositioning ? theme.colors.primary : theme.colors.border}`,
                            padding: theme.spacing.sm,
                            borderRadius: theme.borderRadius.sm,
                            cursor: 'pointer',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            gap: theme.spacing.sm,
                            transition: 'all 0.2s ease',
                        }}
                    >
                        <span>üìç</span>
                        {showPositioning ? 'Hide Position Editor' : 'Edit Position'}
                    </button>
                </div>
            )}

            {/* Positioning Screen */}
            {showPositioning && hasStyle(componentWithStyle) && (
                <PositioningScreen
                    component={componentWithStyle}
                    onPositionChange={handlePositionChange}
                    onClose={() => setShowPositioning(false)}
                />
            )}

            {/* Position display */}
            {hasStyle(componentWithStyle) && componentWithStyle.style?.position && (
                <div style={{
                    display: 'flex',
                    gap: theme.spacing.md,
                    justifyContent: 'center',
                    color: theme.colors.text.secondary,
                    fontSize: theme.fontSizes.sm,
                    padding: theme.spacing.sm,
                    backgroundColor: theme.colors.background.tertiary,
                    borderRadius: theme.borderRadius.sm,
                }}>
                    <span>X: {Math.round(componentWithStyle.style.position.x)}</span>
                    <span>Y: {Math.round(componentWithStyle.style.position.y)}</span>
                </div>
            )}
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\ComponentEditors.tsx ---

import React from 'react';
import { Component } from '../../types/script';
import { TextComponentEditor } from './TextComponentEditor';
import { ComparisonComponentEditor } from './ComparisonComponentEditor';
import { VoiceComponentEditor } from './VoiceComponentEditor';
import { VideoComponentEditor } from './VideoComponentEditor';
import { AudioComponentEditor } from './AudioComponentEditor';

interface ComponentEditorProps {
    component: Component;
    onChange: (component: Component) => void;
}

const componentEditors: Record<string, React.ComponentType<any>> = {
    text: TextComponentEditor,
    comparison: ComparisonComponentEditor,
    voice: VoiceComponentEditor,
    video: VideoComponentEditor,
    audio: AudioComponentEditor,
};

export const ComponentEditor: React.FC<ComponentEditorProps> = ({ component, onChange }) => {
    const EditorComponent = componentEditors[component.type];

    if (!EditorComponent) {
        return <div>No editor available for component type: {component.type}</div>;
    }

    return <EditorComponent component={component} onChange={onChange} />;
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\ComponentPalette.tsx ---

import React from 'react';
import { ComponentType } from '../../types/script';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';

interface ComponentPaletteProps {
    onDragStart: (type: ComponentType) => void;
}

interface ComponentOption {
    type: ComponentType;
    label: string;
    icon: string;
    description: string;
    create: () => any;
}

const components: ComponentOption[] = [
    {
        type: 'text',
        label: 'Text',
        icon: 'üìù',
        description: 'Add text with optional voice-over',
        create: () => ({
            type: 'text',
            text: '',
            style: {
                fontSize: '16px',
                fontWeight: 'normal',
                color: '#000000',
                lineHeight: '1.5',
            },
        }),
    },
    {
        type: 'title',
        label: 'Title',
        icon: 'üî§',
        description: 'Large text with optional subtitle',
        create: () => ({
            type: 'title',
            text: '',
            style: {
                fontSize: '24px',
                fontWeight: 'bold',
                color: '#000000',
                lineHeight: '1.2',
            },
        }),
    },
    {
        type: 'comparison',
        label: 'Comparison',
        icon: '‚öñÔ∏è',
        description: 'Compare two options side by side',
        create: () => ({
            type: 'comparison',
            options: [],
            style: {
                width: '100%',
                height: 'auto',
            },
        }),
    },
    {
        type: 'countdown',
        label: 'Countdown',
        icon: '‚è±Ô∏è',
        description: 'Animated countdown timer',
        create: () => ({
            type: 'countdown',
            duration: 60,
            style: {
                width: '100%',
                height: 'auto',
            },
        }),
    },
    {
        type: 'transition',
        label: 'Transition',
        icon: 'üîÑ',
        description: 'Smooth transition between scenes',
        create: () => ({
            type: 'transition',
            duration: 1,
            style: {
                width: '100%',
                height: 'auto',
            },
        }),
    },
    {
        type: 'voice',
        label: 'Voice',
        icon: 'üéôÔ∏è',
        description: 'Generate voice with synchronized captions',
        create: () => ({
            type: 'voice',
            text: '',
            style: {
                fontSize: '16px',
                fontWeight: 'normal',
                color: '#000000',
                lineHeight: '1.5',
            },
        }),
    },
    {
        type: 'video',
        label: 'Video',
        icon: 'üé¨',
        description: 'Add custom video content',
        create: () => ({
            type: 'video',
            videoUrl: '',
            style: {
                width: '100%',
                height: 'auto',
            },
        }),
    },
    {
        type: 'audio',
        label: 'Audio Effect',
        icon: 'üéµ',
        description: 'Add audio effect',
        create: () => ({
            type: 'audio',
            audioUrl: '',
            style: {
                volume: 1,
                loop: false,
                startTime: 0,
            },
        }),
    },
];

export const ComponentPalette: React.FC<ComponentPaletteProps> = ({ onDragStart }) => {
    return (
        <div>
            <h3 style={commonStyles.heading}>Components</h3>
            <div style={{
                display: 'flex',
                gap: theme.spacing.sm,
                flexWrap: 'wrap',
            }}>
                {components.map(({ type, label, icon, description }) => (
                    <div
                        key={type}
                        draggable
                        onDragStart={(e) => {
                            e.dataTransfer.setData('componentType', type);
                            onDragStart(type);
                        }}
                        style={{
                            backgroundColor: theme.colors.background.tertiary,
                            borderRadius: theme.borderRadius.md,
                            padding: theme.spacing.sm,
                            cursor: 'grab',
                            transition: 'all 0.2s ease',
                            border: `1px solid ${theme.colors.border}`,
                            flex: '0 0 auto',
                            display: 'flex',
                            alignItems: 'center',
                            gap: theme.spacing.sm,
                            minWidth: 'auto',
                        }}
                    >
                        <span style={{ fontSize: '1.2em' }}>{icon}</span>
                        <span style={{
                            color: theme.colors.text.primary,
                            fontWeight: 'bold',
                        }}>
                            {label}
                        </span>
                    </div>
                ))}
            </div>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\CountdownComponentEditor.tsx ---

import React from 'react';
import { CountdownComponent } from '../../types/script';
import { TextField, Grid, Switch, FormControlLabel } from '@mui/material';

interface CountdownComponentEditorProps {
    component: CountdownComponent;
    onChange: (component: CountdownComponent) => void;
}

export const CountdownComponentEditor: React.FC<CountdownComponentEditorProps> = ({ component, onChange }) => {
    return (
        <Grid container spacing={2}>
            <Grid item xs={12}>
                <TextField
                    fullWidth
                    type="number"
                    label="Count From"
                    value={component.from}
                    onChange={(e) => onChange({
                        ...component,
                        from: parseInt(e.target.value) || 0
                    })}
                />
            </Grid>
            <Grid item xs={12}>
                <FormControlLabel
                    control={
                        <Switch
                            checked={component.sound ?? false}
                            onChange={(e) => onChange({
                                ...component,
                                sound: e.target.checked
                            })}
                        />
                    }
                    label="Play Sound"
                />
            </Grid>
        </Grid>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\DraggablePreview.tsx ---

import React, { useState, useRef } from 'react';
import { TextStyle } from '../../types/script';

interface DraggablePreviewProps {
    text: string;
    style: TextStyle;
    onChange: (updates: Partial<TextStyle>) => void;
}

export const DraggablePreview: React.FC<DraggablePreviewProps> = ({
    text,
    style,
    onChange,
}) => {
    const containerRef = useRef<HTMLDivElement>(null);
    const elementRef = useRef<HTMLDivElement>(null);
    const [isDragging, setIsDragging] = useState(false);
    const [isResizing, setIsResizing] = useState(false);
    const [startPos, setStartPos] = useState({ x: 0, y: 0 });

    const position = style.position || { x: 50, y: 50, width: 80 };

    const handleMouseDown = (e: React.MouseEvent, mode: 'drag' | 'resize') => {
        if (mode === 'drag') setIsDragging(true);
        if (mode === 'resize') setIsResizing(true);
        setStartPos({ x: e.clientX, y: e.clientY });
        e.preventDefault();
    };

    const handleMouseMove = (e: React.MouseEvent) => {
        if (!isDragging && !isResizing) return;
        if (!containerRef.current) return;

        const containerRect = containerRef.current.getBoundingClientRect();
        
        if (isDragging) {
            const dx = e.clientX - startPos.x;
            const dy = e.clientY - startPos.y;

            const newX = position.x + (dx / containerRect.width * 100);
            const newY = position.y + (dy / containerRect.height * 100);

            onChange({
                position: {
                    ...position,
                    x: Math.max(0, Math.min(100, newX)),
                    y: Math.max(0, Math.min(100, newY)),
                }
            });
        }

        if (isResizing) {
            const dx = e.clientX - startPos.x;
            const newWidth = position.width + (dx / containerRect.width * 100);

            onChange({
                position: {
                    ...position,
                    width: Math.max(10, Math.min(100, newWidth)),
                }
            });
        }

        setStartPos({ x: e.clientX, y: e.clientY });
    };

    const handleMouseUp = () => {
        setIsDragging(false);
        setIsResizing(false);
    };

    return (
        <div
            ref={containerRef}
            style={{
                position: 'relative',
                width: '100%',
                height: '400px',
                backgroundColor: '#1a1a1a',
                borderRadius: '8px',
                overflow: 'hidden',
                cursor: isDragging ? 'grabbing' : 'default',
            }}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseUp}
        >
            <div
                ref={elementRef}
                style={{
                    position: 'absolute',
                    left: `${position.x}%`,
                    top: `${position.y}%`,
                    width: `${position.width}%`,
                    transform: 'translate(-50%, -50%)',
                    cursor: isDragging ? 'grabbing' : 'grab',
                    userSelect: 'none',
                    backgroundColor: 'rgba(255, 255, 255, 0.1)',
                    padding: '20px',
                    borderRadius: '8px',
                    border: '2px solid rgba(255, 255, 255, 0.2)',
                }}
            >
                <div
                    style={{
                        padding: '10px',
                        fontFamily: style.fontFamily,
                        fontSize: `${style.fontSize}px`,
                        color: style.color || '#fff',
                        textAlign: style.textAlign || 'center',
                        fontWeight: style.fontWeight,
                    }}
                    onMouseDown={(e) => handleMouseDown(e, 'drag')}
                >
                    {text || 'Preview text will appear here...'}
                </div>
                <div
                    style={{
                        position: 'absolute',
                        right: '-5px',
                        top: '50%',
                        transform: 'translateY(-50%)',
                        width: '10px',
                        height: '20px',
                        backgroundColor: 'rgba(255, 255, 255, 0.5)',
                        cursor: 'ew-resize',
                        borderRadius: '4px',
                    }}
                    onMouseDown={(e) => handleMouseDown(e, 'resize')}
                />
            </div>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\ImageComponentEditor.tsx ---

import React, { useState } from 'react';
import { ImageComponent } from '../../types/script';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';
import { ColorPicker } from '../common/ColorPicker';
import { Slider } from '../common/Slider';
import { Switch } from '../common/Switch';

interface PexelsImage {
    id: number;
    thumbnail: string;
    url: string;
    photographer: string;
    width: number;
    height: number;
}

interface ImageComponentEditorProps {
    component: ImageComponent;
    onChange: (component: ImageComponent) => void;
}

export const ImageComponentEditor: React.FC<ImageComponentEditorProps> = ({
    component,
    onChange,
}) => {
    const [uploadingImage, setUploadingImage] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [searchQuery, setSearchQuery] = useState('');
    const [searching, setSearching] = useState(false);
    const [pexelsImages, setPexelsImages] = useState<PexelsImage[]>([]);
    const [showPexelsSearch, setShowPexelsSearch] = useState(false);

    const handleImageUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (!file) return;

        setUploadingImage(true);
        setError(null);

        try {
            const formData = new FormData();
            formData.append('file', file);

            const response = await fetch('http://localhost:5003/upload_image', {
                method: 'POST',
                body: formData,
            });

            if (!response.ok) {
                throw new Error('Failed to upload image');
            }

            const data = await response.json();
            onChange({
                ...component,
                imageUrl: data.url,
            });
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to upload image');
        } finally {
            setUploadingImage(false);
        }
    };

    const handlePexelsSearch = async () => {
        if (!searchQuery.trim()) return;

        setSearching(true);
        setError(null);

        try {
            const response = await fetch(`http://localhost:5003/search_pexels?query=${encodeURIComponent(searchQuery)}`);
            if (!response.ok) {
                throw new Error('Failed to search Pexels');
            }

            const images = await response.json();
            setPexelsImages(images);
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to search Pexels');
        } finally {
            setSearching(false);
        }
    };

    const handlePexelsSelect = async (pexelsImage: PexelsImage) => {
        setUploadingImage(true);
        setError(null);

        try {
            const response = await fetch('http://localhost:5003/download_pexels', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ url: pexelsImage.url }),
            });

            if (!response.ok) {
                throw new Error('Failed to download image');
            }

            const data = await response.json();
            onChange({
                ...component,
                imageUrl: data.url,
                style: {
                    ...component.style,
                    width: pexelsImage.width,
                    height: pexelsImage.height,
                },
            });
            setShowPexelsSearch(false);
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to download image');
        } finally {
            setUploadingImage(false);
        }
    };

    const handleStyleChange = (updates: Partial<ImageComponent['style']>) => {
        onChange({
            ...component,
            style: {
                ...component.style,
                ...updates,
            },
        });
    };

    const handleDropShadowChange = (updates: Partial<ImageComponent['style']['dropShadow']>) => {
        handleStyleChange({
            dropShadow: {
                ...component.style?.dropShadow,
                ...updates,
            },
        });
    };

    const handleBorderChange = (updates: Partial<ImageComponent['style']['border']>) => {
        handleStyleChange({
            border: {
                ...component.style?.border,
                ...updates,
            },
        });
    };

    return (
        <div style={styles.container}>
            {/* Image Upload */}
            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Image</h3>
                <div style={styles.uploadButtons}>
                    <input
                        type="file"
                        accept="image/*"
                        onChange={handleImageUpload}
                        style={{ display: 'none' }}
                        id="image-upload"
                    />
                    <label htmlFor="image-upload" style={styles.uploadButton}>
                        {uploadingImage ? 'Uploading...' : 'Upload Image'}
                    </label>
                    <button
                        onClick={() => setShowPexelsSearch(!showPexelsSearch)}
                        style={styles.uploadButton}
                    >
                        Search Pexels
                    </button>
                </div>

                {showPexelsSearch && (
                    <div style={styles.pexelsSearch}>
                        <div style={styles.searchBar}>
                            <input
                                type="text"
                                value={searchQuery}
                                onChange={(e) => setSearchQuery(e.target.value)}
                                onKeyDown={(e) => e.key === 'Enter' && handlePexelsSearch()}
                                placeholder="Search Pexels images..."
                                style={styles.searchInput}
                            />
                            <button
                                onClick={handlePexelsSearch}
                                style={styles.searchButton}
                                disabled={searching}
                            >
                                {searching ? 'Searching...' : 'Search'}
                            </button>
                        </div>
                        <div style={styles.pexelsResults}>
                            {pexelsImages.map((image) => (
                                <div
                                    key={image.id}
                                    onClick={() => handlePexelsSelect(image)}
                                    style={styles.pexelsImage}
                                >
                                    <img
                                        src={image.thumbnail}
                                        alt={`By ${image.photographer}`}
                                        style={styles.pexelsThumbnail}
                                    />
                                    <div style={styles.photographerCredit}>
                                        By {image.photographer}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                )}

                {error && <div style={styles.error}>{error}</div>}
                {component.imageUrl && (
                    <img
                        src={component.imageUrl}
                        alt="Preview"
                        style={styles.preview}
                    />
                )}
            </div>

            {/* Size and Position */}
            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Size & Position</h3>
                <Slider
                    label="Width"
                    value={component.style?.width ?? 400}
                    onChange={(value) => handleStyleChange({ width: value })}
                    min={50}
                    max={1920}
                />
                <Slider
                    label="Height"
                    value={component.style?.height ?? 400}
                    onChange={(value) => handleStyleChange({ height: value })}
                    min={50}
                    max={1080}
                />
                <Slider
                    label="X Position"
                    value={component.style?.position?.x ?? 0}
                    onChange={(value) => handleStyleChange({ position: { ...component.style?.position, x: value } })}
                    min={-1920}
                    max={1920}
                />
                <Slider
                    label="Y Position"
                    value={component.style?.position?.y ?? 0}
                    onChange={(value) => handleStyleChange({ position: { ...component.style?.position, y: value } })}
                    min={-1080}
                    max={1080}
                />
            </div>

            {/* Transform */}
            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Transform</h3>
                <Slider
                    label="Scale"
                    value={component.style?.scale ?? 1}
                    onChange={(value) => handleStyleChange({ scale: value })}
                    min={0.1}
                    max={5}
                    step={0.1}
                />
                <Slider
                    label="Rotation"
                    value={component.style?.rotation ?? 0}
                    onChange={(value) => handleStyleChange({ rotation: value })}
                    min={-180}
                    max={180}
                />
                <Slider
                    label="Opacity"
                    value={component.style?.opacity ?? 1}
                    onChange={(value) => handleStyleChange({ opacity: value })}
                    min={0}
                    max={1}
                    step={0.1}
                />
            </div>

            {/* Border */}
            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Border</h3>
                <Switch
                    label="Enable Border"
                    checked={component.style?.border?.enabled ?? false}
                    onChange={(checked) => handleBorderChange({ enabled: checked })}
                />
                {component.style?.border?.enabled && (
                    <>
                        <ColorPicker
                            label="Border Color"
                            color={component.style.border.color}
                            onChange={(color) => handleBorderChange({ color })}
                        />
                        <Slider
                            label="Border Width"
                            value={component.style.border.width}
                            onChange={(value) => handleBorderChange({ width: value })}
                            min={1}
                            max={20}
                        />
                    </>
                )}
            </div>

            {/* Drop Shadow */}
            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Drop Shadow</h3>
                <Switch
                    label="Enable Shadow"
                    checked={component.style?.dropShadow?.enabled ?? false}
                    onChange={(checked) => handleDropShadowChange({ enabled: checked })}
                />
                {component.style?.dropShadow?.enabled && (
                    <>
                        <ColorPicker
                            label="Shadow Color"
                            color={component.style.dropShadow.color}
                            onChange={(color) => handleDropShadowChange({ color })}
                        />
                        <Slider
                            label="Blur Radius"
                            value={component.style.dropShadow.blur}
                            onChange={(value) => handleDropShadowChange({ blur: value })}
                            min={0}
                            max={50}
                        />
                        <Slider
                            label="Spread"
                            value={component.style.dropShadow.spread}
                            onChange={(value) => handleDropShadowChange({ spread: value })}
                            min={0}
                            max={50}
                        />
                        <Slider
                            label="X Offset"
                            value={component.style.dropShadow.x}
                            onChange={(value) => handleDropShadowChange({ x: value })}
                            min={-50}
                            max={50}
                        />
                        <Slider
                            label="Y Offset"
                            value={component.style.dropShadow.y}
                            onChange={(value) => handleDropShadowChange({ y: value })}
                            min={-50}
                            max={50}
                        />
                    </>
                )}
            </div>
        </div>
    );
};

const styles = {
    container: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.lg,
    },
    section: {
        backgroundColor: theme.colors.background.secondary,
        padding: theme.spacing.md,
        borderRadius: theme.borderRadius.md,
    },
    sectionTitle: {
        margin: 0,
        marginBottom: theme.spacing.sm,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.md,
    },
    uploadButtons: {
        display: 'flex',
        gap: theme.spacing.sm,
        marginBottom: theme.spacing.md,
    },
    uploadButton: {
        ...commonStyles.button.primary,
        display: 'inline-block',
        cursor: 'pointer',
        marginBottom: theme.spacing.md,
    },
    preview: {
        width: '100%',
        height: '200px',
        objectFit: 'cover' as const,
        borderRadius: theme.borderRadius.sm,
        marginTop: theme.spacing.sm,
    },
    error: {
        color: theme.colors.error,
        marginTop: theme.spacing.sm,
        fontSize: theme.fontSizes.sm,
    },
    pexelsSearch: {
        marginTop: theme.spacing.md,
    },
    searchBar: {
        display: 'flex',
        gap: theme.spacing.sm,
        marginBottom: theme.spacing.md,
    },
    searchInput: {
        flex: 1,
        padding: theme.spacing.sm,
        backgroundColor: theme.colors.background.tertiary,
        border: `1px solid ${theme.colors.border}`,
        borderRadius: theme.borderRadius.sm,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
    },
    searchButton: {
        ...commonStyles.button.primary,
    },
    pexelsResults: {
        display: 'grid',
        gridTemplateColumns: 'repeat(auto-fill, minmax(150px, 1fr))',
        gap: theme.spacing.md,
        maxHeight: '400px',
        overflowY: 'auto',
    },
    pexelsImage: {
        cursor: 'pointer',
        borderRadius: theme.borderRadius.sm,
        overflow: 'hidden',
        backgroundColor: theme.colors.background.tertiary,
        transition: 'transform 0.2s',
        '&:hover': {
            transform: 'scale(1.05)',
        },
    },
    pexelsThumbnail: {
        width: '100%',
        height: '150px',
        objectFit: 'cover' as const,
    },
    photographerCredit: {
        padding: theme.spacing.xs,
        fontSize: theme.fontSizes.xs,
        color: theme.colors.text.secondary,
        textAlign: 'center' as const,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\PositioningScreen.tsx ---

import React, { useRef, useState, useEffect, useCallback } from 'react';
import { TextComponent } from '../../types/script';
import { theme } from '../../styles/theme';

const PREVIEW_WIDTH = 400; // Doubled from 200
const PREVIEW_HEIGHT = 712; // Doubled from 356
const SCALE_FACTOR = 2.7; // Halved from 5.4 since we doubled the preview size

interface Props {
    component: TextComponent;
    onPositionChange: (position: { x: number; y: number }) => void;
    onClose: () => void;
}

const getInitialPosition = (component: TextComponent) => {
    if (component.style?.position) {
        return {
            x: component.style.position.x / SCALE_FACTOR,
            y: component.style.position.y / SCALE_FACTOR,
        };
    }
    return {
        x: PREVIEW_WIDTH / 2,
        y: PREVIEW_HEIGHT / 2,
    };
};

export const PositioningScreen: React.FC<Props> = React.memo(({ component, onPositionChange, onClose }) => {
    const containerRef = useRef<HTMLDivElement>(null);
    const [state, setState] = useState(() => ({
        isDragging: false,
        position: getInitialPosition(component)
    }));

    const updatePosition = useCallback((clientX: number, clientY: number) => {
        if (containerRef.current) {
            const rect = containerRef.current.getBoundingClientRect();
            const x = Math.min(Math.max(0, clientX - rect.left), PREVIEW_WIDTH);
            const y = Math.min(Math.max(0, clientY - rect.top), PREVIEW_HEIGHT);
            
            setState(prev => ({
                ...prev,
                position: { x, y }
            }));
            onPositionChange({
                x: Math.round(x * SCALE_FACTOR),
                y: Math.round(y * SCALE_FACTOR),
            });
        }
    }, [onPositionChange]);

    const handleMouseDown = useCallback((e: React.MouseEvent) => {
        setState(prev => ({ ...prev, isDragging: true }));
        updatePosition(e.clientX, e.clientY);
    }, [updatePosition]);

    const handleMouseMove = useCallback((e: MouseEvent) => {
        if (state.isDragging) {
            updatePosition(e.clientX, e.clientY);
        }
    }, [state.isDragging, updatePosition]);

    const handleMouseUp = useCallback(() => {
        setState(prev => ({ ...prev, isDragging: false }));
    }, []);

    useEffect(() => {
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        return () => {
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
        };
    }, [handleMouseMove, handleMouseUp]);

    return (
        <div style={{
            display: 'flex',
            flexDirection: 'column',
            gap: theme.spacing.sm,
        }}>
            <div
                ref={containerRef}
                onMouseDown={handleMouseDown}
                style={{
                    width: PREVIEW_WIDTH,
                    height: PREVIEW_HEIGHT,
                    backgroundColor: '#1a1a1a',
                    position: 'relative',
                    borderRadius: theme.borderRadius.sm,
                    overflow: 'hidden',
                    cursor: state.isDragging ? 'grabbing' : 'grab',
                }}
            >
                {/* Grid lines */}
                <div style={{
                    position: 'absolute',
                    inset: 0,
                    backgroundImage: `
                        linear-gradient(to right, #333 1px, transparent 1px),
                        linear-gradient(to bottom, #333 1px, transparent 1px)
                    `,
                    backgroundSize: '40px 40px',
                    opacity: 0.5,
                    pointerEvents: 'none',
                }} />

                {/* Center dot */}
                <div
                    style={{
                        position: 'absolute',
                        left: state.position.x,
                        top: state.position.y,
                        width: 8,
                        height: 8,
                        backgroundColor: theme.colors.primary,
                        borderRadius: '50%',
                        transform: 'translate(-50%, -50%)',
                        pointerEvents: 'none',
                        boxShadow: '0 0 0 2px rgba(255, 255, 255, 0.3)',
                    }}
                />
            </div>

            {/* Position display */}
            <div style={{
                display: 'flex',
                gap: theme.spacing.md,
                justifyContent: 'center',
                color: theme.colors.text.secondary,
                fontSize: theme.fontSizes.sm,
            }}>
                <span>X: {Math.round(state.position.x * SCALE_FACTOR)}</span>
                <span>Y: {Math.round(state.position.y * SCALE_FACTOR)}</span>
            </div>
        </div>
    );
}); 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\ScriptEditor.tsx ---

import React, { useState } from 'react';
import { Script, ScriptComponent, ComponentType } from '../../types/script';
import { ComponentEditor } from './ComponentEditor';
import { StyleEditor } from './StyleEditor';
import { Player } from '@remotion/player';
import { ScriptVideo } from '../Video/ScriptVideo';
import { ComponentPalette } from './ComponentPalette';
import { Timeline } from './Timeline';
import '../../styles/timeline.css';
import { ConfigMenu } from '../ConfigMenu/ConfigMenu';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';
import { Modal } from '../common/Modal';
import { TemplateManager } from '../TemplateManager/TemplateManager';
import { CaptionTimeline } from './CaptionTimeline';

export const ScriptEditor: React.FC = () => {
    const [script, setScript] = useState<Script>({
        id: Date.now().toString(),
        title: 'New Quiz',
        components: [],
        captionTracks: [],
        settings: {
            defaultTextStyle: {
                fontSize: 40,
                color: 'white',
                fontFamily: 'Arial',
                textAlign: 'center',
            },
            defaultCaptionStyle: {
                fontSize: 24,
                color: 'white',
                fontFamily: 'Arial',
                textAlign: 'center',
            },
            background: {
                type: 'none',
            }
        },
    });

    const [selectedComponentId, setSelectedComponentId] = useState<string>();
    const [isConfigOpen, setIsConfigOpen] = useState(false);
    const [isTemplateManagerOpen, setIsTemplateManagerOpen] = useState(false);

    const handleComponentChange = (updated: ScriptComponent) => {
        setScript(prev => ({
            ...prev,
            components: prev.components.map(c => 
                c.id === updated.id ? updated : c
            ),
        }));
    };

    const handleComponentDelete = (id: string) => {
        setScript(prev => ({
            ...prev,
            components: prev.components.filter(c => c.id !== id),
        }));
        setSelectedComponentId(undefined);
    };

    const handleDragStart = (type: ComponentType) => {
        // This can be empty or add visual feedback
    };

    const handleReorder = (newComponents: ScriptComponent[]) => {
        setScript(prev => ({
            ...prev,
            components: newComponents,
        }));
    };

    const selectedComponent = script.components.find(c => c.id === selectedComponentId);

    // Calculate total duration, minimum 30 frames (1 second)
    const totalDuration = Math.max(
        ...script.components.map(comp => {
            const start = comp.startFrame || 0;
            const duration = comp.durationInFrames || 150; // Default 5 seconds if not specified
            return start + duration;
        }),
        30 // Minimum 1 second
    );

    const PreviewPanel = ({ script }: { script: Script }) => (
        <>
            <div style={{
                padding: theme.spacing.md,
                borderBottom: `1px solid ${theme.colors.border}`,
                backgroundColor: theme.colors.background.secondary,
            }}>
                <h3 style={{
                    ...commonStyles.heading,
                    margin: 0,
                    fontSize: '16px',
                }}>
                    Preview
                </h3>
            </div>
            <div style={{
                flex: 1,
                padding: theme.spacing.md,
                display: 'flex',
                flexDirection: 'column',
                gap: theme.spacing.md,
            }}>
                <div style={{
                    position: 'relative',
                    width: '100%',
                    aspectRatio: '9/16',
                    backgroundColor: '#000',
                    borderRadius: theme.borderRadius.md,
                    overflow: 'hidden',
                }}>
                    <Player
                        component={ScriptVideo}
                        durationInFrames={totalDuration}
                        fps={30}
                        compositionWidth={1080}
                        compositionHeight={1920}
                        style={{
                            width: '100%',
                            height: '100%',
                        }}
                        controls
                        autoPlay
                        loop
                        inputProps={{ script }}
                    />
                </div>
            </div>
        </>
    );

    return (
        <div style={{
            backgroundColor: theme.colors.background.primary,
            minHeight: '100vh',
            display: 'flex',
            flexDirection: 'column',
        }}>
            {/* Header */}
            <header style={{
                backgroundColor: theme.colors.background.secondary,
                padding: `${theme.spacing.sm} ${theme.spacing.md}`,
                borderBottom: `1px solid ${theme.colors.border}`,
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                height: '48px',
            }}>
                <h1 style={{ margin: 0, fontSize: '24px' }}>Video Editor</h1>
                <div style={{ display: 'flex', gap: theme.spacing.md }}>
                    <button
                        onClick={() => setIsTemplateManagerOpen(true)}
                        style={{
                            ...commonStyles.button.secondary,
                            display: 'flex',
                            alignItems: 'center',
                            gap: theme.spacing.sm,
                        }}
                    >
                        üìã Templates
                    </button>
                    <button
                        onClick={() => setIsConfigOpen(true)}
                        style={{
                            ...commonStyles.button.secondary,
                            display: 'flex',
                            alignItems: 'center',
                            gap: theme.spacing.sm,
                        }}
                    >
                        ‚öôÔ∏è Settings
                    </button>
                </div>
            </header>

            {/* Main Content */}
            <div style={{
                display: 'grid',
                gridTemplateColumns: '4fr 1fr',
                gap: theme.spacing.sm,
                padding: theme.spacing.sm,
                flex: 1,
                height: 'calc(100vh - 48px)',
                overflow: 'hidden',
            }}>
                {/* Left Panel */}
                <div style={{
                    display: 'flex',
                    flexDirection: 'column',
                    gap: theme.spacing.sm,
                    overflow: 'hidden',
                }}>
                    {/* Component Palette */}
                    <div style={{
                        ...commonStyles.card,
                        padding: theme.spacing.sm,
                    }}>
                        <ComponentPalette onDragStart={handleDragStart} />
                    </div>

                    {/* Timeline Container */}
                    <div style={{
                        ...commonStyles.card,
                        padding: theme.spacing.sm,
                        display: 'flex',
                        flexDirection: 'column',
                        gap: theme.spacing.md,
                        overflow: 'visible',
                    }}>
                        {/* Main Timeline */}
                        <div>
                            <h3 style={{ 
                                color: theme.colors.text.primary, 
                                margin: 0,
                                marginBottom: theme.spacing.md,
                                fontSize: '16px',
                                fontWeight: 'bold',
                            }}>
                                Timeline
                            </h3>
                            <Timeline
                                script={script}
                                onReorder={handleReorder}
                                onSelect={setSelectedComponentId}
                                selectedId={selectedComponentId}
                                onDelete={handleComponentDelete}
                            />
                        </div>

                        {/* Caption Timeline */}
                        <CaptionTimeline
                            script={script}
                            onScriptChange={setScript}
                        />
                    </div>
                </div>

                {/* Right Panel */}
                <div style={{
                    flex: 1,
                    display: 'flex',
                    flexDirection: 'column',
                    padding: theme.spacing.md,
                    backgroundColor: theme.colors.background.primary,
                    overflow: 'auto',
                }}>
                    {/* Preview */}
                    <div style={{
                        position: 'relative',
                        width: '100%',
                        maxWidth: '300px',
                        margin: '0 auto',
                        aspectRatio: '9/16',
                        backgroundColor: '#000',
                        borderRadius: theme.borderRadius.lg,
                        overflow: 'hidden',
                    }}>
                        <Player
                            component={ScriptVideo}
                            durationInFrames={totalDuration}
                            fps={30}
                            compositionWidth={1080}
                            compositionHeight={1920}
                            style={{
                                width: '100%',
                                height: '100%',
                            }}
                            controls
                            autoPlay
                            loop
                            inputProps={{
                                script
                            }}
                        />
                    </div>
                </div>
            </div>

            {/* Component Editor Modal */}
            <Modal
                isOpen={!!selectedComponentId}
                onClose={() => setSelectedComponentId(undefined)}
                title={
                    selectedComponent && (
                        <h2 style={{
                            ...commonStyles.heading,
                            margin: 0,
                            display: 'flex',
                            alignItems: 'center',
                            gap: theme.spacing.sm,
                            color: theme.colors.text.primary,
                            fontSize: '20px',
                        }}>
                            <span style={{ fontSize: '1.2em' }}>
                                {selectedComponent.type === 'title' && 'üìë'}
                                {selectedComponent.type === 'text' && 'üìù'}
                                {selectedComponent.type === 'comparison' && '‚öñÔ∏è'}
                                {selectedComponent.type === 'countdown' && '‚è≤Ô∏è'}
                                {selectedComponent.type === 'transition' && 'üîÑ'}
                            </span>
                            Edit {selectedComponent.type.charAt(0).toUpperCase() + selectedComponent.type.slice(1)}
                        </h2>
                    )
                }
            >
                {selectedComponent && (
                    <ComponentEditor
                        component={selectedComponent}
                        onChange={handleComponentChange}
                        onDelete={handleComponentDelete}
                    />
                )}
            </Modal>

            <ConfigMenu 
                isOpen={isConfigOpen} 
                onClose={() => setIsConfigOpen(false)} 
                script={script}
                onScriptChange={setScript}
            />

            {/* Template Manager Modal */}
            <Modal
                isOpen={isTemplateManagerOpen}
                onClose={() => setIsTemplateManagerOpen(false)}
                title="Template Manager"
            >
                <TemplateManager
                    currentScript={script}
                    onTemplateSelect={(newScript) => {
                        setScript(newScript);
                        setIsTemplateManagerOpen(false);
                    }}
                />
            </Modal>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\TextComponentEditor.tsx ---

import React, { useState, useEffect } from 'react';
import { TextComponent } from '../../types/script';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';
import { PositioningScreen } from './PositioningScreen';

interface TextComponentEditorProps {
    component: TextComponent;
    onChange: (updated: TextComponent) => void;
}

// Predefined fonts list
const FONTS = {
    system: [
        'Arial',
        'Helvetica',
        'Times New Roman',
        'Georgia',
        'Verdana',
        'Roboto',
        'Open Sans',
        'Montserrat',
    ],
    getCustomFonts: (): string[] => {
        try {
            const savedFonts = localStorage.getItem('customFonts');
            if (savedFonts) {
                const fonts = JSON.parse(savedFonts);
                return fonts.map((font: { name: string }) => font.name);
            }
        } catch (error) {
            console.error('Error loading custom fonts:', error);
        }
        return [];
    },
};

const styles = {
    section: {
        backgroundColor: theme.colors.background.tertiary,
        padding: theme.spacing.md,
        borderRadius: theme.borderRadius.md,
        marginBottom: theme.spacing.md,
    },
    sectionTitle: {
        fontSize: '14px',
        fontWeight: 'bold',
        color: theme.colors.text.primary,
        margin: 0,
        marginBottom: theme.spacing.sm,
    },
    input: {
        width: '100%',
        padding: '10px 14px',
        borderRadius: '8px',
        border: `1px solid ${theme.colors.border}`,
        backgroundColor: theme.colors.background.tertiary,
        color: theme.colors.text.primary,
        fontSize: '14px',
        '&:focus': {
            outline: 'none',
            borderColor: theme.colors.primary,
        },
    },
    textarea: {
        ...commonStyles.input,
        minHeight: '120px',
        resize: 'vertical' as const,
        whiteSpace: 'pre-wrap',
        lineHeight: '1.5',
        padding: '12px 16px',
    },
    grid: {
        display: 'grid',
        gridTemplateColumns: 'repeat(2, 1fr)',
        gap: '20px',
    },
    previewArea: {
        width: '1920px',
        height: '1080px',
        backgroundColor: 'rgba(0, 0, 0, 0.8)',
        position: 'relative' as const,
        transform: 'scale(0.25)',
        transformOrigin: 'top left',
        cursor: 'pointer',
    },
    animationTimingGrid: {
        marginTop: '12px',
        display: 'grid',
        gap: '12px',
        gridTemplateColumns: '1fr 1fr',
    },
    animationInput: {
        width: '100%',
        padding: '8px 12px',
        borderRadius: '6px',
        border: `1px solid ${theme.colors.border}`,
        backgroundColor: theme.colors.background.tertiary,
        color: theme.colors.text.primary,
        fontSize: '14px',
        fontFamily: 'monospace',
    },
    animationLabel: {
        fontWeight: 'bold',
        marginBottom: '6px',
        color: theme.colors.text.primary,
        fontSize: '12px',
    },
};

export const TextComponentEditor: React.FC<TextComponentEditorProps> = ({
    component,
    onChange,
}) => {
    const style = component.style || {};
    const [customFonts, setCustomFonts] = useState<string[]>([]);
    const [isPositioningPopupOpen, setIsPositioningPopupOpen] = useState(false);

    useEffect(() => {
        const updateCustomFonts = () => {
            setCustomFonts(FONTS.getCustomFonts());
        };

        updateCustomFonts();
        window.addEventListener('storage', updateCustomFonts);
        return () => window.removeEventListener('storage', updateCustomFonts);
    }, []);

    const handleTextChange = (text: string) => {
        if (text && style.wordsPerLine && style.wordsPerLine > 0) {
            const cleanText = text.replace(/[\n\r]+/g, ' ').replace(/\s+/g, ' ').trim();
            const words = cleanText.split(' ');
            const lines = [];
            
            for (let i = 0; i < words.length; i += style.wordsPerLine) {
                const line = words.slice(i, i + style.wordsPerLine).join(' ');
                if (line) lines.push(line);
            }
            
            text = lines.join('\n');
        }

        onChange({
            ...component,
            text,
        });
    };

    const handleBlockStyleToggle = (value: string) => {
        console.log('Block style changed to:', value);
        
        let backgroundColor, textColor;
        if (value === 'white') {
            backgroundColor = '#FFFFFF';
            textColor = '#000000';
        } else if (value === 'black') {
            backgroundColor = '#000000';
            textColor = '#FFFFFF';
        } else {
            backgroundColor = undefined;
            textColor = '#FFFFFF';
        }

        console.log('Setting colors:', { backgroundColor, textColor });
        
        const newStyle = {
            ...style,
            blockStyle: { enabled: value !== 'disabled' },
            backgroundColor,
            color: textColor,
            textTransform: value !== 'disabled' ? 'uppercase' as const : 'none' as const,
            fontWeight: value !== 'disabled' ? 'bold' : 'normal',
            padding: value !== 'disabled' ? '20px 40px' : undefined,
            borderRadius: value !== 'disabled' ? '15px' : undefined,
            textAlign: value !== 'disabled' ? 'center' as const : (style.textAlign || 'center'),
        };
        
        console.log('New style:', newStyle);
        
        onChange({
            ...component,
            style: newStyle,
        });
    };

    const handlePositionChange = (position: { x: number; y: number }) => {
        onChange({
            ...component,
            style: {
                ...style,
                position,
            },
        });
    };

    return (
        <>
            {/* Basic Settings */}
            <div style={styles.grid}>
                <div>
                    <label style={styles.sectionTitle}>Duration (seconds)</label>
                    <input
                        type="number"
                        value={component.durationInFrames / 30}
                        onChange={(e) => onChange({
                            ...component,
                            durationInFrames: Math.max(1, parseFloat(e.target.value)) * 30,
                        })}
                        style={styles.input}
                        min="0.1"
                        step="0.1"
                    />
                </div>
                <div>
                    <label style={styles.sectionTitle}>Block Style</label>
                    <select
                        value={style.blockStyle?.enabled ? 
                            (style.backgroundColor === '#FFFFFF' ? 'white' : 'black') 
                            : 'disabled'}
                        onChange={(e) => handleBlockStyleToggle(e.target.value)}
                        style={styles.input}
                    >
                        <option value="disabled">Normal Text</option>
                        <option value="white">White Block with Black Text</option>
                        <option value="black">Black Block with White Text</option>
                    </select>
                </div>
            </div>

            {/* Content */}
            <div style={{ marginTop: theme.spacing.lg }}>
                <div style={{
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    marginBottom: theme.spacing.sm,
                }}>
                    <h3 style={styles.sectionTitle}>Content</h3>
                    <button style={{
                        backgroundColor: 'rgb(255, 75, 75)',
                        color: 'white',
                        border: 'none',
                        padding: '4px 8px',
                        borderRadius: '4px',
                        cursor: 'pointer',
                        fontSize: '13px',
                    }}>Delete</button>
                </div>
                <textarea
                    value={component.text}
                    onChange={(e) => handleTextChange(e.target.value)}
                    style={styles.textarea}
                    placeholder="Enter your text..."
                />
            </div>

            {/* Font Settings */}
            <div style={{ marginTop: theme.spacing.lg }}>
                <h3 style={styles.sectionTitle}>Font Settings</h3>
                <div style={styles.grid}>
                    <div>
                        <label style={styles.sectionTitle}>Font Family</label>
                        <select
                            value={style.fontFamily}
                            onChange={(e) => onChange({
                                ...component,
                                style: {
                                    ...style,
                                    fontFamily: e.target.value,
                                },
                            })}
                            style={styles.input}
                        >
                            <optgroup label="System Fonts">
                                {FONTS.system.map(font => (
                                    <option key={font} value={font}>{font}</option>
                                ))}
                            </optgroup>
                            {customFonts.length > 0 && (
                                <optgroup label="Custom Fonts">
                                    {customFonts.map(font => (
                                        <option key={font} value={font}>{font}</option>
                                    ))}
                                </optgroup>
                            )}
                        </select>
                    </div>
                    <div>
                        <label style={styles.sectionTitle}>Font Size (px)</label>
                        <input
                            type="number"
                            value={style.fontSize}
                            onChange={(e) => onChange({
                                ...component,
                                style: {
                                    ...style,
                                    fontSize: parseInt(e.target.value),
                                },
                            })}
                            style={styles.input}
                            min="12"
                            max="200"
                        />
                    </div>
                    <div>
                        <label style={styles.sectionTitle}>Font Weight</label>
                        <select
                            value={style.fontWeight}
                            onChange={(e) => onChange({
                                ...component,
                                style: {
                                    ...style,
                                    fontWeight: e.target.value,
                                },
                            })}
                            style={styles.input}
                        >
                            <option value="300">Light</option>
                            <option value="400">Regular</option>
                            <option value="500">Medium</option>
                            <option value="600">Semi Bold</option>
                            <option value="700">Bold</option>
                            <option value="800">Extra Bold</option>
                        </select>
                    </div>
                    <div>
                        <label style={styles.sectionTitle}>Line Height</label>
                        <select
                            value={style.lineHeight || '1.5'}
                            onChange={(e) => onChange({
                                ...component,
                                style: {
                                    ...style,
                                    lineHeight: e.target.value,
                                },
                            })}
                            style={styles.input}
                        >
                            <option value="1">Tight</option>
                            <option value="1.2">Compact</option>
                            <option value="1.5">Normal</option>
                            <option value="1.8">Relaxed</option>
                            <option value="2">Spacious</option>
                        </select>
                    </div>
                </div>
            </div>

            {/* Style Settings */}
            <div style={{ marginTop: theme.spacing.lg }}>
                <h3 style={styles.sectionTitle}>Style Settings</h3>
                <div style={styles.grid}>
                    <div>
                        <label style={styles.sectionTitle}>Text Color</label>
                        <div style={{ display: 'flex', gap: '8px' }}>
                            <input
                                type="color"
                                value={style.color || '#FFFFFF'}
                                onChange={(e) => onChange({
                                    ...component,
                                    style: {
                                        ...style,
                                        color: e.target.value,
                                    },
                                })}
                                style={{ ...styles.input, width: '50px', padding: '2px' }}
                            />
                            <input
                                type="text"
                                value={style.color || '#FFFFFF'}
                                onChange={(e) => onChange({
                                    ...component,
                                    style: {
                                        ...style,
                                        color: e.target.value,
                                    },
                                })}
                                style={{ ...styles.input, flex: 1 }}
                                placeholder="#FFFFFF"
                            />
                        </div>
                    </div>
                    <div>
                        <label style={styles.sectionTitle}>Text Alignment</label>
                        <select
                            value={style.textAlign || 'center'}
                            onChange={(e) => onChange({
                                ...component,
                                style: {
                                    ...style,
                                    textAlign: e.target.value as 'left' | 'center' | 'right' | 'justify',
                                },
                            })}
                            style={styles.input}
                        >
                            <option value="left">Left</option>
                            <option value="center">Center</option>
                            <option value="right">Right</option>
                            <option value="justify">Justify</option>
                        </select>
                    </div>
                </div>
            </div>

            {/* Animation Settings */}
            <div style={{ marginTop: theme.spacing.lg }}>
                <h3 style={styles.sectionTitle}>Animation Settings</h3>
                <div style={styles.grid}>
                    <div>
                        <label style={styles.sectionTitle}>Entrance Animation</label>
                        <select
                            value={style.animation?.in?.type || 'none'}
                            onChange={(e) => onChange({
                                ...component,
                                style: {
                                    ...style,
                                    animation: {
                                        ...style.animation,
                                        in: {
                                            ...style.animation?.in,
                                            type: e.target.value,
                                            startFrame: style.animation?.in?.startFrame || 0,
                                            endFrame: style.animation?.in?.endFrame || 30,
                                        },
                                    },
                                },
                            })}
                            style={styles.input}
                        >
                            <option value="none">None</option>
                            <option value="slide-left">Slide In from Left</option>
                            <option value="slide-right">Slide In from Right</option>
                        </select>
                        {style.animation?.in?.type && style.animation.in.type !== 'none' && (
                            <div style={styles.animationTimingGrid}>
                                <div>
                                    <label style={styles.animationLabel}>Start Frame</label>
                                    <input
                                        type="number"
                                        value={style.animation?.in?.startFrame ?? 0}
                                        onChange={(e) => {
                                            const newValue = parseInt(e.target.value);
                                            if (!isNaN(newValue)) {
                                                console.log('Updating in animation start frame to:', newValue);
                                                const updatedStyle = {
                                                    ...style,
                                                    animation: {
                                                        ...style.animation,
                                                        in: {
                                                            ...style.animation?.in,
                                                            startFrame: newValue,
                                                        },
                                                    },
                                                };
                                                console.log('Updated style:', updatedStyle);
                                                onChange({
                                                    ...component,
                                                    style: updatedStyle,
                                                });
                                            }
                                        }}
                                        style={styles.animationInput}
                                        min="0"
                                    />
                                </div>
                                <div>
                                    <label style={styles.animationLabel}>End Frame</label>
                                    <input
                                        type="number"
                                        value={style.animation?.in?.endFrame ?? 30}
                                        onChange={(e) => {
                                            const newValue = parseInt(e.target.value);
                                            if (!isNaN(newValue)) {
                                                console.log('Updating in animation end frame to:', newValue);
                                                const updatedStyle = {
                                                    ...style,
                                                    animation: {
                                                        ...style.animation,
                                                        in: {
                                                            ...style.animation?.in,
                                                            endFrame: newValue,
                                                        },
                                                    },
                                                };
                                                console.log('Updated style:', updatedStyle);
                                                onChange({
                                                    ...component,
                                                    style: updatedStyle,
                                                });
                                            }
                                        }}
                                        style={styles.animationInput}
                                        min={style.animation?.in?.startFrame ?? 0}
                                    />
                                </div>
                            </div>
                        )}
                    </div>
                    <div>
                        <label style={styles.sectionTitle}>Exit Animation</label>
                        <select
                            value={style.animation?.out?.type || 'none'}
                            onChange={(e) => {
                                const updatedStyle = {
                                    ...style,
                                    animation: {
                                        ...style.animation,
                                        out: {
                                            ...style.animation?.out,
                                            type: e.target.value,
                                            startFrame: style.animation?.out?.startFrame ?? 30,
                                            endFrame: style.animation?.out?.endFrame ?? 0,
                                        },
                                    },
                                };
                                console.log('Updated exit animation style:', updatedStyle);
                                onChange({
                                    ...component,
                                    style: updatedStyle,
                                });
                            }}
                            style={styles.input}
                        >
                            <option value="none">None</option>
                            <option value="slide-left">Slide Out to Left</option>
                            <option value="slide-right">Slide Out to Right</option>
                        </select>
                        {style.animation?.out?.type && style.animation.out.type !== 'none' && (
                            <div style={styles.animationTimingGrid}>
                                <div>
                                    <label style={styles.animationLabel}>Start Frame (from end)</label>
                                    <input
                                        type="number"
                                        value={style.animation?.out?.startFrame ?? 30}
                                        onChange={(e) => {
                                            const newValue = parseInt(e.target.value);
                                            if (!isNaN(newValue)) {
                                                console.log('Updating out animation start frame to:', newValue);
                                                const updatedStyle = {
                                                    ...style,
                                                    animation: {
                                                        ...style.animation,
                                                        out: {
                                                            ...style.animation?.out,
                                                            startFrame: newValue,
                                                        },
                                                    },
                                                };
                                                console.log('Updated style:', updatedStyle);
                                                onChange({
                                                    ...component,
                                                    style: updatedStyle,
                                                });
                                            }
                                        }}
                                        style={styles.animationInput}
                                        min={style.animation?.out?.endFrame ?? 0}
                                    />
                                </div>
                                <div>
                                    <label style={styles.animationLabel}>End Frame (from end)</label>
                                    <input
                                        type="number"
                                        value={style.animation?.out?.endFrame ?? 0}
                                        onChange={(e) => {
                                            const newValue = parseInt(e.target.value);
                                            if (!isNaN(newValue)) {
                                                console.log('Updating out animation end frame to:', newValue);
                                                const updatedStyle = {
                                                    ...style,
                                                    animation: {
                                                        ...style.animation,
                                                        out: {
                                                            ...style.animation?.out,
                                                            endFrame: newValue,
                                                        },
                                                    },
                                                };
                                                console.log('Updated style:', updatedStyle);
                                                onChange({
                                                    ...component,
                                                    style: updatedStyle,
                                                });
                                            }
                                        }}
                                        style={styles.animationInput}
                                        min="0"
                                    />
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            </div>

            {/* Position */}
            <div style={{ marginTop: theme.spacing.lg }}>
                <div style={{
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    marginBottom: theme.spacing.sm,
                }}>
                    <h3 style={styles.sectionTitle}>Position</h3>
                    <button
                        onClick={() => setIsPositioningPopupOpen(true)}
                        style={{
                            backgroundColor: theme.colors.primary,
                            color: theme.colors.text.primary,
                            border: 'none',
                            borderRadius: '4px',
                            padding: '4px 8px',
                            cursor: 'pointer',
                            fontSize: '13px',
                        }}
                    >
                        Open Large Preview
                    </button>
                </div>
                <div style={{
                    width: '200px',
                    height: '356px',
                    backgroundColor: '#1a1a1a',
                    position: 'relative',
                    borderRadius: theme.borderRadius.sm,
                    overflow: 'hidden',
                    cursor: 'pointer',
                }}
                onClick={(e) => {
                    const rect = e.currentTarget.getBoundingClientRect();
                    const x = (e.clientX - rect.left) * 5.4;
                    const y = (e.clientY - rect.top) * 5.4;
                    handlePositionChange({ x, y });
                }}>
                    {/* Grid lines */}
                    <div style={{
                        position: 'absolute',
                        inset: 0,
                        backgroundImage: `
                            linear-gradient(to right, #333 1px, transparent 1px),
                            linear-gradient(to bottom, #333 1px, transparent 1px)
                        `,
                        backgroundSize: '20px 20px',
                        opacity: 0.5,
                        pointerEvents: 'none',
                    }} />

                    {/* Center dot */}
                    <div style={{
                        position: 'absolute',
                        left: (style.position?.x || 0) / 5.4,
                        top: (style.position?.y || 0) / 5.4,
                        width: 6,
                        height: 6,
                        backgroundColor: theme.colors.primary,
                        borderRadius: '50%',
                        transform: 'translate(-50%, -50%)',
                        pointerEvents: 'none',
                        boxShadow: '0 0 0 2px rgba(255, 255, 255, 0.3)',
                    }} />
                </div>
            </div>

            {/* Positioning Popup */}
            {isPositioningPopupOpen && (
                <PositioningScreen
                    component={component}
                    onPositionChange={handlePositionChange}
                    onClose={() => setIsPositioningPopupOpen(false)}
                />
            )}
        </>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\Timeline.tsx ---

import React, { useState, useRef, useEffect } from 'react';
import { Script, BaseScriptComponent, ComponentType } from '../../types/script';
import { theme } from '../../styles/theme';
import { createComponent } from '../../utils/componentFactory';

interface TimelineProps {
    script: Script;
    onReorder: (components: BaseScriptComponent[]) => void;
    onSelect: (id: string) => void;
    selectedId?: string;
    onDelete: (id: string) => void;
    zoom?: number;
}

const TRACK_HEIGHT = 40;
const PIXELS_PER_SECOND = 100;
const FRAMES_PER_SECOND = 30;
const NUM_TRACKS = 5;

export const Timeline: React.FC<TimelineProps> = ({
    script,
    onReorder,
    onSelect,
    selectedId,
    onDelete,
    zoom = 1,
}) => {
    const [draggingId, setDraggingId] = useState<string | null>(null);
    const [dragOffset, setDragOffset] = useState(0);
    const containerRef = useRef<HTMLDivElement>(null);

    // Calculate timeline width based on the maximum end time of all components
    const timelineWidth = Math.max(
        ...script.components.map(comp => {
            const start = comp.startFrame || 0;
            const duration = comp.durationInFrames || 150;
            return (start + duration) / FRAMES_PER_SECOND * PIXELS_PER_SECOND * zoom;
        }),
        PIXELS_PER_SECOND * 10 * zoom // Minimum width of 10 seconds
    );

    useEffect(() => {
        // Scroll to show the rightmost component if it's out of view
        if (containerRef.current) {
            const maxEndTime = Math.max(...script.components.map(comp => {
                const start = comp.startFrame || 0;
                const duration = comp.durationInFrames || 150;
                return start + duration;
            }));
            const scrollPosition = (maxEndTime / FRAMES_PER_SECOND) * PIXELS_PER_SECOND * zoom;
            const clientWidth = containerRef.current.clientWidth;

            if (scrollPosition > clientWidth) {
                containerRef.current.scrollLeft = scrollPosition - clientWidth + 100;
            }
        }
    }, [script.components, zoom]);

    const handleDragStart = (e: React.DragEvent, component: BaseScriptComponent) => {
        e.stopPropagation();
        const rect = e.currentTarget.getBoundingClientRect();
        const offsetX = e.clientX - rect.left;
        setDragOffset(Math.round((offsetX / (PIXELS_PER_SECOND * zoom)) * FRAMES_PER_SECOND));
        setDraggingId(component.id);
        e.dataTransfer.effectAllowed = 'move';
    };

    const handleDrop = (e: React.DragEvent, trackIndex: number) => {
        e.preventDefault();
        e.stopPropagation();
        
        const rect = containerRef.current?.getBoundingClientRect();
        if (!rect) return;

        const scrollLeft = containerRef.current?.scrollLeft || 0;
        const x = e.clientX - rect.left + scrollLeft;
        const startFrame = Math.round((x / (PIXELS_PER_SECOND * zoom)) * FRAMES_PER_SECOND);

        if (draggingId) {
            // Update existing component position
            const updatedComponents = script.components.map(comp => {
                if (comp.id === draggingId) {
                    const newStartFrame = Math.max(0, startFrame - dragOffset);
                    const newComp = {
                        ...comp,
                        startFrame: newStartFrame,
                        track: trackIndex,
                    };
                    
                    // Only handle style for text components
                    if (comp.type === 'text' && 'style' in comp) {
                        return {
                            ...newComp,
                            style: {
                                ...comp.style,
                                position: comp.style.position
                            }
                        };
                    }
                    
                    return newComp;
                }
                return comp;
            });
            onReorder(updatedComponents);
        } else {
            // Handle new component from palette
            const componentType = e.dataTransfer.getData('componentType') as ComponentType;
            if (componentType) {
                const newComponent = createComponent(
                    componentType,
                    script.settings.defaultTextStyle,
                    script.settings.defaultCaptionStyle
                );
                newComponent.startFrame = Math.max(0, startFrame);
                newComponent.track = trackIndex;
                onReorder([...script.components, newComponent]);
            }
        }
        setDraggingId(null);
        setDragOffset(0);
    };

    const handleDrag = (e: React.DragEvent, trackIndex: number) => {
        e.preventDefault();
        e.stopPropagation();
        
        if (!draggingId || !containerRef.current || !e.clientX) return;

        const rect = containerRef.current.getBoundingClientRect();
        const scrollLeft = containerRef.current.scrollLeft;
        const x = e.clientX - rect.left + scrollLeft;
        const newStartFrame = Math.max(0, Math.round((x / (PIXELS_PER_SECOND * zoom)) * FRAMES_PER_SECOND) - dragOffset);

        // Auto-scroll when dragging near the right edge
        const SCROLL_THRESHOLD = 100; // pixels from the right edge
        const SCROLL_SPEED = 10;
        
        if (e.clientX > rect.right - SCROLL_THRESHOLD) {
            containerRef.current.scrollLeft += SCROLL_SPEED;
        }

        const updatedComponents = script.components.map(comp => {
            if (comp.id === draggingId) {
                return {
                    ...comp,
                    startFrame: newStartFrame,
                    track: trackIndex
                };
            }
            return comp;
        });

        onReorder(updatedComponents);
    };

    // Calculate timeline width including extra space for dragging
    const timelineWidthIncludingExtraSpace = Math.max(
        containerRef.current?.clientWidth || 0,
        script.components.reduce((max, comp) => {
            const endFrame = comp.startFrame + comp.durationInFrames;
            return Math.max(max, endFrame);
        }, 0) * (PIXELS_PER_SECOND * zoom) / FRAMES_PER_SECOND + 500 // Add extra space
    );

    return (
        <div 
            ref={containerRef}
            style={{
                overflow: 'auto',
                backgroundColor: theme.colors.background.tertiary,
                borderRadius: theme.borderRadius.sm,
            }}
        >
            <div style={{
                width: `${timelineWidthIncludingExtraSpace}px`,
                minHeight: TRACK_HEIGHT * NUM_TRACKS,
                position: 'relative',
            }}>
                {/* Time markers */}
                <div style={{
                    height: '20px',
                    borderBottom: `1px solid ${theme.colors.border}`,
                    position: 'relative',
                }}>
                    {Array.from({ length: Math.ceil(timelineWidthIncludingExtraSpace / PIXELS_PER_SECOND) }).map((_, i) => (
                        <div
                            key={i}
                            style={{
                                position: 'absolute',
                                left: `${i * PIXELS_PER_SECOND}px`,
                                height: '100%',
                                borderLeft: `1px solid ${theme.colors.border}`,
                            }}
                        >
                            <span style={{
                                position: 'absolute',
                                top: '2px',
                                left: '4px',
                                fontSize: '10px',
                                color: theme.colors.text.secondary,
                            }}>
                                {i}s
                            </span>
                        </div>
                    ))}
                </div>

                {/* Tracks */}
                {Array.from({ length: NUM_TRACKS }).map((_, trackIndex) => (
                    <div
                        key={trackIndex}
                        style={{
                            height: TRACK_HEIGHT,
                            borderBottom: `1px solid ${theme.colors.border}`,
                            position: 'relative',
                            backgroundColor: theme.colors.background.secondary,
                        }}
                        onDragOver={(e) => {
                            e.preventDefault();
                            handleDrag(e, trackIndex);
                        }}
                        onDrop={(e) => handleDrop(e, trackIndex)}
                    >
                        {script.components
                            .filter(comp => (comp.track || 0) === trackIndex)
                            .map(component => (
                                <div
                                    key={component.id}
                                    draggable
                                    onClick={() => onSelect(component.id)}
                                    onDragStart={(e) => handleDragStart(e, component as BaseScriptComponent)}
                                    onDragEnd={() => setDraggingId(null)}
                                    style={{
                                        position: 'absolute',
                                        left: `${((component.startFrame || 0) / FRAMES_PER_SECOND) * PIXELS_PER_SECOND * zoom}px`,
                                        width: `${((component.durationInFrames || 150) / FRAMES_PER_SECOND) * PIXELS_PER_SECOND * zoom}px`,
                                        height: TRACK_HEIGHT - 2,
                                        backgroundColor: selectedId === component.id ? theme.colors.primary : theme.colors.secondary,
                                        borderRadius: theme.borderRadius.sm,
                                        cursor: 'grab',
                                        display: 'flex',
                                        alignItems: 'center',
                                        padding: '0 8px',
                                        fontSize: '12px',
                                        color: 'white',
                                        whiteSpace: 'nowrap',
                                        overflow: 'hidden',
                                        textOverflow: 'ellipsis',
                                        transition: theme.transitions.fast,
                                    }}
                                >
                                    {component.type}
                                </div>
                        ))}
                    </div>
                ))}
            </div>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\TitleComponentEditor.tsx ---

import React from 'react';
import { TitleComponent } from '../../types/script';
import { TextField, Grid } from '@mui/material';

interface TitleComponentEditorProps {
    component: TitleComponent;
    onChange: (component: TitleComponent) => void;
}

export const TitleComponentEditor: React.FC<TitleComponentEditorProps> = ({ component, onChange }) => {
    return (
        <Grid container spacing={2}>
            <Grid item xs={12}>
                <TextField
                    fullWidth
                    label="Title Text"
                    value={component.text}
                    onChange={(e) => onChange({
                        ...component,
                        text: e.target.value
                    })}
                />
            </Grid>
            <Grid item xs={12}>
                <TextField
                    fullWidth
                    label="Subtitle"
                    value={component.subtitle || ''}
                    onChange={(e) => onChange({
                        ...component,
                        subtitle: e.target.value
                    })}
                />
            </Grid>
        </Grid>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\VideoComponentEditor.tsx ---

import React from 'react';
import { VideoComponent, AnimationOptions } from '../../types/script';
import { theme } from '../../styles/theme';

interface VideoComponentEditorProps {
    component: VideoComponent;
    onChange: (updated: VideoComponent) => void;
}

export const VideoComponentEditor: React.FC<VideoComponentEditorProps> = ({
    component,
    onChange,
}) => {
    const handleStyleChange = (updated: Partial<VideoComponent['style']>) => {
        onChange({
            ...component,
            style: {
                ...component.style,
                ...updated
            }
        });
    };

    const handleAnimationChange = (updates: Partial<AnimationOptions>) => {
        const currentAnimation = component.style?.animation || {
            type: 'none',
            direction: 'in',
            easing: 'easeInOut',
            duration: 30,
            delay: 0,
            stagger: 0
        };
        handleStyleChange({
            animation: {
                ...currentAnimation,
                ...updates,
            }
        });
    };

    const handleChromakeyChange = (updates: Partial<NonNullable<VideoComponent['style']>['chromakey']>) => {
        const currentChromakey = component.style?.chromakey || {
            enabled: false,
            color: '#00ff00',
            similarity: 0.4,
            smoothness: 0.1
        };
        handleStyleChange({
            chromakey: {
                ...currentChromakey,
                ...updates,
            }
        });
    };

    return (
        <div style={styles.container}>
            {/* Video URL */}
            <div style={styles.section}>
                <label style={styles.label}>Video URL:</label>
                <input
                    type="text"
                    value={component.videoUrl}
                    onChange={(e) => {
                        onChange({
                            ...component,
                            videoUrl: e.target.value
                        });
                    }}
                    style={styles.input}
                    placeholder="Enter video URL (supports video files and GIFs)..."
                />
            </div>

            {/* Size and Position */}
            <div style={styles.section}>
                <h4 style={styles.sectionTitle}>Size & Position</h4>
                <div style={styles.settingsGrid}>
                    <div>
                        <label style={styles.label}>Width (%):</label>
                        <input
                            type="number"
                            min="1"
                            max="100"
                            value={component.style?.width || 100}
                            onChange={(e) => handleStyleChange({ width: Number(e.target.value) })}
                            style={styles.input}
                        />
                    </div>
                    <div>
                        <label style={styles.label}>Height (%):</label>
                        <input
                            type="number"
                            min="1"
                            max="100"
                            value={component.style?.height || 100}
                            onChange={(e) => handleStyleChange({ height: Number(e.target.value) })}
                            style={styles.input}
                        />
                    </div>
                </div>

                <div style={styles.settingsGrid}>
                    <div>
                        <label style={styles.label}>X Position (%):</label>
                        <input
                            type="range"
                            min="-100"
                            max="100"
                            value={component.style?.position?.x || 0}
                            onChange={(e) => handleStyleChange({
                                position: {
                                    x: Number(e.target.value),
                                    y: component.style?.position?.y || 0
                                }
                            })}
                            style={styles.input}
                        />
                    </div>
                    <div>
                        <label style={styles.label}>Y Position (%):</label>
                        <input
                            type="range"
                            min="-100"
                            max="100"
                            value={component.style?.position?.y || 0}
                            onChange={(e) => handleStyleChange({
                                position: {
                                    x: component.style?.position?.x || 0,
                                    y: Number(e.target.value)
                                }
                            })}
                            style={styles.input}
                        />
                    </div>
                </div>
            </div>

            {/* Transform */}
            <div style={styles.section}>
                <h4 style={styles.sectionTitle}>Transform</h4>
                <div style={styles.settingsGrid}>
                    <div>
                        <label style={styles.label}>Scale:</label>
                        <input
                            type="number"
                            min="0.1"
                            max="5"
                            step="0.1"
                            value={component.style?.scale || 1}
                            onChange={(e) => handleStyleChange({ scale: Number(e.target.value) })}
                            style={styles.input}
                        />
                    </div>
                    <div>
                        <label style={styles.label}>Rotation (deg):</label>
                        <input
                            type="number"
                            min="-360"
                            max="360"
                            value={component.style?.rotation || 0}
                            onChange={(e) => handleStyleChange({ rotation: Number(e.target.value) })}
                            style={styles.input}
                        />
                    </div>
                    <div>
                        <label style={styles.label}>Opacity:</label>
                        <input
                            type="range"
                            min="0"
                            max="1"
                            step="0.1"
                            value={component.style?.opacity || 1}
                            onChange={(e) => handleStyleChange({ opacity: Number(e.target.value) })}
                            style={styles.input}
                        />
                    </div>
                </div>
            </div>

            {/* Playback Settings */}
            <div style={styles.section}>
                <h4 style={styles.sectionTitle}>Playback Settings</h4>
                <div style={styles.settingsGrid}>
                    <div>
                        <label style={styles.label}>Volume:</label>
                        <input
                            type="range"
                            min="0"
                            max="1"
                            step="0.1"
                            value={component.style?.volume || 1}
                            onChange={(e) => handleStyleChange({ volume: Number(e.target.value) })}
                            style={styles.input}
                        />
                    </div>
                    <div>
                        <label style={styles.label}>Playback Rate:</label>
                        <input
                            type="number"
                            min="0.5"
                            max="2"
                            step="0.1"
                            value={component.style?.playbackRate || 1}
                            onChange={(e) => handleStyleChange({ playbackRate: Number(e.target.value) })}
                            style={styles.input}
                        />
                    </div>
                </div>
                <div style={styles.row}>
                    <label style={styles.checkboxLabel}>
                        <input
                            type="checkbox"
                            checked={component.style?.loop || false}
                            onChange={(e) => handleStyleChange({ loop: e.target.checked })}
                        />
                        Loop Video
                    </label>
                    <label style={styles.checkboxLabel}>
                        <input
                            type="checkbox"
                            checked={component.style?.muted || false}
                            onChange={(e) => handleStyleChange({ muted: e.target.checked })}
                        />
                        Mute Audio
                    </label>
                </div>
            </div>

            {/* Animation Controls */}
            <div style={styles.section}>
                <h4 style={styles.sectionTitle}>Animation</h4>
                <div style={styles.row}>
                    <select
                        value={component.style?.animation?.type ?? 'none'}
                        onChange={(e) => handleAnimationChange({ type: e.target.value as AnimationOptions['type'] })}
                        style={styles.input}
                    >
                        <option value="none">None</option>
                        <option value="fade">Fade</option>
                        <option value="scale">Scale</option>
                        <option value="rotate">Rotate</option>
                        <option value="slide">Slide</option>
                    </select>
                </div>
                {component.style?.animation?.type !== 'none' && (
                    <>
                        <div style={styles.row}>
                            <select
                                value={component.style?.animation?.direction ?? 'in'}
                                onChange={(e) => handleAnimationChange({ direction: e.target.value as AnimationOptions['direction'] })}
                                style={styles.input}
                            >
                                <option value="in">In</option>
                                <option value="out">Out</option>
                            </select>
                            <select
                                value={component.style?.animation?.easing ?? 'easeInOut'}
                                onChange={(e) => handleAnimationChange({ easing: e.target.value as AnimationOptions['easing'] })}
                                style={styles.input}
                            >
                                <option value="linear">Linear</option>
                                <option value="easeIn">Ease In</option>
                                <option value="easeOut">Ease Out</option>
                                <option value="easeInOut">Ease In Out</option>
                            </select>
                        </div>
                        <div style={styles.row}>
                            <input
                                type="number"
                                value={component.style?.animation?.duration ?? 30}
                                onChange={(e) => handleAnimationChange({ duration: Number(e.target.value) })}
                                placeholder="Duration (frames)"
                                min="1"
                                style={styles.input}
                            />
                            <input
                                type="number"
                                value={component.style?.animation?.delay ?? 0}
                                onChange={(e) => handleAnimationChange({ delay: Number(e.target.value) })}
                                placeholder="Delay (frames)"
                                min="0"
                                style={styles.input}
                            />
                            <input
                                type="number"
                                value={component.style?.animation?.stagger ?? 0}
                                onChange={(e) => handleAnimationChange({ stagger: Number(e.target.value) })}
                                placeholder="Stagger (frames)"
                                min="0"
                                style={styles.input}
                            />
                        </div>
                    </>
                )}
            </div>

            {/* Chromakey Settings */}
            <div style={styles.section}>
                <h4 style={styles.sectionTitle}>Chromakey</h4>
                <div style={styles.row}>
                    <label style={styles.checkboxLabel}>
                        <input
                            type="checkbox"
                            checked={component.style?.chromakey?.enabled || false}
                            onChange={(e) => handleChromakeyChange({ enabled: e.target.checked })}
                        />
                        Enable Chromakey
                    </label>
                </div>
                {component.style?.chromakey?.enabled && (
                    <>
                        <div style={styles.row}>
                            <div style={{ flex: 1 }}>
                                <label style={styles.label}>Color to Remove:</label>
                                <input
                                    type="color"
                                    value={component.style.chromakey.color || '#00ff00'}
                                    onChange={(e) => handleChromakeyChange({ color: e.target.value })}
                                    style={styles.input}
                                />
                            </div>
                        </div>
                        <div style={styles.settingsGrid}>
                            <div>
                                <label style={styles.label}>Color Similarity:</label>
                                <input
                                    type="range"
                                    min="0"
                                    max="1"
                                    step="0.01"
                                    value={component.style.chromakey.similarity || 0.4}
                                    onChange={(e) => handleChromakeyChange({ similarity: Number(e.target.value) })}
                                    style={styles.input}
                                />
                            </div>
                            <div>
                                <label style={styles.label}>Edge Smoothness:</label>
                                <input
                                    type="range"
                                    min="0"
                                    max="1"
                                    step="0.01"
                                    value={component.style.chromakey.smoothness || 0.1}
                                    onChange={(e) => handleChromakeyChange({ smoothness: Number(e.target.value) })}
                                    style={styles.input}
                                />
                            </div>
                        </div>
                    </>
                )}
            </div>
        </div>
    );
};

const styles = {
    container: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.md,
        height: '100%',
        backgroundColor: 'transparent',
    },
    section: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.sm,
        padding: theme.spacing.md,
        backgroundColor: theme.colors.background.secondary,
        borderRadius: theme.borderRadius.md,
        border: `1px solid ${theme.colors.border}`,
    },
    sectionTitle: {
        margin: '0 0 8px 0',
        color: theme.colors.text.primary,
        fontSize: '1rem',
        fontWeight: 600,
    },
    label: {
        fontSize: '0.9rem',
        fontWeight: 500,
        color: theme.colors.text.primary,
    },
    input: {
        padding: '0.5rem',
        borderRadius: theme.borderRadius.sm,
        border: `1px solid ${theme.colors.border}`,
        backgroundColor: theme.colors.background.tertiary,
        color: theme.colors.text.primary,
        width: '100%',
        minWidth: 0,
    },
    settingsGrid: {
        display: 'grid',
        gridTemplateColumns: '1fr 1fr',
        gap: theme.spacing.sm,
    },
    row: {
        display: 'flex',
        gap: theme.spacing.sm,
        alignItems: 'center',
        flexWrap: 'wrap' as const,
    },
    checkboxLabel: {
        display: 'flex',
        alignItems: 'center',
        gap: theme.spacing.sm,
        fontSize: '0.9rem',
        fontWeight: 500,
        color: theme.colors.text.primary,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\VoiceComponent.tsx ---

import React, { useState } from 'react';
import { VoiceComponent } from '../../types/script';
import { generateSpeech } from '../../services/elevenLabs';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';
import { DraggablePreview } from './DraggablePreview';

interface VoiceComponentEditorProps {
    component: VoiceComponent;
    onChange: (updated: VoiceComponent) => void;
}

type VoiceStatus = 'none' | 'generating' | 'success' | 'error';

const styles = {
    container: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: '20px',
    },
    section: {
        backgroundColor: theme.colors.background.secondary,
        padding: theme.spacing.lg,
        borderRadius: theme.borderRadius.md,
        border: `1px solid ${theme.colors.border}`,
    },
    label: {
        ...commonStyles.label,
        color: theme.colors.text.primary,
        display: 'block',
        marginBottom: theme.spacing.xs,
    },
    input: {
        ...commonStyles.input,
        backgroundColor: theme.colors.background.tertiary,
        border: `1px solid ${theme.colors.border}`,
        color: theme.colors.text.primary,
        padding: theme.spacing.sm,
        borderRadius: theme.borderRadius.sm,
        width: '100%',
    },
    button: {
        ...commonStyles.button.primary,
        display: 'flex',
        alignItems: 'center',
        gap: theme.spacing.sm,
        padding: `${theme.spacing.sm} ${theme.spacing.md}`,
    },
    grid: {
        display: 'grid',
        gridTemplateColumns: '1fr 1fr',
        gap: '20px',
    },
};

export const VoiceComponentEditor: React.FC<VoiceComponentEditorProps> = ({
    component,
    onChange,
}) => {
    const [voiceStatus, setVoiceStatus] = useState<VoiceStatus>(
        component.audioUrl ? 'success' : 'none'
    );
    const [errorMessage, setErrorMessage] = useState<string>('');
    const style = component.style || {};

    const handleVoiceGeneration = async () => {
        try {
            if (!component.text) {
                setErrorMessage('Please enter text for voice generation');
                return;
            }

            setVoiceStatus('generating');
            setErrorMessage('');
            
            const { audioUrl, wordTimings } = await generateSpeech({
                text: component.text,
                voiceId: component.voiceSettings?.voiceId || 'GhJYgP4Lrji0pwS3kQwv',
                settings: {
                    stability: component.voiceSettings?.stability || 0.75,
                    similarity_boost: component.voiceSettings?.similarity_boost || 0.75,
                },
            });

            onChange({
                ...component,
                audioUrl,
                wordTimings,
            });
            setVoiceStatus('success');
        } catch (error) {
            console.error('Voice generation failed:', error);
            setVoiceStatus('error');
            setErrorMessage(error instanceof Error ? error.message : 'Voice generation failed');
        }
    };

    const getStatusColor = () => {
        switch (voiceStatus) {
            case 'generating': return '#ffd700';
            case 'success': return '#4caf50';
            case 'error': return '#f44336';
            default: return '#007bff';
        }
    };

    return (
        <div style={styles.container}>
            {/* Voice Generation Section */}
            <div style={styles.section}>
                <h4 style={{ marginTop: 0 }}>Voice Generation</h4>
                <div style={{ marginBottom: theme.spacing.md }}>
                    <label style={styles.label}>Voice Text:</label>
                    <textarea
                        value={component.text}
                        onChange={(e) => onChange({
                            ...component,
                            text: e.target.value,
                        })}
                        style={{
                            ...styles.input,
                            minHeight: '100px',
                        }}
                        placeholder="Enter text for voice generation..."
                    />
                </div>

                <div style={styles.grid}>
                    <div>
                        <label style={styles.label}>Voice:</label>
                        <select
                            value={component.voiceSettings?.voiceId}
                            onChange={(e) => onChange({
                                ...component,
                                voiceSettings: {
                                    ...component.voiceSettings,
                                    voiceId: e.target.value,
                                },
                            })}
                            style={styles.input}
                        >
                            <option value="GhJYgP4Lrji0pwS3kQwv">Josh (Default)</option>
                            <option value="21m00Tcm4TlvDq8ikWAM">Rachel</option>
                            <option value="AZnzlk1XvdvUeBnXmlld">Domi</option>
                            <option value="EXAVITQu4vr4xnSDxMaL">Bella</option>
                            <option value="MF3mGyEYCl7XYWbV9V6O">Elli</option>
                        </select>
                    </div>

                    <div>
                        <label style={styles.label}>Stability:</label>
                        <input
                            type="range"
                            min="0"
                            max="100"
                            value={((component.voiceSettings?.stability || 0.75) * 100)}
                            onChange={(e) => onChange({
                                ...component,
                                voiceSettings: {
                                    ...component.voiceSettings,
                                    stability: parseInt(e.target.value) / 100,
                                },
                            })}
                            style={styles.input}
                        />
                    </div>

                    <div>
                        <label style={styles.label}>Similarity Boost:</label>
                        <input
                            type="range"
                            min="0"
                            max="100"
                            value={((component.voiceSettings?.similarity_boost || 0.75) * 100)}
                            onChange={(e) => onChange({
                                ...component,
                                voiceSettings: {
                                    ...component.voiceSettings,
                                    similarity_boost: parseInt(e.target.value) / 100,
                                },
                            })}
                            style={styles.input}
                        />
                    </div>
                </div>

                <div style={{ marginTop: theme.spacing.md }}>
                    <button
                        onClick={handleVoiceGeneration}
                        disabled={voiceStatus === 'generating'}
                        style={{
                            ...styles.button,
                            backgroundColor: getStatusColor(),
                        }}
                    >
                        {voiceStatus === 'generating' && (
                            <div style={{
                                width: '16px',
                                height: '16px',
                                border: '2px solid white',
                                borderTop: '2px solid transparent',
                                borderRadius: '50%',
                                animation: 'spin 1s linear infinite',
                            }}>
                                <style>
                                    {`
                                        @keyframes spin {
                                            0% { transform: rotate(0deg); }
                                            100% { transform: rotate(360deg); }
                                        }
                                    `}
                                </style>
                            </div>
                        )}
                        {voiceStatus === 'generating' ? 'Generating...' : 
                         voiceStatus === 'success' ? 'Regenerate Voice' : 
                         voiceStatus === 'error' ? 'Try Again' : 
                         'Generate Voice'}
                    </button>
                    {voiceStatus === 'success' && (
                        <span style={{ color: '#4caf50', marginLeft: '10px' }}>‚úì Voice generated successfully</span>
                    )}
                    {voiceStatus === 'error' && (
                        <span style={{ color: '#f44336', marginLeft: '10px' }}>‚ö†Ô∏è {errorMessage}</span>
                    )}
                </div>

                {/* Audio Preview */}
                {component.audioUrl && (
                    <div style={{ marginTop: theme.spacing.md }}>
                        <label style={styles.label}>Preview Audio:</label>
                        <audio
                            controls
                            src={component.audioUrl}
                            style={{ width: '100%' }}
                        />
                    </div>
                )}
            </div>

            {/* Caption Settings */}
            <div style={styles.section}>
                <div style={{ 
                    display: 'flex', 
                    alignItems: 'center', 
                    gap: theme.spacing.md,
                    marginBottom: theme.spacing.md 
                }}>
                    <h4 style={{ margin: 0 }}>Caption Settings</h4>
                    <label style={{
                        display: 'flex',
                        alignItems: 'center',
                        gap: theme.spacing.sm,
                    }}>
                        <input
                            type="checkbox"
                            checked={component.showCaptions}
                            onChange={(e) => onChange({
                                ...component,
                                showCaptions: e.target.checked,
                            })}
                        />
                        Show Captions
                    </label>
                </div>

                {component.showCaptions && (
                    <>
                        {/* Text Styling */}
                        <div style={styles.grid}>
                            <div>
                                <label style={styles.label}>Font Size:</label>
                                <input
                                    type="number"
                                    value={style.fontSize || 24}
                                    onChange={(e) => onChange({
                                        ...component,
                                        style: {
                                            ...style,
                                            fontSize: parseInt(e.target.value),
                                        },
                                    })}
                                    style={styles.input}
                                    min="12"
                                    max="72"
                                />
                            </div>

                            <div>
                                <label style={styles.label}>Font Family:</label>
                                <select
                                    value={style.fontFamily || 'Arial'}
                                    onChange={(e) => onChange({
                                        ...component,
                                        style: {
                                            ...style,
                                            fontFamily: e.target.value,
                                        },
                                    })}
                                    style={styles.input}
                                >
                                    <option value="Arial">Arial</option>
                                    <option value="Times New Roman">Times New Roman</option>
                                    <option value="Helvetica">Helvetica</option>
                                    <option value="Georgia">Georgia</option>
                                    <option value="Verdana">Verdana</option>
                                </select>
                            </div>

                            <div>
                                <label style={styles.label}>Text Color:</label>
                                <input
                                    type="color"
                                    value={style.color || '#ffffff'}
                                    onChange={(e) => onChange({
                                        ...component,
                                        style: {
                                            ...style,
                                            color: e.target.value,
                                        },
                                    })}
                                    style={styles.input}
                                />
                            </div>

                            <div>
                                <label style={styles.label}>Background Color:</label>
                                <input
                                    type="color"
                                    value={component.captionStyle?.backgroundColor || '#000000'}
                                    onChange={(e) => onChange({
                                        ...component,
                                        captionStyle: {
                                            ...component.captionStyle,
                                            backgroundColor: e.target.value,
                                        },
                                    })}
                                    style={styles.input}
                                />
                            </div>

                            <div>
                                <label style={styles.label}>Font Weight:</label>
                                <select
                                    value={style.fontWeight || 'normal'}
                                    onChange={(e) => onChange({
                                        ...component,
                                        style: {
                                            ...style,
                                            fontWeight: e.target.value,
                                        },
                                    })}
                                    style={styles.input}
                                >
                                    <option value="normal">Normal</option>
                                    <option value="bold">Bold</option>
                                    <option value="lighter">Light</option>
                                </select>
                            </div>

                            <div>
                                <label style={styles.label}>Text Alignment:</label>
                                <select
                                    value={style.textAlign || 'center'}
                                    onChange={(e) => onChange({
                                        ...component,
                                        style: {
                                            ...style,
                                            textAlign: e.target.value as 'left' | 'center' | 'right',
                                        },
                                    })}
                                    style={styles.input}
                                >
                                    <option value="left">Left</option>
                                    <option value="center">Center</option>
                                    <option value="right">Right</option>
                                </select>
                            </div>
                        </div>

                        {/* Position Preview */}
                        <div style={{ marginTop: theme.spacing.lg }}>
                            <h4 style={{ marginBottom: '10px' }}>Position & Preview</h4>
                            <DraggablePreview
                                text={component.text}
                                style={style}
                                onChange={(updates) => onChange({
                                    ...component,
                                    style: {
                                        ...style,
                                        ...updates,
                                    },
                                })}
                            />
                        </div>
                    </>
                )}
            </div>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\VoiceComponentEditor.tsx ---

import React, { useState } from 'react';
import { VoiceComponent } from '../../types/script';
import { generateSpeech, generateCaptions } from '../../services/elevenLabs';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';
import { CaptionPositioningScreen } from './CaptionPositioningScreen';

interface VoiceComponentEditorProps {
    component: VoiceComponent;
    onChange: (updated: VoiceComponent) => void;
}

type VoiceStatus = 'none' | 'generating' | 'success' | 'error';

const styles = {
    container: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: '20px',
    },
    section: {
        backgroundColor: theme.colors.background.secondary,
        padding: theme.spacing.lg,
        borderRadius: theme.borderRadius.md,
        border: `1px solid ${theme.colors.border}`,
    },
    label: {
        ...commonStyles.label,
        color: theme.colors.text.primary,
        display: 'block',
        marginBottom: theme.spacing.xs,
    },
    input: {
        ...commonStyles.input,
        backgroundColor: theme.colors.background.tertiary,
        border: `1px solid ${theme.colors.border}`,
        color: theme.colors.text.primary,
        padding: theme.spacing.sm,
        borderRadius: theme.borderRadius.sm,
        width: '100%',
    },
    button: {
        ...commonStyles.button.primary,
        display: 'flex',
        alignItems: 'center',
        gap: theme.spacing.sm,
        padding: `${theme.spacing.sm} ${theme.spacing.md}`,
    },
    grid: {
        display: 'grid',
        gridTemplateColumns: '1fr 1fr',
        gap: '20px',
    },
    modal: {
        position: 'fixed' as const,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        zIndex: 1000,
    },
    modalContent: {
        backgroundColor: '#fff',
        padding: theme.spacing.lg,
        borderRadius: theme.borderRadius.md,
        maxWidth: '90%',
        maxHeight: '90%',
        overflow: 'auto',
        position: 'relative' as const,
    },
};

export const VoiceComponentEditor: React.FC<VoiceComponentEditorProps> = ({
    component,
    onChange,
}) => {
    const [voiceStatus, setVoiceStatus] = useState<VoiceStatus>(
        component.audioUrl ? 'success' : 'none'
    );
    const [errorMessage, setErrorMessage] = useState<string>('');
    const [showPositioningScreen, setShowPositioningScreen] = useState(false);
    const style = component.style || {};

    const handleVoiceGeneration = async () => {
        try {
            if (!component.text) {
                setErrorMessage('Please enter text for voice generation');
                return;
            }

            setVoiceStatus('generating');
            setErrorMessage('');
            
            // Generate speech with the new interface
            const { audioUrl } = await generateSpeech({
                text: component.text,
                voiceId: component.voiceSettings?.voiceId || 'GhJYgP4Lrji0pwS3kQwv',
                settings: {
                    stability: component.voiceSettings?.stability || 0.75,
                    similarity_boost: component.voiceSettings?.similarity_boost || 0.75
                }
            });

            onChange({
                ...component,
                audioUrl,
                // Note: wordTimings are now included in the generateSpeech response
            });
            setVoiceStatus('success');
        } catch (error) {
            console.error('Voice generation failed:', error);
            setVoiceStatus('error');
            setErrorMessage(error instanceof Error ? error.message : 'Voice generation failed');
        }
    };

    const getStatusColor = () => {
        switch (voiceStatus) {
            case 'generating': return '#ffd700';
            case 'success': return '#4caf50';
            case 'error': return '#f44336';
            default: return '#007bff';
        }
    };

    return (
        <div style={styles.container}>
            {/* Voice Generation Section */}
            <div style={styles.section}>
                <h4 style={{ marginTop: 0 }}>Voice Generation</h4>
                <div style={{ marginBottom: theme.spacing.md }}>
                    <label style={styles.label}>Voice Text:</label>
                    <textarea
                        value={component.text}
                        onChange={(e) => onChange({
                            ...component,
                            text: e.target.value,
                        })}
                        style={{
                            ...styles.input,
                            minHeight: '100px',
                        }}
                        placeholder="Enter text for voice generation..."
                    />
                </div>

                <div style={styles.grid}>
                    <div>
                        <label style={styles.label}>Voice:</label>
                        <select
                            value={component.voiceSettings?.voiceId}
                            onChange={(e) => onChange({
                                ...component,
                                voiceSettings: {
                                    ...component.voiceSettings,
                                    voiceId: e.target.value,
                                },
                            })}
                            style={styles.input}
                        >
                            <option value="GhJYgP4Lrji0pwS3kQwv">Josh (Default)</option>
                            <option value="21m00Tcm4TlvDq8ikWAM">Rachel</option>
                            <option value="AZnzlk1XvdvUeBnXmlld">Domi</option>
                            <option value="EXAVITQu4vr4xnSDxMaL">Bella</option>
                            <option value="MF3mGyEYCl7XYWbV9V6O">Elli</option>
                        </select>
                    </div>

                    <div>
                        <label style={styles.label}>Stability:</label>
                        <input
                            type="range"
                            min="0"
                            max="100"
                            value={((component.voiceSettings?.stability || 0.75) * 100)}
                            onChange={(e) => onChange({
                                ...component,
                                voiceSettings: {
                                    ...component.voiceSettings,
                                    stability: parseInt(e.target.value) / 100,
                                },
                            })}
                            style={styles.input}
                        />
                    </div>
                </div>

                <div style={{ marginTop: theme.spacing.md }}>
                    <button
                        onClick={handleVoiceGeneration}
                        style={{
                            ...styles.button,
                            backgroundColor: getStatusColor(),
                        }}
                        disabled={voiceStatus === 'generating'}
                    >
                        {voiceStatus === 'generating' ? 'Generating...' : 'Generate Voice'}
                    </button>
                    {errorMessage && (
                        <div style={{ color: theme.colors.error, marginTop: theme.spacing.sm }}>
                            {errorMessage}
                        </div>
                    )}
                </div>

                {component.audioUrl && (
                    <div style={{ marginTop: theme.spacing.md }}>
                        <label style={styles.label}>Preview Audio:</label>
                        <audio
                            controls
                            src={component.audioUrl}
                            style={{ width: '100%' }}
                        />
                        
                        <div style={{ marginTop: theme.spacing.md }}>
                            <button
                                onClick={async () => {
                                    try {
                                        if (!component.audioUrl) return;

                                        // Get the audio file as a blob
                                        const response = await fetch(component.audioUrl);
                                        const audioBlob = await response.blob();
                                        
                                        // Create form data for transcription
                                        const formData = new FormData();
                                        formData.append('audio', audioBlob, 'speech.mp3');
                                        
                                        // Send to Whisper service
                                        const transcriptionResponse = await fetch('http://localhost:5000/transcribe', {
                                            method: 'POST',
                                            body: formData
                                        });

                                        if (!transcriptionResponse.ok) {
                                            throw new Error('Failed to generate captions');
                                        }

                                        const transcriptionData = await transcriptionResponse.json();
                                        
                                        // Update the component with captions
                                        onChange({
                                            ...component,
                                            wordTimings: transcriptionData.wordTimings,
                                            showCaptions: true,
                                            captionStyle: {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            }
                                        });
                                    } catch (error) {
                                        console.error('Error generating captions:', error);
                                        setErrorMessage('Failed to generate captions');
                                    }
                                }}
                                style={styles.button}
                                disabled={!component.audioUrl}
                            >
                                Generate Captions
                            </button>
                        </div>
                    </div>
                )}

                {/* Caption Settings */}
                {component.wordTimings && (
                    <div style={styles.section}>
                        <div style={{ 
                            display: 'flex', 
                            alignItems: 'center', 
                            gap: theme.spacing.md,
                            marginBottom: theme.spacing.md 
                        }}>
                            <h4 style={{ margin: 0 }}>Caption Settings</h4>
                            <label style={{
                                display: 'flex',
                                alignItems: 'center',
                                gap: theme.spacing.sm,
                                color: theme.colors.text.primary,
                            }}>
                                <input
                                    type="checkbox"
                                    checked={component.showCaptions}
                                    onChange={(e) => onChange({
                                        ...component,
                                        showCaptions: e.target.checked
                                    })}
                                />
                                Show Captions
                            </label>
                        </div>

                        {component.showCaptions && (
                            <div style={{ display: 'flex', flexDirection: 'column', gap: theme.spacing.md }}>
                                <div>
                                    <label style={styles.label}>Font Family:</label>
                                    <select
                                        value={component.captionStyle?.fontFamily || 'Arial'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    fontFamily: e.target.value
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    >
                                        <option value="Arial">Arial</option>
                                        <option value="Times New Roman">Times New Roman</option>
                                        <option value="Courier New">Courier New</option>
                                        <option value="Georgia">Georgia</option>
                                        <option value="Verdana">Verdana</option>
                                    </select>
                                </div>

                                <div>
                                    <label style={styles.label}>Font Size:</label>
                                    <input
                                        type="number"
                                        value={component.captionStyle?.fontSize || 24}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    fontSize: parseInt(e.target.value)
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <div>
                                    <label style={styles.label}>Font Weight:</label>
                                    <select
                                        value={component.captionStyle?.fontWeight || 'normal'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    fontWeight: e.target.value
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    >
                                        <option value="normal">Normal</option>
                                        <option value="bold">Bold</option>
                                        <option value="100">100</option>
                                        <option value="200">200</option>
                                        <option value="300">300</option>
                                        <option value="400">400</option>
                                        <option value="500">500</option>
                                        <option value="600">600</option>
                                        <option value="700">700</option>
                                        <option value="800">800</option>
                                        <option value="900">900</option>
                                    </select>
                                </div>

                                <div>
                                    <label style={styles.label}>Font Style:</label>
                                    <select
                                        value={component.captionStyle?.fontStyle || 'normal'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    fontStyle: e.target.value as 'normal' | 'italic'
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    >
                                        <option value="normal">Normal</option>
                                        <option value="italic">Italic</option>
                                    </select>
                                </div>

                                <div>
                                    <label style={styles.label}>Text Color:</label>
                                    <input
                                        type="color"
                                        value={component.captionStyle?.color || '#ffffff'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    color: e.target.value
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <div>
                                    <label style={styles.label}>Background Color:</label>
                                    <input
                                        type="color"
                                        value={component.captionStyle?.backgroundColor || 'rgba(0, 0, 0, 0.7)'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    backgroundColor: e.target.value
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <div>
                                    <label style={styles.label}>Position:</label>
                                    <select
                                        value={component.captionStyle?.position || 'bottom'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    position: e.target.value as 'top' | 'bottom'
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    >
                                        <option value="top">Top</option>
                                        <option value="bottom">Bottom</option>
                                    </select>
                                </div>

                                <div>
                                    <label style={styles.label}>Word Window:</label>
                                    <input
                                        type="number"
                                        min="1"
                                        max="10"
                                        value={component.captionStyle?.wordWindow || 1}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    wordWindow: parseInt(e.target.value)
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <div>
                                    <label style={styles.label}>Border Radius:</label>
                                    <input
                                        type="text"
                                        value={component.captionStyle?.borderRadius || '5px'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    borderRadius: e.target.value
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <div>
                                    <label style={styles.label}>Padding:</label>
                                    <input
                                        type="text"
                                        value={component.captionStyle?.padding || '10px 20px'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    padding: e.target.value
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <div>
                                    <label style={styles.label}>Box Shadow:</label>
                                    <input
                                        type="text"
                                        value={component.captionStyle?.boxShadow || 'none'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    boxShadow: e.target.value
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <div>
                                    <label style={styles.label}>Opacity:</label>
                                    <input
                                        type="range"
                                        min="0"
                                        max="1"
                                        step="0.1"
                                        value={component.captionStyle?.opacity || 1}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    opacity: parseFloat(e.target.value)
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <button
                                    onClick={() => setShowPositioningScreen(true)}
                                    style={styles.button}
                                >
                                    Open Positioning Screen
                                </button>

                                {showPositioningScreen && (
                                    <div style={styles.modal}>
                                        <div style={styles.modalContent}>
                                            <CaptionPositioningScreen
                                                style={component.captionStyle || {
                                                    fontSize: 24,
                                                    color: '#ffffff',
                                                    backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                    position: 'bottom',
                                                    wordWindow: 1
                                                }}
                                                onChange={(newStyle) => {
                                                    onChange({
                                                        ...component,
                                                        captionStyle: newStyle
                                                    });
                                                }}
                                            />
                                            <button
                                                onClick={() => setShowPositioningScreen(false)}
                                                style={styles.button}
                                            >
                                                Close
                                            </button>
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}
                    </div>
                )}
            </div>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\VoiceOverEditor.tsx ---

import React, { useState } from 'react';
import { ScriptComponent } from '../../types/script';
import { generateSpeech } from '../../services/elevenLabs';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';

interface VoiceOverEditorProps {
    component: ScriptComponent;
    onChange: (updated: ScriptComponent) => void;
}

type VoiceStatus = 'none' | 'generating' | 'success' | 'error';

const styles = {
    section: {
        backgroundColor: theme.colors.background.secondary,
        padding: theme.spacing.lg,
        borderRadius: theme.borderRadius.md,
        border: `1px solid ${theme.colors.border}`,
    },
    label: {
        ...commonStyles.label,
        color: theme.colors.text.primary,
        display: 'block',
        marginBottom: theme.spacing.xs,
    },
    input: {
        ...commonStyles.input,
        backgroundColor: theme.colors.background.tertiary,
        border: `1px solid ${theme.colors.border}`,
        color: theme.colors.text.primary,
        padding: theme.spacing.sm,
        borderRadius: theme.borderRadius.sm,
        width: '100%',
    },
    button: {
        ...commonStyles.button.primary,
        display: 'flex',
        alignItems: 'center',
        gap: theme.spacing.sm,
        padding: `${theme.spacing.sm} ${theme.spacing.md}`,
    },
};

export const VoiceOverEditor: React.FC<VoiceOverEditorProps> = ({
    component,
    onChange,
}) => {
    const [voiceStatus, setVoiceStatus] = useState<VoiceStatus>(
        component.voiceOver?.audioUrl ? 'success' : 'none'
    );
    const [errorMessage, setErrorMessage] = useState<string>('');

    const getComponentText = (comp: ScriptComponent): string => {
        switch (comp.type) {
            case 'comparison':
                return comp.question;
            case 'text':
            case 'title':
                return comp.text;
            default:
                return '';
        }
    };

    const handleVoiceGeneration = async () => {
        try {
            const text = getComponentText(component);
            if (!text) {
                setErrorMessage('No text available for voice generation');
                return;
            }

            setVoiceStatus('generating');
            setErrorMessage('');
            
            const { audioUrl, wordTimings } = await generateSpeech({
                text,
                voiceId: component.voiceOver?.voiceId || 'default',
                settings: {
                    stability: 0.75,
                    similarity_boost: 0.75,
                },
            });

            onChange({
                ...component,
                voiceOver: {
                    text,
                    audioUrl,
                    wordTimings,
                    voiceId: component.voiceOver?.voiceId || 'default',
                    settings: {
                        stability: 0.75,
                        similarity_boost: 0.75,
                    },
                },
            });
            setVoiceStatus('success');
        } catch (error) {
            console.error('Voice generation failed:', error);
            setVoiceStatus('error');
            setErrorMessage(error instanceof Error ? error.message : 'Voice generation failed');
        }
    };

    const getStatusColor = () => {
        switch (voiceStatus) {
            case 'generating': return '#ffd700';
            case 'success': return '#4caf50';
            case 'error': return '#f44336';
            default: return '#007bff';
        }
    };

    return (
        <div style={styles.section}>
            <div style={{
                display: 'flex',
                alignItems: 'center',
                gap: theme.spacing.md,
                marginBottom: theme.spacing.md,
            }}>
                <h3 style={{ margin: 0 }}>Voice Over</h3>
                <button
                    onClick={handleVoiceGeneration}
                    disabled={voiceStatus === 'generating'}
                    style={{
                        ...styles.button,
                        backgroundColor: getStatusColor(),
                    }}
                >
                    {voiceStatus === 'generating' && (
                        <div style={{
                            width: '16px',
                            height: '16px',
                            border: '2px solid white',
                            borderTop: '2px solid transparent',
                            borderRadius: '50%',
                            animation: 'spin 1s linear infinite',
                        }}>
                            <style>
                                {`
                                    @keyframes spin {
                                        0% { transform: rotate(0deg); }
                                        100% { transform: rotate(360deg); }
                                    }
                                `}
                            </style>
                        </div>
                    )}
                    {voiceStatus === 'generating' ? 'Generating...' : 
                     voiceStatus === 'success' ? 'Regenerate Voice' : 
                     voiceStatus === 'error' ? 'Try Again' : 
                     'Generate Voice'}
                </button>
                {voiceStatus === 'success' && (
                    <span style={{ color: '#4caf50' }}>‚úì Voice generated successfully</span>
                )}
                {voiceStatus === 'error' && (
                    <span style={{ color: '#f44336' }}>‚ö†Ô∏è {errorMessage}</span>
                )}
            </div>

            {/* Caption Settings */}
            <div style={{ marginBottom: theme.spacing.md }}>
                <label style={{
                    ...styles.label,
                    display: 'flex',
                    alignItems: 'center',
                    gap: theme.spacing.sm,
                }}>
                    <input
                        type="checkbox"
                        checked={component.captions?.enabled ?? false}
                        onChange={(e) => onChange({
                            ...component,
                            captions: e.target.checked ? {
                                enabled: true,
                                displayMode: 'sync',
                                style: {
                                    fontSize: 24,
                                    color: 'white',
                                    textAlign: 'center',
                                },
                            } : undefined,
                        })}
                    />
                    Enable Captions
                </label>
            </div>

            {/* Audio Preview */}
            {component.voiceOver?.audioUrl && (
                <div style={{
                    marginTop: theme.spacing.md,
                    padding: theme.spacing.md,
                    backgroundColor: theme.colors.background.tertiary,
                    borderRadius: theme.borderRadius.md,
                }}>
                    <label style={styles.label}>Preview Audio:</label>
                    <audio
                        controls
                        src={component.voiceOver.audioUrl}
                        style={{ width: '100%' }}
                    />
                </div>
            )}
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Settings\BackgroundManager.tsx ---

import React, { useState, useEffect } from 'react';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';

interface BackgroundHistory {
    name: string;
    url: string;
    addedAt: string;
    type: 'image' | 'video' | 'none';
}

interface BackgroundManagerProps {
    onSelectBackground: (background: { 
        type: 'image' | 'video' | 'none'; 
        url?: string; 
        filePath?: string;
        durationInFrames?: number;
    }) => void;
}

export const BackgroundManager: React.FC<BackgroundManagerProps> = ({ onSelectBackground }) => {
    const [backgrounds, setBackgrounds] = useState<BackgroundHistory[]>([]);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);

    const loadBackgrounds = async () => {
        try {
            setLoading(true);
            const response = await fetch('http://localhost:3002/backgrounds/history');
            if (!response.ok) throw new Error('Failed to load backgrounds');
            const data = await response.json();
            setBackgrounds(data);
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to load backgrounds');
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        loadBackgrounds();
    }, []);

    const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (!file) return;

        const formData = new FormData();
        formData.append('file', file);

        try {
            setLoading(true);
            const response = await fetch('http://localhost:3002/set_background', {
                method: 'POST',
                body: formData,
            });

            if (!response.ok) throw new Error('Failed to upload background');
            
            const data = await response.json();
            await loadBackgrounds(); // Refresh the list
            
            // Select the newly uploaded background
            onSelectBackground({
                type: 'image',
                url: data.url,
                filePath: data.filePath
            });
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to upload background');
        } finally {
            setLoading(false);
        }
    };

    const handleRemoveBackground = async (name: string) => {
        try {
            setLoading(true);
            const response = await fetch('http://localhost:3002/remove_background', {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ name }),
            });

            if (!response.ok) throw new Error('Failed to remove background');
            await loadBackgrounds(); // Refresh the list
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to remove background');
        } finally {
            setLoading(false);
        }
    };

    return (
        <div style={styles.container}>
            <div style={styles.header}>
                <h3 style={styles.title}>Background Manager</h3>
                <input
                    type="file"
                    accept="image/*"
                    onChange={handleFileUpload}
                    style={{ display: 'none' }}
                    id="background-upload"
                />
                <label htmlFor="background-upload" style={styles.uploadButton}>
                    Upload New Background
                </label>
            </div>

            {error && <div style={styles.error}>{error}</div>}

            <div style={styles.grid}>
                {/* No Background Option */}
                <div 
                    style={styles.backgroundItem}
                    onClick={() => onSelectBackground({ type: 'none', url: '', filePath: '' })}
                >
                    <div style={styles.noBackgroundPreview}>
                        No Background
                    </div>
                    <div style={styles.backgroundName}>None</div>
                </div>

                {backgrounds.map((bg) => (
                    <div key={bg.name} style={styles.backgroundItem}>
                        <div 
                            style={styles.imagePreview}
                            onClick={() => onSelectBackground({
                                type: 'image',
                                url: bg.url,
                                filePath: bg.name
                            })}
                        >
                            <img src={bg.url} alt={bg.name} style={styles.previewImage} />
                        </div>
                        <div style={styles.backgroundInfo}>
                            <div style={styles.backgroundName}>{bg.name}</div>
                            <button
                                onClick={(e) => {
                                    e.stopPropagation();
                                    handleRemoveBackground(bg.name);
                                }}
                                style={styles.removeButton}
                            >
                                Remove
                            </button>
                        </div>
                    </div>
                ))}
            </div>

            {loading && <div style={styles.loading}>Loading...</div>}
        </div>
    );
};

const styles = {
    container: {
        padding: theme.spacing.md,
    },
    header: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: theme.spacing.lg,
    },
    title: {
        margin: 0,
        color: theme.colors.text.primary,
    },
    uploadButton: {
        ...commonStyles.button.primary,
        cursor: 'pointer',
    },
    grid: {
        display: 'grid',
        gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))',
        gap: theme.spacing.md,
        marginTop: theme.spacing.md,
    },
    backgroundItem: {
        border: `1px solid ${theme.colors.border}`,
        borderRadius: theme.borderRadius.md,
        overflow: 'hidden',
        backgroundColor: theme.colors.background.secondary,
    },
    imagePreview: {
        width: '100%',
        height: '150px',
        backgroundColor: theme.colors.background.tertiary,
        cursor: 'pointer',
        position: 'relative' as const,
    },
    noBackgroundPreview: {
        width: '100%',
        height: '150px',
        backgroundColor: theme.colors.background.tertiary,
        cursor: 'pointer',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        color: theme.colors.text.secondary,
    },
    previewImage: {
        width: '100%',
        height: '100%',
        objectFit: 'cover' as const,
    },
    backgroundInfo: {
        padding: theme.spacing.sm,
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
    },
    backgroundName: {
        color: theme.colors.text.primary,
        fontSize: '0.9em',
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap' as const,
    },
    removeButton: {
        ...commonStyles.button.secondary,
        color: theme.colors.error,
        padding: '4px 8px',
        fontSize: '0.8em',
    },
    error: {
        color: theme.colors.error,
        marginBottom: theme.spacing.md,
        padding: theme.spacing.sm,
        backgroundColor: 'rgba(244, 67, 54, 0.1)',
        borderRadius: theme.borderRadius.sm,
    },
    loading: {
        textAlign: 'center' as const,
        color: theme.colors.text.secondary,
        marginTop: theme.spacing.md,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Settings\FontManager.tsx ---

import React, { useState, useEffect } from 'react';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';

interface FontManagerProps {
    onClose: () => void;
}

interface CustomFont {
    name: string;
    url: string;
    format: 'truetype' | 'opentype';
}

const styles = {
    modal: {
        position: 'fixed' as const,
        top: '50%',
        left: '50%',
        transform: 'translate(-50%, -50%)',
        backgroundColor: theme.colors.background.secondary,
        padding: theme.spacing.xl,
        borderRadius: theme.borderRadius.lg,
        boxShadow: theme.shadows.lg,
        width: '90%',
        maxWidth: '600px',
        maxHeight: '80vh',
        overflow: 'auto',
        zIndex: 1000,
    },
    overlay: {
        position: 'fixed' as const,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.7)',
        zIndex: 999,
    },
    title: {
        margin: 0,
        marginBottom: theme.spacing.lg,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.xl,
    },
    fontList: {
        marginBottom: theme.spacing.lg,
    },
    fontItem: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        padding: theme.spacing.md,
        backgroundColor: theme.colors.background.tertiary,
        borderRadius: theme.borderRadius.sm,
        marginBottom: theme.spacing.sm,
    },
    button: {
        ...commonStyles.button,
        marginRight: theme.spacing.sm,
    },
    deleteButton: {
        backgroundColor: theme.colors.error,
        color: 'white',
        border: 'none',
        padding: `${theme.spacing.xs} ${theme.spacing.sm}`,
        borderRadius: theme.borderRadius.sm,
        cursor: 'pointer',
    },
    input: {
        display: 'none',
    },
};

export const FontManager: React.FC<FontManagerProps> = ({ onClose }) => {
    const [customFonts, setCustomFonts] = useState<CustomFont[]>([]);

    // Load fonts from background service
    useEffect(() => {
        const loadFonts = async () => {
            try {
                const response = await fetch('http://localhost:3003/fonts/dictionary');
                if (!response.ok) throw new Error('Failed to load fonts');
                const fontDict = await response.json();
                
                // Convert dictionary to array
                const fonts = Object.entries(fontDict).map(([name, data]: [string, any]) => ({
                    name,
                    url: data.url,
                    format: data.format
                }));
                setCustomFonts(fonts);

                // Load each font
                fonts.forEach(font => {
                    try {
                        const testFont = new FontFace(font.name, `url(${font.url})`);
                        testFont.load().then(loadedFont => {
                            document.fonts.add(loadedFont);
                        }).catch(error => {
                            console.error('Error loading font:', error);
                        });
                    } catch (error) {
                        console.error('Error creating font:', error);
                    }
                });
            } catch (error) {
                console.error('Error loading font dictionary:', error);
            }
        };

        loadFonts();
    }, []);

    const handleFileSelect = async (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (!file) return;

        // Check if it's an OTF or TTF file
        if (!file.name.match(/\.(otf|ttf)$/i)) {
            alert('Please select an OTF or TTF font file');
            return;
        }

        try {
            // Create form data
            const formData = new FormData();
            formData.append('file', file);

            // Upload font to font service
            const response = await fetch('http://localhost:3003/set_font', {
                method: 'POST',
                body: formData,
            });

            if (!response.ok) {
                throw new Error('Failed to upload font');
            }

            const result = await response.json();
            const { url, name } = result;
            const format = file.name.toLowerCase().endsWith('.otf') ? 'opentype' as const : 'truetype' as const;

            // Test if font can be loaded
            console.log('Loading font:', name, 'from URL:', url);
            const testFont = new FontFace(name, `url(${url})`);
            await testFont.load();
            document.fonts.add(testFont);
            console.log('Successfully loaded font:', name);

            // Add new font to list
            const newFont: CustomFont = { name, url, format };
            setCustomFonts(prev => [...prev, newFont]);

            // Force preview to reload fonts
            window.dispatchEvent(new Event('fontsUpdated'));

        } catch (error) {
            console.error('Error loading font:', error);
            alert('Error loading font. Please try another file.');
        }
    };

    const handleDelete = async (fontName: string) => {
        try {
            // Delete font from font service
            const response = await fetch('http://localhost:3003/delete_font', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ name: fontName }),
            });

            if (!response.ok) {
                throw new Error('Failed to delete font');
            }

            // Remove font from document.fonts
            const fontToRemove = Array.from(document.fonts).find(f => f.family === fontName);
            if (fontToRemove) {
                document.fonts.delete(fontToRemove);
                console.log('Removed font from document:', fontName);
            }

            // Update state
            setCustomFonts(prev => prev.filter(font => font.name !== fontName));

            // Force preview to reload fonts
            window.dispatchEvent(new Event('fontsUpdated'));

        } catch (error) {
            console.error('Error deleting font:', error);
            alert('Error deleting font. Please try again.');
        }
    };

    return (
        <>
            <div style={styles.overlay} onClick={onClose} />
            <div style={styles.modal}>
                <h2 style={styles.title}>Font Manager</h2>

                <div style={styles.fontList}>
                    {customFonts.map(font => (
                        <div key={font.name} style={styles.fontItem}>
                            <span style={{ 
                                fontFamily: `'${font.name}'`,
                                fontSize: '18px',
                            }}>
                                {font.name} - Sample Text
                            </span>
                            <button
                                style={styles.deleteButton}
                                onClick={() => handleDelete(font.name)}
                            >
                                Delete
                            </button>
                        </div>
                    ))}
                </div>

                <input
                    type="file"
                    accept=".otf,.ttf"
                    onChange={handleFileSelect}
                    id="font-file"
                    style={styles.input}
                />
                <label htmlFor="font-file" style={styles.button}>
                    Add Font
                </label>
                <button style={styles.button} onClick={onClose}>
                    Close
                </button>
            </div>
        </>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Settings\PositioningPopup.tsx ---

import React from 'react';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';

interface PositioningPopupProps {
    onClose: () => void;
    children: React.ReactNode;
}

const styles = {
    overlay: {
        position: 'fixed' as const,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.7)',
        zIndex: 9999,
    },
    modal: {
        position: 'fixed' as const,
        top: '50%',
        left: '50%',
        transform: 'translate(-50%, -50%)',
        backgroundColor: theme.colors.background.secondary,
        padding: theme.spacing.xl,
        borderRadius: theme.borderRadius.lg,
        boxShadow: theme.shadows.lg,
        width: '90vw',
        height: '90vh',
        display: 'flex',
        flexDirection: 'column' as const,
        zIndex: 10000,
    },
    header: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: theme.spacing.lg,
    },
    title: {
        margin: 0,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.xl,
    },
    closeButton: {
        ...commonStyles.button,
        padding: `${theme.spacing.xs} ${theme.spacing.sm}`,
    },
    content: {
        flex: 1,
        overflow: 'hidden',
        backgroundColor: theme.colors.background.tertiary,
        borderRadius: theme.borderRadius.md,
        position: 'relative' as const,
    },
    canvas: {
        width: '100%',
        height: '100%',
        position: 'relative' as const,
        overflow: 'hidden',
        transform: 'scale(2)',
        transformOrigin: 'top left',
    },
};

export const PositioningPopup: React.FC<PositioningPopupProps> = ({ onClose, children }) => {
    return (
        <>
            <div style={styles.overlay} onClick={onClose} />
            <div style={styles.modal}>
                <div style={styles.header}>
                    <h2 style={styles.title}>Precise Positioning</h2>
                    <button style={styles.closeButton} onClick={onClose}>
                        Close
                    </button>
                </div>
                <div style={styles.content}>
                    <div style={styles.canvas}>
                        {children}
                    </div>
                </div>
            </div>
        </>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Setup\ComparisonEditor.tsx ---

import React from 'react';
import {Comparison} from '../../types/quiz';
import { ImageSelector } from './ImageSelector';

interface ComparisonEditorProps {
  item: QuizItem;
  onChange: (item: QuizItem) => void;
  onDelete: () => void;
}

export const ComparisonEditor: React.FC<ComparisonEditorProps> = ({
  item,
  onChange,
  onDelete,
}) => {
  return (
    <div style={{
      border: '1px solid #ccc',
      padding: '20px',
      marginBottom: '20px',
      borderRadius: '8px',
    }}>
      <div style={{ marginBottom: '20px' }}>
        <label>
          Question:
          <input
            type="text"
            value={item.question}
            onChange={(e) => onChange({
              ...item,
              question: e.target.value,
              voiceover: e.target.value, // Auto-set voiceover to question
            })}
            style={{ width: '100%', padding: '8px' }}
          />
        </label>
      </div>

      <div style={{ display: 'flex', gap: '20px' }}>
        {/* Left Option */}
        <div style={{ flex: 1 }}>
          <h4>Left Option</h4>
          <input
            type="text"
            value={item.leftOption.text}
            onChange={(e) => onChange({
              ...item,
              leftOption: {
                ...item.leftOption,
                text: e.target.value,
              },
            })}
            placeholder="Left option text"
          />
          <ImageSelector
            currentImage={item.leftOption.image}
            searchTerm={item.leftOption.text}
            onSelect={(imageUrl) => onChange({
              ...item,
              leftOption: {
                ...item.leftOption,
                image: imageUrl,
              },
            })}
          />
        </div>

        {/* Right Option */}
        <div style={{ flex: 1 }}>
          <h4>Right Option</h4>
          <input
            type="text"
            value={item.rightOption.text}
            onChange={(e) => onChange({
              ...item,
              rightOption: {
                ...item.rightOption,
                text: e.target.value,
              },
            })}
            placeholder="Right option text"
          />
          <ImageSelector
            currentImage={item.rightOption.image}
            searchTerm={item.rightOption.text}
            onSelect={(imageUrl) => onChange({
              ...item,
              rightOption: {
                ...item.rightOption,
                image: imageUrl,
              },
            })}
          />
        </div>
      </div>

      <button onClick={onDelete} style={{ marginTop: '20px', color: 'red' }}>
        Delete Comparison
      </button>
    </div>
  );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Setup\ImagePicker.tsx ---

import React, { useState, useEffect } from 'react';
import { createClient } from 'pexels';

const client = createClient('rXEDE5m6pUxOXZPawHmzKj04Z29WlV2y0Us44ld2TmXwdZstXtHUIh2F');

interface ImagePickerProps {
  currentImage: string;
  searchTerm: string;
  onSelect: (imageUrl: string) => void;
}

export const ImagePicker: React.FC<ImagePickerProps> = ({
  currentImage,
  searchTerm,
  onSelect,
}) => {
  const [images, setImages] = useState<Array<{ url: string }>>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (searchTerm) {
      setLoading(true);
      client.photos.search({ query: searchTerm, per_page: 10 })
        .then(result => {
          if ('photos' in result) {
            setImages(result.photos.map(photo => ({
              url: photo.src.large
            })));
          }
          setLoading(false);
        })
        .catch(err => {
          console.error('Error fetching images:', err);
          setLoading(false);
        });
    }
  }, [searchTerm]);

  return (
    <div>
      {loading ? (
        <div>Loading images...</div>
      ) : (
        <div style={{
          display: 'grid',
          gridTemplateColumns: 'repeat(auto-fill, minmax(100px, 1fr))',
          gap: '10px',
          marginTop: '10px',
        }}>
          {images.map((image, index) => (
            <img
              key={index}
              src={image.url}
              alt={`Option ${index + 1}`}
              style={{
                width: '100%',
                height: '100px',
                objectFit: 'cover',
                cursor: 'pointer',
                border: currentImage === image.url ? '3px solid blue' : '1px solid #ccc',
              }}
              onClick={() => onSelect(image.url)}
            />
          ))}
        </div>
      )}
    </div>
  );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Setup\ImageSelector.tsx ---

import React, { useState, useEffect } from 'react';
import { createClient } from 'pexels';

const client = createClient('rXEDE5m6pUxOXZPawHmzKj04Z29WlV2y0Us44ld2TmXwdZstXtHUIh2F');

interface ImageSelectorProps {
    searchTerm: string;
    onSelect: (imageUrl: string) => void;
    currentImageUrl?: string;
}

export const ImageSelector: React.FC<ImageSelectorProps> = ({
    searchTerm,
    onSelect,
    currentImageUrl,
}) => {
    // ... rest of the component stays the same, just update property names
    // from currentImage to currentImageUrl
    // and image.url to photo.src.medium
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Setup\Setup.tsx ---

import React, { useState } from 'react';
import { Player } from '@remotion/player';
import { QuizVideo } from '../../QuizVideo';
import { QuizItem } from '../../data/quizData';
import { ComparisonEditor } from './ComparisonEditor';

export const Setup: React.FC = () => {
  const [quizItems, setQuizItems] = useState<QuizItem[]>([]);
  
  const addComparison = () => {
    setQuizItems([
      ...quizItems,
      {
        question: '',
        leftOption: {
          image: '',
          text: '',
        },
        rightOption: {
          image: '',
          text: '',
        },
        voiceover: '',
      },
    ]);
  };

  return (
    <div style={{ display: 'flex', gap: '20px', padding: '20px' }}>
      {/* Editor Section */}
      <div style={{ flex: 1 }}>
        <button onClick={addComparison}>Add Comparison</button>
        
        {quizItems.map((item, index) => (
          <ComparisonEditor
            key={index}
            item={item}
            onChange={(updatedItem) => {
              const newItems = [...quizItems];
              newItems[index] = updatedItem;
              setQuizItems(newItems);
            }}
            onDelete={() => {
              const newItems = quizItems.filter((_, i) => i !== index);
              setQuizItems(newItems);
            }}
          />
        ))}
      </div>

      {/* Preview Section */}
      <div style={{ flex: 1 }}>
        <Player
          component={QuizVideo}
          durationInFrames={1800}
          fps={30}
          compositionWidth={1080}
          compositionHeight={1920}
          style={{
            width: '100%',
            height: 'auto',
          }}
          inputProps={{
            quizConfig: {
              comparisons: quizItems
            }
          }}
        />
      </div>
    </div>
  );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\SetupPage.tsx ---

import React, {useState} from 'react';
import {Player} from '@remotion/player';
import {QuizConfig, Comparison} from '../types/quiz';
import {ComparisonEditor} from './ComparisonEditor';
import {QuizVideo} from './Video/QuizVideo';

export const SetupPage: React.FC = () => {
	const [quizConfig, setQuizConfig] = useState<QuizConfig>({
		comparisons: [],
	});

	// Calculate duration, minimum 1 second (30 frames)
	const videoDuration = Math.max(30, quizConfig.comparisons.length * 150);

	return (
		<div style={{
			display: 'grid',
			gridTemplateColumns: '1fr 1fr',
			gap: '20px',
			padding: '20px',
			height: '100vh',
			overflow: 'hidden',
		}}>
			{/* Left side - Editor Section */}
			<div style={{
				overflowY: 'auto',
				padding: '20px',
			}}>
				<h1>Quiz Video Setup</h1>
				<button
					onClick={() => {
						const newComparison: Comparison = {
							id: Date.now().toString(),
							question: '',
							leftOption: {
								text: '',
								imageUrl: '',
							},
							rightOption: {
								text: '',
								imageUrl: '',
							},
						};
						setQuizConfig(prev => ({
							...prev,
							comparisons: [...prev.comparisons, newComparison],
						}));
					}}
					style={{
						padding: '12px 24px',
						fontSize: '16px',
						cursor: 'pointer',
						backgroundColor: '#007bff',
						color: 'white',
						border: 'none',
						borderRadius: '4px',
						marginBottom: '20px',
					}}
				>
					Add New Comparison
				</button>

				<div style={{
					display: 'flex',
					flexDirection: 'column',
					gap: '20px',
				}}>
					{quizConfig.comparisons.map((comparison) => (
						<ComparisonEditor
							key={comparison.id}
							comparison={comparison}
							onChange={(updatedComparison) => {
								setQuizConfig(prev => ({
									...prev,
									comparisons: prev.comparisons.map(c => 
										c.id === updatedComparison.id ? updatedComparison : c
									),
								}));
							}}
							onDelete={() => {
								setQuizConfig(prev => ({
									...prev,
									comparisons: prev.comparisons.filter(c => c.id !== comparison.id),
								}));
							}}
						/>
					))}
				</div>
			</div>

			{/* Right side - Preview Section */}
			<div style={{
				backgroundColor: '#f8f9fa',
				padding: '20px',
				borderRadius: '8px',
				display: 'flex',
				flexDirection: 'column',
				height: '100%',
				overflowY: 'auto',
			}}>
				<h2 style={{marginBottom: '20px'}}>Preview</h2>
				
				{/* Debug Info */}
				<div style={{ 
					marginBottom: '20px', 
					padding: '10px', 
					backgroundColor: '#eee', 
					borderRadius: '4px' 
				}}>
					<h3>Debug Info:</h3>
					<pre style={{ whiteSpace: 'pre-wrap', wordBreak: 'break-word' }}>
						{JSON.stringify({
							comparisonsCount: quizConfig.comparisons.length,
							videoDuration,
							firstComparison: quizConfig.comparisons[0],
						}, null, 2)}
					</pre>
				</div>

				{/* Player Container */}
				<div style={{
					position: 'relative',
					width: '100%',
					paddingTop: '177.78%', // 16:9 aspect ratio
					backgroundColor: '#000',
					borderRadius: '8px',
					overflow: 'hidden',
				}}>
					<div style={{
						position: 'absolute',
						top: 0,
						left: 0,
						right: 0,
						bottom: 0,
					}}>
						<Player
							component={QuizVideo}
							inputProps={{
								quizConfig: quizConfig,
							}}
							durationInFrames={videoDuration}
							fps={30}
							compositionWidth={1080}
							compositionHeight={1920}
							style={{
								width: '100%',
								height: '100%',
							}}
							controls
							autoPlay
							loop
						/>
					</div>
				</div>
			</div>
		</div>
	);
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\TemplateManager\TemplateManager.tsx ---

import React, { useState, useEffect } from 'react';
import {
    Box,
    Button,
    Dialog,
    DialogTitle,
    DialogContent,
    DialogActions,
    TextField,
    List,
    ListItem,
    ListItemText,
    ListItemSecondaryAction,
    IconButton,
    Typography,
    Tooltip,
} from '@mui/material';
import DeleteIcon from '@mui/icons-material/Delete';
import DownloadIcon from '@mui/icons-material/Download';
import AddIcon from '@mui/icons-material/Add';
import { Template } from '../../types/template';
import { Script } from '../../types/script';
import {
    getTemplates,
    saveTemplate,
    deleteTemplate,
    scriptToTemplate,
    templateToScript,
} from '../../services/templateService';

interface TemplateManagerProps {
    currentScript?: Script;
    onTemplateSelect?: (script: Script) => void;
}

export const TemplateManager: React.FC<TemplateManagerProps> = ({
    currentScript,
    onTemplateSelect,
}) => {
    const [templates, setTemplates] = useState<Template[]>([]);
    const [isAddDialogOpen, setIsAddDialogOpen] = useState(false);
    const [newTemplateName, setNewTemplateName] = useState('');
    const [newTemplateDescription, setNewTemplateDescription] = useState('');

    useEffect(() => {
        loadTemplates();
    }, []);

    const loadTemplates = () => {
        const loadedTemplates = getTemplates();
        setTemplates(loadedTemplates);
    };

    const handleSaveTemplate = () => {
        if (!currentScript || !newTemplateName) return;

        const template = scriptToTemplate(
            currentScript,
            newTemplateName,
            newTemplateDescription
        );
        saveTemplate(template);
        setIsAddDialogOpen(false);
        setNewTemplateName('');
        setNewTemplateDescription('');
        loadTemplates();
    };

    const handleDeleteTemplate = (templateId: string) => {
        deleteTemplate(templateId);
        loadTemplates();
    };

    const handleTemplateSelect = (template: Template) => {
        if (onTemplateSelect) {
            const script = templateToScript(template);
            onTemplateSelect(script);
        }
    };

    const handleDownloadTemplate = (template: Template) => {
        const templateJson = JSON.stringify(template, null, 2);
        const blob = new Blob([templateJson], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${template.name.toLowerCase().replace(/\s+/g, '_')}_template.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    };

    return (
        <Box>
            <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
                <Typography variant="h6">Templates</Typography>
                <Button
                    variant="contained"
                    color="primary"
                    startIcon={<AddIcon />}
                    onClick={() => setIsAddDialogOpen(true)}
                    disabled={!currentScript}
                >
                    Save as Template
                </Button>
            </Box>

            <List>
                {templates.map((template) => (
                    <ListItem
                        key={template.id}
                        button
                        onClick={() => handleTemplateSelect(template)}
                    >
                        <ListItemText
                            primary={template.name}
                            secondary={template.description || 'No description'}
                        />
                        <ListItemSecondaryAction>
                            <Tooltip title="Download Template">
                                <IconButton
                                    edge="end"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        handleDownloadTemplate(template);
                                    }}
                                >
                                    <DownloadIcon />
                                </IconButton>
                            </Tooltip>
                            <Tooltip title="Delete Template">
                                <IconButton
                                    edge="end"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        handleDeleteTemplate(template.id);
                                    }}
                                >
                                    <DeleteIcon />
                                </IconButton>
                            </Tooltip>
                        </ListItemSecondaryAction>
                    </ListItem>
                ))}
                {templates.length === 0 && (
                    <Typography color="textSecondary" align="center" py={2}>
                        No templates saved yet
                    </Typography>
                )}
            </List>

            <Dialog
                open={isAddDialogOpen}
                onClose={() => setIsAddDialogOpen(false)}
                maxWidth="sm"
                fullWidth
            >
                <DialogTitle>Save as Template</DialogTitle>
                <DialogContent>
                    <TextField
                        autoFocus
                        margin="dense"
                        label="Template Name"
                        fullWidth
                        value={newTemplateName}
                        onChange={(e) => setNewTemplateName(e.target.value)}
                    />
                    <TextField
                        margin="dense"
                        label="Description (optional)"
                        fullWidth
                        multiline
                        rows={3}
                        value={newTemplateDescription}
                        onChange={(e) => setNewTemplateDescription(e.target.value)}
                    />
                </DialogContent>
                <DialogActions>
                    <Button onClick={() => setIsAddDialogOpen(false)}>Cancel</Button>
                    <Button
                        onClick={handleSaveTemplate}
                        color="primary"
                        disabled={!newTemplateName}
                    >
                        Save
                    </Button>
                </DialogActions>
            </Dialog>
        </Box>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Timer.tsx ---

import {useCurrentFrame, Video} from 'remotion';
import clockVideo from '../@Assets/clock.mp4';

interface TimerProps {
	startFrame: number;
}

export const Timer: React.FC<TimerProps> = ({startFrame}) => {
	const frame = useCurrentFrame();
	const relativeFrame = frame - startFrame;

	return (
		<div style={{
			position: 'absolute',
			bottom: 100,
			left: '50%',
			transform: 'translateX(-50%)',
			width: '200px', // Adjust size as needed
			height: '200px',
		}}>
			<Video
				src={clockVideo}
				startFrom={relativeFrame}
				endAt={relativeFrame + 150} // 5 seconds at 30fps
				style={{
					width: '100%',
					height: '100%',
				}}
			/>
		</div>
	);
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\AudioComponent.tsx ---

import React, { useEffect, useRef } from 'react';
import { useCurrentFrame, useVideoConfig } from 'remotion';
import { AudioComponent as AudioComponentType } from '../../types/script';

interface AudioComponentProps {
    component: AudioComponentType;
}

export const AudioComponent: React.FC<AudioComponentProps> = ({ component }) => {
    const frame = useCurrentFrame();
    const { fps } = useVideoConfig();
    const audioRef = useRef<HTMLAudioElement>(null);
    const audioContextRef = useRef<AudioContext | null>(null);
    const sourceNodeRef = useRef<MediaElementAudioSourceNode | null>(null);
    const gainNodeRef = useRef<GainNode | null>(null);

    useEffect(() => {
        if (!audioRef.current) return;

        // Initialize Web Audio API context and nodes
        if (!audioContextRef.current) {
            const AudioContextClass = window.AudioContext || (window as any).webkitAudioContext;
            audioContextRef.current = new AudioContextClass();
            sourceNodeRef.current = audioContextRef.current.createMediaElementSource(audioRef.current);
            gainNodeRef.current = audioContextRef.current.createGain();
            sourceNodeRef.current.connect(gainNodeRef.current);
            gainNodeRef.current.connect(audioContextRef.current.destination);
        }

        const audio = audioRef.current;
        const gainNode = gainNodeRef.current;
        const startTime = component.style?.startTime ?? 0;
        const currentTime = frame / fps;

        // Set volume using gain node
        if (gainNode) {
            gainNode.gain.value = component.style?.volume ?? 1;
        }

        // Set loop
        audio.loop = component.style?.loop ?? false;

        // Calculate and set current time
        const audioTime = currentTime - startTime;
        if (audioTime >= 0) {
            audio.currentTime = audioTime;
            audio.play().catch(console.error);
        } else {
            audio.pause();
        }

        // Handle duration limit
        if (component.style?.duration) {
            const duration = component.style.duration;
            if (audioTime > duration) {
                audio.pause();
            }
        }

        // Cleanup
        return () => {
            audio.pause();
            if (audioContextRef.current) {
                audioContextRef.current.close();
                audioContextRef.current = null;
                sourceNodeRef.current = null;
                gainNodeRef.current = null;
            }
        };
    }, [frame, fps, component.style?.startTime, component.style?.volume, component.style?.loop, component.style?.duration]);

    const audioUrl = typeof component.audioUrl === 'string' ? component.audioUrl : component.audioUrl.url;

    return (
        <audio
            ref={audioRef}
            src={audioUrl}
            preload="auto"
            crossOrigin="anonymous"
        />
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\CaptionRenderer.tsx ---

import React from 'react';
import { useCurrentFrame } from 'remotion';
import { WordTiming, CaptionStyle } from '../../types/script';

interface CaptionRendererProps {
    wordTimings: WordTiming[];
    style: CaptionStyle;
}

export const CaptionRenderer: React.FC<CaptionRendererProps> = ({ wordTimings, style }) => {
    const frame = useCurrentFrame();
    const fps = 30; // Standard frame rate
    const currentTime = frame / fps;

    // Find words that should be visible based on the current time and word window
    const visibleWords = wordTimings.filter(timing => {
        const isWithinTime = currentTime >= timing.start && currentTime <= timing.end;
        if (!isWithinTime) return false;

        // Find the index of the current word
        const currentIndex = wordTimings.findIndex(w => w === timing);
        const windowStart = Math.max(0, currentIndex - Math.floor(style.wordWindow / 2));
        const windowEnd = Math.min(wordTimings.length - 1, currentIndex + Math.floor(style.wordWindow / 2));

        // Check if the word is within the window
        return currentIndex >= windowStart && currentIndex <= windowEnd;
    });

    if (visibleWords.length === 0) return null;

    return (
        <div style={{
            position: 'absolute',
            bottom: style.position === 'top' ? 'auto' : '10%',
            top: style.position === 'top' ? '10%' : 'auto',
            left: '50%',
            transform: 'translateX(-50%)',
            textAlign: 'center',
            fontSize: style.fontSize,
            color: style.color,
            backgroundColor: style.backgroundColor,
            padding: '10px 20px',
            borderRadius: '5px',
            maxWidth: '80%',
            transition: 'all 0.2s ease-in-out'
        }}>
            {visibleWords.map(word => word.word).join(' ')}
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\ComparisonComponent.tsx ---

import React from 'react';
import { ComparisonComponent as ComparisonComponentType } from '../../types/script';
import { AbsoluteFill, useCurrentFrame, interpolate, spring } from 'remotion';
import { theme } from '../../styles/theme';

interface ComparisonComponentProps {
    component: ComparisonComponentType;
}

const getAnimationStyle = (
    frame: number,
    animation: ComparisonComponentType['style']['animation'],
    isSecondImage: boolean = false,
    durationInFrames: number
) => {
    if (!animation || animation.type === 'none') {
        return {};
    }

    const delay = (animation.delay || 0) + (isSecondImage ? (animation.stagger || 0) : 0);
    const duration = animation.duration || 30;
    const currentFrame = Math.max(0, frame - delay);
    const progress = interpolate(
        currentFrame,
        [0, duration, durationInFrames - duration, durationInFrames],
        [0, 1, 1, 0],
        {
            extrapolateLeft: 'clamp',
            extrapolateRight: 'clamp',
            easing: animation.easing === 'linear' ? (t) => t :
                   animation.easing === 'ease-in' ? (t) => t * t :
                   animation.easing === 'ease-out' ? (t) => 1 - Math.pow(1 - t, 2) :
                   (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2
        }
    );

    switch (animation.type) {
        case 'fade':
            return { opacity: progress };
        case 'scale':
            return { transform: `scale(${progress})` };
        case 'rotate':
            return { transform: `rotate(${interpolate(progress, [0, 1], [0, 360])}deg)` };
        case 'slide':
            const offset = 100;
            const x = animation.direction === 'left' ? -offset : 
                     animation.direction === 'right' ? offset : 0;
            const y = animation.direction === 'top' ? -offset :
                     animation.direction === 'bottom' ? offset : 0;
            return {
                transform: `translate(${interpolate(progress, [0, 1], [x, 0])}%, ${interpolate(progress, [0, 1], [y, 0])}%)`
            };
        default:
            return {};
    }
};

export const ComparisonComponent: React.FC<ComparisonComponentProps> = ({ component }) => {
    const frame = useCurrentFrame();
    const { 
        fontSize = 32, 
        fontFamily = 'Arial', 
        textColor = '#ffffff', 
        backgroundColor = 'rgba(0, 0, 0, 0.7)', 
        spacing = 20, 
        borderRadius = 8, 
        shadow = true,
        showText = true,
        imageSize = 100,
        imageGap = 20,
        forceSameSize = true,
        imagePosition = { x: 0, y: 0 },
        imageBorder,
        imageDropShadow,
        animation
    } = component.style || {};

    // Base fade animation
    const opacity = interpolate(
        frame,
        [0, 15, component.durationInFrames - 15, component.durationInFrames],
        [0, 1, 1, 0]
    );

    const imageContainerStyle = {
        display: 'flex',
        flexDirection: component.orientation === 'horizontal' ? 'row' as const : 'column' as const,
        gap: `${imageGap}px`,
        justifyContent: 'center',
        alignItems: 'center',
        transform: `translate(${imagePosition.x}%, ${imagePosition.y}%)`,
        width: '100%',
        height: '100%',
        padding: '10% 5%',
    };

    const commonImageStyle = {
        width: forceSameSize ? `${imageSize}%` : 'auto',
        height: forceSameSize ? `${imageSize}%` : 'auto',
        maxWidth: forceSameSize ? `${imageSize}%` : '100%',
        maxHeight: forceSameSize ? `${imageSize}%` : '100%',
        objectFit: forceSameSize ? 'contain' : 'cover',
        borderRadius: `${borderRadius}px`,
        border: imageBorder?.enabled ? `${imageBorder.width}px solid ${imageBorder.color}` : undefined,
        boxShadow: imageDropShadow?.enabled ? 
            `${imageDropShadow.x}px ${imageDropShadow.y}px ${imageDropShadow.blur}px ${imageDropShadow.spread}px ${imageDropShadow.color}` : 
            undefined,
    };

    return (
        <AbsoluteFill style={{ opacity }}>
            {/* Question */}
            {showText && (
                <div style={{
                    position: 'absolute',
                    top: '5%',
                    left: '50%',
                    transform: 'translateX(-50%)',
                    backgroundColor,
                    padding: '10px 20px',
                    borderRadius: borderRadius,
                    boxShadow: shadow ? '0 2px 4px rgba(0,0,0,0.2)' : undefined,
                    fontSize: `${fontSize}px`,
                    fontFamily,
                    color: textColor,
                    textAlign: 'center',
                    zIndex: 10,
                }}>
                    {component.question}
                </div>
            )}

            {/* Images Container */}
            <div style={imageContainerStyle}>
                {/* Left/Top Image */}
                <div style={{
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    gap: '10px',
                    ...getAnimationStyle(frame, animation, false, component.durationInFrames),
                }}>
                    <img
                        src={component.leftOption.imageUrl}
                        style={commonImageStyle}
                        alt={component.leftOption.text}
                    />
                    {showText && (
                        <div style={{
                            backgroundColor,
                            padding: '5px 10px',
                            borderRadius: borderRadius,
                            boxShadow: shadow ? '0 2px 4px rgba(0,0,0,0.2)' : undefined,
                            fontSize: `${fontSize * 0.8}px`,
                            fontFamily,
                            color: textColor,
                            textAlign: 'center',
                        }}>
                            {component.leftOption.text}
                        </div>
                    )}
                </div>

                {/* Right/Bottom Image */}
                <div style={{
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    gap: '10px',
                    ...getAnimationStyle(frame, animation, true, component.durationInFrames),
                }}>
                    <img
                        src={component.rightOption.imageUrl}
                        style={commonImageStyle}
                        alt={component.rightOption.text}
                    />
                    {showText && (
                        <div style={{
                            backgroundColor,
                            padding: '5px 10px',
                            borderRadius: borderRadius,
                            boxShadow: shadow ? '0 2px 4px rgba(0,0,0,0.2)' : undefined,
                            fontSize: `${fontSize * 0.8}px`,
                            fontFamily,
                            color: textColor,
                            textAlign: 'center',
                        }}>
                            {component.rightOption.text}
                        </div>
                    )}
                </div>
            </div>
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\ComparisonSequence.tsx ---

import React from 'react';
import { AbsoluteFill } from 'remotion';
import { Comparison } from '../../types/quiz';

interface ComparisonSequenceProps {
    comparison: Comparison;
}

export const ComparisonSequence: React.FC<ComparisonSequenceProps> = ({ comparison }) => {
    return (
        <AbsoluteFill>
            {/* Component content */}
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\CountdownSequence.tsx ---

import React from 'react';
import { AbsoluteFill, useCurrentFrame } from 'remotion';
import { CountdownComponent } from '../../types/script';

interface CountdownSequenceProps {
    component: CountdownComponent;
}

export const CountdownSequence: React.FC<CountdownSequenceProps> = ({ component }) => {
    const frame = useCurrentFrame();
    const style = component.style || {};
    const position = style.position || { x: 0, y: 0 };

    // Calculate current number based on frame
    const from = component.from || 10;
    const framePerNumber = component.durationInFrames ? component.durationInFrames / from : 30;
    const currentNumber = Math.max(0, Math.ceil(from - frame / framePerNumber));

    return (
        <AbsoluteFill>
            <div style={{
                position: 'absolute',
                left: position.x,
                top: position.y,
                fontSize: style.fontSize || 80,
                fontFamily: style.fontFamily || 'Arial',
                color: style.color || 'white',
                textAlign: style.textAlign || 'center',
                width: style.position?.width || 300,
                fontWeight: 'bold',
                transform: 'translate(0, 0)', // Prevent any transform issues
            }}>
                {currentNumber}
            </div>
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\ImageComponent.tsx ---

import React from 'react';
import { AbsoluteFill } from 'remotion';
import { ImageComponent as ImageComponentType } from '../../types/script';

interface ImageComponentProps {
    component: ImageComponentType;
}

export const ImageComponent: React.FC<ImageComponentProps> = ({ component }) => {
    const {
        imageUrl,
        style = {}
    } = component;

    const {
        width = 400,
        height = 400,
        position = { x: 0, y: 0 },
        scale = 1,
        rotation = 0,
        opacity = 1,
        border = { enabled: false, color: '#000000', width: 2 },
        dropShadow = { enabled: false, color: '#000000', blur: 10, spread: 0, x: 5, y: 5 }
    } = style;

    // Calculate shadow styles if enabled
    const shadowStyle = dropShadow.enabled ? {
        filter: `drop-shadow(${dropShadow.x}px ${dropShadow.y}px ${dropShadow.blur}px ${dropShadow.color})`
    } : {};

    // Calculate border styles if enabled
    const borderStyle = border.enabled ? {
        border: `${border.width}px solid ${border.color}`
    } : {};

    return (
        <AbsoluteFill>
            <div
                style={{
                    position: 'absolute',
                    left: `${position.x}px`,
                    top: `${position.y}px`,
                    width: `${width}px`,
                    height: `${height}px`,
                    transform: `scale(${scale}) rotate(${rotation}deg)`,
                    opacity,
                    ...shadowStyle,
                    ...borderStyle,
                    overflow: 'hidden',
                }}
            >
                <img
                    src={imageUrl}
                    alt="Video component"
                    style={{
                        width: '100%',
                        height: '100%',
                        objectFit: 'cover',
                    }}
                />
            </div>
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\QuizVideo.tsx ---

import React from 'react';
import {
    AbsoluteFill,
    Audio,
    Sequence,
    useVideoConfig,
} from 'remotion';
import {QuizConfig} from '../../types/quiz';
import {ComparisonSequence} from './ComparisonSequence';

interface QuizVideoProps {
    quizConfig: QuizConfig;
}

export const QuizVideo: React.FC<QuizVideoProps> = ({quizConfig}) => {
    const {fps} = useVideoConfig();
    const SEQUENCE_DURATION = 5 * fps;

    // Handle empty state
    if (!quizConfig.comparisons.length) {
        return (
            <AbsoluteFill style={{
                backgroundColor: '#1a1a1a',
                display: 'flex',
                justifyContent: 'center',
                alignItems: 'center',
            }}>
                <h1 style={{color: 'white'}}>Add a comparison to start</h1>
            </AbsoluteFill>
        );
    }

    return (
        <AbsoluteFill style={{backgroundColor: '#1a1a1a'}}>
            {quizConfig.comparisons.map((comparison, index) => (
                <Sequence
                    key={comparison.id}
                    from={index * SEQUENCE_DURATION}
                    durationInFrames={SEQUENCE_DURATION}
                >
                    <ComparisonSequence comparison={comparison} />
                </Sequence>
            ))}
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\RemotionSubtitleCaption.tsx ---

import React, { useEffect } from 'react';
import { useCurrentFrame, useVideoConfig } from 'remotion';
import { SubtitleSequence } from 'remotion-subtitle';
import {
    BounceCaption,
    ColorfulCaption,
    ExplosiveCaption,
    FadeCaption,
    FireCaption,
    GlitchCaption,
    GlowingCaption,
    LightningCaption,
    NeonCaption,
    RotatingCaption,
    ShakeCaption,
    ThreeDishCaption,
    TiltShiftCaption,
    TypewriterCaption,
    WavingCaption,
    ZoomCaption,
} from 'remotion-subtitle';
import { TextStyle, WordTiming } from '../../types/script';

interface RemotionSubtitleCaptionProps {
    wordTimings: WordTiming[];
    style: TextStyle;
    startFrame: number;
}

const CAPTION_COMPONENTS = {
    bounce: BounceCaption,
    colorful: ColorfulCaption,
    explosive: ExplosiveCaption,
    fade: FadeCaption,
    fire: FireCaption,
    glitch: GlitchCaption,
    glowing: GlowingCaption,
    lightning: LightningCaption,
    neon: NeonCaption,
    rotating: RotatingCaption,
    shake: ShakeCaption,
    threeDish: ThreeDishCaption,
    tiltShift: TiltShiftCaption,
    typewriter: TypewriterCaption,
    waving: WavingCaption,
    zoom: ZoomCaption,
};

export const RemotionSubtitleCaption: React.FC<RemotionSubtitleCaptionProps> = (props) => {
    const { wordTimings, style, startFrame } = props;
    const frame = useCurrentFrame();
    const { fps } = useVideoConfig();
    const currentTime = frame / fps;
    const componentStartTime = startFrame / fps;

    // Enhanced debug logging
    const debugLog = (message: string, data?: any, trace: boolean = false, level: 'info' | 'warn' | 'error' = 'info') => {
        const timestamp = new Date().toISOString();
        const frameInfo = `[Frame: ${frame}]`;
        const componentInfo = `[RemotionSubtitleCaption]`;
        const propsSnapshot = JSON.stringify(props, null, 2);
        const callStack = new Error().stack;

        console.group(`${timestamp} ${frameInfo} ${componentInfo} ${message}`);
        console.log('Props Snapshot:', propsSnapshot);
        console.log('Current Frame:', frame);
        console.log('FPS:', fps);
        console.log('Current Time:', currentTime);
        console.log('Component Start Time:', componentStartTime);
        console.log('Data:', data);
        console.log('Call Stack:', callStack);
        if (trace) {
            console.trace('Detailed Stack Trace');
        }
        console.groupEnd();
    };

    // Log initial render
    debugLog('Component Initial Render', {
        hasWordTimings: !!wordTimings,
        wordTimingsCount: wordTimings.length,
        style,
        startFrame,
        currentTime,
        componentStartTime
    }, true);

    // Log component mount
    useEffect(() => {
        debugLog('Component Mounted', {
            wordTimingsCount: wordTimings.length,
            style,
            startFrame,
            currentTime,
            componentStartTime,
            mountTime: new Date().toISOString(),
        }, true);

        return () => {
            debugLog('Component Unmounting', {
                unmountTime: new Date().toISOString(),
                lastFrame: frame,
            }, true);
        };
    }, []);

    // Log every frame update
    useEffect(() => {
        const frameStartTime = performance.now();
        debugLog('Frame Update', {
            currentFrame: frame,
            currentTime,
            componentStartTime,
            activeWords: wordTimings.filter(timing => {
                const start = timing.start - componentStartTime;
                const end = timing.end - componentStartTime;
                return currentTime >= start && currentTime <= end;
            }).map(w => w.word)
        });
        const frameEndTime = performance.now();
        debugLog('Frame Update Complete', {
            frameDuration: frameEndTime - frameStartTime,
            frame,
        });
    }, [frame]);

    // Convert word timings to SRT format with logging
    debugLog('Converting word timings to SRT format', {
        wordTimings,
        componentStartTime
    });

    const srtContent = wordTimings
        .map((timing, index) => {
            const start = timing.start - componentStartTime;
            const end = timing.end - componentStartTime;
            const srtEntry = `${index + 1}\n${formatTime(start)} --> ${formatTime(end)}\n${timing.word}\n\n`;
            
            debugLog('Generated SRT entry:', {
                index,
                word: timing.word,
                originalStart: timing.start,
                originalEnd: timing.end,
                adjustedStart: start,
                adjustedEnd: end,
                srtEntry
            });

            return srtEntry;
        })
        .join('');

    // Get the appropriate caption component
    const CaptionComponent = style.captionStyle && CAPTION_COMPONENTS[style.captionStyle as keyof typeof CAPTION_COMPONENTS];
    
    debugLog('Caption component selection:', {
        requestedStyle: style.captionStyle,
        foundComponent: !!CaptionComponent,
        availableStyles: Object.keys(CAPTION_COMPONENTS)
    });

    if (!CaptionComponent) {
        debugLog('No caption component found for style', {
            style: style.captionStyle
        }, true);
        return null;
    }

    // Create subtitle sequence with logging
    debugLog('Creating subtitle sequence', {
        srtContent,
        style
    });

    const subtitles = new SubtitleSequence(srtContent);

    debugLog('Rendering subtitles', {
        currentFrame: frame,
        currentTime,
        style: {
            fontSize: style.fontSize || '24px',
            color: style.color || 'white',
            ...style,
        }
    }, true);

    return (
        <div style={{
            position: 'absolute',
            left: '50%',
            bottom: '10%',
            transform: 'translateX(-50%)',
            width: '80%',
            textAlign: 'center',
        }}>
            {debugLog('Rendering Subtitles', {
                currentTime,
                componentStartTime,
                activeWords: wordTimings.filter(timing => {
                    const start = timing.start - componentStartTime;
                    const end = timing.end - componentStartTime;
                    return currentTime >= start && currentTime <= end;
                }).map(w => w.word)
            })}
            {subtitles.getSequences(
                <CaptionComponent style={{
                    fontSize: style.fontSize || '24px',
                    color: style.color || 'white',
                    ...style,
                }} />,
                fps
            )}
        </div>
    );
};

// Helper function to format time in SRT format (HH:MM:SS,mmm)
function formatTime(seconds: number): string {
    const pad = (n: number, width: number) => String(n).padStart(width, '0');
    
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    const ms = Math.floor((seconds % 1) * 1000);
    
    return `${pad(hours, 2)}:${pad(minutes, 2)}:${pad(secs, 2)},${pad(ms, 3)}`;
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\ScriptVideo.tsx ---

import React, { useEffect, useState, useMemo } from 'react';
import { AbsoluteFill, Sequence, spring, useCurrentFrame, useVideoConfig, Audio } from 'remotion';
import { Script, TextComponent as TextComponentType, VoiceComponent as VoiceComponentType, AudioComponent as AudioComponentType } from '../../types/script';
import { CaptionRenderer } from './CaptionRenderer';
import { ComparisonComponent } from './ComparisonComponent';
import { VideoComponent } from './VideoComponent';
import { TextComponent } from './TextComponent';

interface Props {
    script?: Script;
}

const getAnimationStyle = (frame: number, fps: number, animation: string, direction: 'in' | 'out', timing: { start: number; end: number }) => {
    if (!animation) return {};

    const isOut = direction === 'out';
    const durationInFrames = timing.end - timing.start;
    const adjustedFrame = frame - timing.start;

    console.log(`Animation ${direction}:`, {
        frame,
        adjustedFrame,
        timing,
        durationInFrames,
    });

    // If we're not within the animation timeframe, return the final state
    if (adjustedFrame < 0) return isOut ? {} : { opacity: 0, transform: getInitialTransform(animation) };
    if (adjustedFrame > durationInFrames) return isOut ? { opacity: 0, transform: getFinalTransform(animation) } : {};

    switch (animation) {
        case 'slide-left': {
            const opacity = spring({
                frame: adjustedFrame,
                fps,
                from: isOut ? 1 : 0,
                to: isOut ? 0 : 1,
                durationInFrames,
            });

            const slideX = spring({
                frame: adjustedFrame,
                fps,
                from: isOut ? 0 : -200,
                to: isOut ? -200 : 0,
                durationInFrames,
                config: {
                    damping: 12,
                    mass: 0.5,
                },
            });

            return {
                opacity,
                transform: `translateX(${slideX}px)`,
            };
        }
        case 'slide-right': {
            const opacity = spring({
                frame: adjustedFrame,
                fps,
                from: isOut ? 1 : 0,
                to: isOut ? 0 : 1,
                durationInFrames,
            });

            const slideX = spring({
                frame: adjustedFrame,
                fps,
                from: isOut ? 0 : 200,
                to: isOut ? 200 : 0,
                durationInFrames,
                config: {
                    damping: 12,
                    mass: 0.5,
                },
            });

            return {
                opacity,
                transform: `translateX(${slideX}px)`,
            };
        }
        default:
            return {};
    }
};

// Helper functions to get initial and final transform states
const getInitialTransform = (animation: string) => {
    switch (animation) {
        case 'slide-left':
            return 'translateX(-200px)';
        case 'slide-right':
            return 'translateX(200px)';
        default:
            return 'none';
    }
};

const getFinalTransform = (animation: string) => {
    switch (animation) {
        case 'slide-left':
            return 'translateX(-200px)';
        case 'slide-right':
            return 'translateX(200px)';
        default:
            return 'none';
    }
};

const BACKGROUND_SERVICE_URL = 'http://localhost:3002';

export const ScriptVideo: React.FC<Script> = (props) => {
    console.log('ScriptVideo received props:', props);
    
    if (!props || !props.components) {
        console.error('Invalid script data:', props);
        return (
            <AbsoluteFill style={{ backgroundColor: 'black', color: 'white' }}>
                <h1>Error: Invalid script data</h1>
            </AbsoluteFill>
        );
    }

    // Store the background URL in state to prevent re-fetching
    const [bgUrl, setBgUrl] = useState<string | null>(null);

    useEffect(() => {
        if (props.settings?.background?.type === 'image' && props.settings.background.url) {
            // If it's already a full URL, or we want to prefix a local service
            let finalUrl = props.settings.background.url;
            if (!/^https?:\/\//.test(finalUrl)) {
                // Not a fully qualified URL, prefix the background service
                finalUrl = `${BACKGROUND_SERVICE_URL}/backgrounds/${encodeURIComponent(finalUrl)}`;
            }
            setBgUrl(finalUrl);
        } else if (props.settings?.background?.type === 'video' && props.settings.background.url) {
            // Handle video backgrounds similarly
            let finalUrl = props.settings.background.url;
            if (!/^https?:\/\//.test(finalUrl)) {
                finalUrl = `${BACKGROUND_SERVICE_URL}/backgrounds/${encodeURIComponent(finalUrl)}`;
            }
            setBgUrl(finalUrl);
        } else {
            setBgUrl(null);
        }
    }, [props.settings?.background]);

    // Memoize the background style to prevent unnecessary re-renders
    const backgroundStyle = useMemo(() => {
        if (!bgUrl) {
            return {
                backgroundColor: 'black',
            };
        }

        if (props.settings?.background?.type === 'video') {
            return {
                backgroundColor: 'black',
            };
        }

        return {
            backgroundImage: `url("${bgUrl}")`,
            backgroundSize: 'cover',
            backgroundPosition: 'center',
            backgroundRepeat: 'no-repeat',
        };
    }, [bgUrl, props.settings?.background?.type]);

    useEffect(() => {
        const loadFonts = async () => {
            try {
                // Get font dictionary from font service
                const response = await fetch('http://localhost:3003/fonts/dictionary');
                if (!response.ok) throw new Error('Failed to load font dictionary');
                const fontDict = await response.json();
                console.log('ScriptVideo: Font dictionary:', fontDict);

                // Get unique font families used in components
                const usedFonts = new Set<string>();
                props.components.forEach(comp => {
                    if (comp.type === 'text' || comp.type === 'title') {
                        const textComp = comp as { style?: { fontFamily?: string } };
                        if (textComp.style?.fontFamily) {
                            usedFonts.add(textComp.style.fontFamily);
                            console.log('ScriptVideo: Found font:', textComp.style.fontFamily);
                        }
                    }
                });

                // Load each used font
                const fontLoadPromises = Array.from(usedFonts).map(async fontName => {
                    const fontData = fontDict[fontName];
                    if (fontData?.url) {
                        try {
                            console.log('ScriptVideo: Loading font:', fontName, 'from URL:', fontData.url);
                            const font = new FontFace(fontName, `url(${fontData.url})`);
                            const loadedFont = await font.load();
                            document.fonts.add(loadedFont);
                            console.log('ScriptVideo: Successfully loaded font:', fontName);
                            return true;
                        } catch (error) {
                            console.error('ScriptVideo: Error loading font:', fontName, error);
                            return false;
                        }
                    }
                    return false;
                });

                await Promise.all(fontLoadPromises);
                console.log('ScriptVideo: All fonts loaded');
            } catch (error) {
                console.error('ScriptVideo: Error loading fonts:', error);
            }
        };

        loadFonts();
    }, [props.components]);

    return (
        <AbsoluteFill style={backgroundStyle}>
            {props.settings?.background?.type === 'video' && bgUrl && (
                <video
                    src={bgUrl}
                    style={{
                        position: 'absolute',
                        width: '100%',
                        height: '100%',
                        objectFit: 'cover',
                    }}
                    autoPlay
                    loop
                    muted
                />
            )}
            {props.components.map((component) => {
                const key = `${component.id}-${component.startFrame}-${component.durationInFrames}`;
                return (
                    <Sequence
                        key={key}
                        from={component.startFrame || 0}
                        durationInFrames={component.durationInFrames || 150}
                    >
                        {component.type === 'text' && (
                            <TextComponent component={component as TextComponentType} />
                        )}
                        {component.type === 'comparison' && (
                            <ComparisonComponent component={component as any} />
                        )}
                        {component.type === 'video' && (
                            <VideoComponent component={component as any} />
                        )}
                        {component.type === 'voice' && (
                            <VoiceComponent component={component as VoiceComponentType} />
                        )}
                        {component.type === 'audio' && (
                            <AudioEffectComponent component={component as AudioComponentType} />
                        )}
                    </Sequence>
                );
            })}
        </AbsoluteFill>
    );
};

const TextComponent: React.FC<{ component: TextComponentType }> = ({ component }) => {
    const frame = useCurrentFrame();
    const { fps } = useVideoConfig();
    
    const animationIn = component.style?.animation?.in?.type || '';
    const animationOut = component.style?.animation?.out?.type || '';
    
    // Calculate animation timings
    const totalDuration = component.durationInFrames || 150;
    
    // For entrance animation
    const inStartFrame = component.style?.animation?.in?.startFrame || 0;
    const inEndFrame = component.style?.animation?.in?.endFrame || 30;
    const inTiming = {
        start: inStartFrame,
        end: inEndFrame,
    };
    
    // For exit animation
    const outStartFrame = totalDuration - (component.style?.animation?.out?.startFrame || 30);
    const outEndFrame = totalDuration - (component.style?.animation?.out?.endFrame || 0);
    const outTiming = {
        start: outStartFrame,
        end: outEndFrame,
    };
    
    console.log('Animation frames:', {
        frame,
        totalDuration,
        in: { start: inStartFrame, end: inEndFrame },
        out: { start: outStartFrame, end: outEndFrame },
    });
    
    const animationStyleIn = getAnimationStyle(frame, fps, animationIn, 'in', inTiming);
    const animationStyleOut = getAnimationStyle(frame, fps, animationOut, 'out', outTiming);
    
    return (
        <div style={{
            position: 'absolute',
            left: component.style?.position?.x || 0,
            top: component.style?.position?.y || 0,
            width: 'auto',
            display: 'inline-block',
            ...(component.style?.blockStyle?.enabled ? {
                backgroundColor: component.style.backgroundColor || '#FFFFFF',
                padding: '20px 40px',
                borderRadius: '15px',
                boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
                minWidth: '33%',
            } : {}),
            textAlign: component.style?.textAlign || 'center',
            color: component.style?.color || 'white',
            fontSize: component.style?.fontSize || 40,
            fontFamily: component.style?.fontFamily || 'Arial',
            fontWeight: component.style?.fontWeight || 'normal',
            textTransform: component.style?.textTransform || 'none',
            ...animationStyleIn,
            ...animationStyleOut,
            ...(component.style?.outline?.enabled ? {
                textShadow: `
                    -${component.style.outline.width}px -${component.style.outline.width}px 0 ${component.style.outline.color},
                    ${component.style.outline.width}px -${component.style.outline.width}px 0 ${component.style.outline.color},
                    -${component.style.outline.width}px ${component.style.outline.width}px 0 ${component.style.outline.color},
                    ${component.style.outline.width}px ${component.style.outline.width}px 0 ${component.style.outline.color}
                `
            } : {})
        }}>
            {component.text}
        </div>
    );
};

const VoiceComponent: React.FC<{ component: VoiceComponentType }> = ({ component }) => {
    if (!component.audioUrl) {
        console.warn('VoiceComponent: No audio URL provided');
        return null;
    }

    // Calculate volume based on style settings
    const volume = component.style?.volume ?? 1;

    // Calculate start and end times if specified
    const startTime = component.style?.startTime ?? 0;
    const duration = component.style?.duration;

    return (
        <>
            <Audio
                src={component.audioUrl}
                volume={volume}
                startFrom={startTime}
                endAt={duration ? startTime + duration : undefined}
            />
            {component.showCaptions && component.wordTimings && (
                <CaptionRenderer
                    wordTimings={component.wordTimings}
                    style={component.captionStyle || {
                        fontSize: 24,
                        color: '#ffffff',
                        backgroundColor: 'rgba(0, 0, 0, 0.7)',
                        position: 'bottom',
                        wordWindow: 1
                    }}
                />
            )}
        </>
    );
};

const AudioEffectComponent: React.FC<{ component: AudioComponentType }> = ({ component }) => {
    if (!component.audioUrl) {
        console.warn('AudioEffectComponent: No audio URL provided');
        return null;
    }

    // Get audio settings from style
    const volume = component.style?.volume ?? 1;
    const startTime = component.style?.startTime ?? 0;
    const duration = component.style?.duration;
    const loop = component.style?.loop ?? false;

    // Handle both string URLs and audio object URLs
    const audioSrc = typeof component.audioUrl === 'string' 
        ? component.audioUrl 
        : component.audioUrl.url;

    return (
        <Audio
            src={audioSrc}
            volume={volume}
            startFrom={startTime}
            endAt={duration ? startTime + duration : undefined}
            loop={loop}
        />
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\TextComponent.tsx ---

import React from 'react';
import { useCurrentFrame, useVideoConfig } from 'remotion';
import { TextComponent as TextComponentType } from '../../types/script';
import { getAnimationStyle } from '../../utils/animation';

interface TextComponentProps {
    component: TextComponentType;
}

export const TextComponent: React.FC<TextComponentProps> = ({ component }) => {
    const frame = useCurrentFrame();
    const { fps } = useVideoConfig();

    const style = component.style || {};
    const animationStyle = getAnimationStyle(frame, fps, style.animation);

    return (
        <div
            style={{
                position: 'absolute',
                left: '50%',
                top: '50%',
                transform: `translate(-50%, -50%)`,
                fontSize: style.fontSize || 32,
                fontFamily: style.fontFamily || 'Arial',
                color: style.color || '#ffffff',
                textAlign: style.textAlign || 'center',
                fontWeight: style.fontWeight || 'normal',
                lineHeight: style.lineHeight || 1.5,
                backgroundColor: style.backgroundColor,
                padding: style.padding,
                borderRadius: style.borderRadius,
                ...animationStyle,
            }}
        >
            {component.text}
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\TextSequence.tsx ---

import React from 'react';
import { AbsoluteFill } from 'remotion';
import { TextComponent } from '../../types/script';

interface TextSequenceProps {
    component: TextComponent;
}

export const TextSequence: React.FC<TextSequenceProps> = ({ component }) => {
    const style = component.style || {};
    const position = style.position || { x: 0, y: 0 };

    // Format text based on wordsPerLine
    const formatText = (text: string) => {
        if (!text || !style.wordsPerLine || style.wordsPerLine <= 0) {
            return text;
        }

        // Remove existing line breaks and extra spaces
        const cleanText = text.replace(/[\n\r]+/g, ' ').replace(/\s+/g, ' ').trim();
        const words = cleanText.split(' ');
        const lines = [];
        
        // Group words into lines
        for (let i = 0; i < words.length; i += style.wordsPerLine) {
            const line = words.slice(i, i + style.wordsPerLine).join(' ');
            if (line) lines.push(line);
        }
        
        // Join lines with newlines
        return lines.join('\n');
    };

    // Create text shadow for outline effect
    const getTextShadow = () => {
        if (!style.outline?.enabled) return 'none';

        const width = style.outline.width || 2;
        const color = style.outline.color || '#000000';
        const shadows = [];

        // Generate outline effect using multiple text shadows
        for (let x = -width; x <= width; x++) {
            for (let y = -width; y <= width; y++) {
                if (Math.abs(x) === width || Math.abs(y) === width) {
                    shadows.push(`${x}px ${y}px 0 ${color}`);
                }
            }
        }

        return shadows.join(', ');
    };

    return (
        <AbsoluteFill>
            <div style={{
                position: 'absolute',
                left: position.x,
                top: position.y,
                fontSize: style.fontSize || 40,
                fontFamily: style.fontFamily || 'Arial',
                color: style.color || 'white',
                textAlign: style.textAlign || 'center',
                width: '100%',
                maxWidth: '80%',
                margin: '0 auto',
                transform: 'translate(0, 0)', // Prevent any transform issues
                whiteSpace: 'pre-wrap', // Preserve line breaks
                fontWeight: style.fontWeight || 'normal',
                lineHeight: style.lineHeight || 1.5,
                textShadow: getTextShadow(),
            }}>
                {formatText(component.text)}
            </div>
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\TikTokCaptions.tsx ---

import React from 'react';
import {
    AbsoluteFill,
    useCurrentFrame,
    useVideoConfig,
    spring,
    interpolate,
} from 'remotion';
import { TikTokPage } from '../../types/script';

interface TikTokCaptionsProps {
    pages: TikTokPage[];
    style?: {
        backgroundColor?: string;
        textColor?: string;
        position?: 'top' | 'bottom' | 'middle';
    };
}

export const TikTokCaptions: React.FC<TikTokCaptionsProps> = ({
    pages,
    style = {},
}) => {
    const frame = useCurrentFrame();
    const { fps } = useVideoConfig();
    const currentTimeMs = (frame / fps) * 1000;

    const currentPage = pages.find((page, index) => {
        const nextPage = pages[index + 1];
        return (
            currentTimeMs >= page.startMs &&
            (!nextPage || currentTimeMs < nextPage.startMs)
        );
    });

    if (!currentPage) return null;

    const pageProgress = spring({
        frame,
        fps,
        config: {
            damping: 200,
        },
    });

    const getTokenOpacity = (token: TikTokPage['tokens'][0]) => {
        return interpolate(
            currentTimeMs,
            [token.fromMs, token.fromMs + 100, token.toMs - 100, token.toMs],
            [0, 1, 1, 0],
            {
                extrapolateLeft: 'clamp',
                extrapolateRight: 'clamp',
            }
        );
    };

    return (
        <AbsoluteFill
            style={{
                justifyContent: style.position === 'top' ? 'flex-start' : 
                    style.position === 'bottom' ? 'flex-end' : 'center',
                padding: '40px',
            }}
        >
            <div
                style={{
                    backgroundColor: style.backgroundColor || 'rgba(0, 0, 0, 0.8)',
                    color: style.textColor || 'white',
                    padding: '20px',
                    borderRadius: '12px',
                    fontSize: '32px',
                    fontWeight: 'bold',
                    textAlign: 'center',
                    opacity: pageProgress,
                    whiteSpace: 'pre',
                    display: 'inline-block',
                    margin: '0 auto',
                }}
            >
                {currentPage.tokens.map((token, i) => (
                    <span
                        key={i}
                        style={{
                            opacity: getTokenOpacity(token),
                            display: 'inline-block',
                        }}
                    >
                        {token.text}
                    </span>
                ))}
            </div>
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\TitleSequence.tsx ---

import React from 'react';
import { AbsoluteFill } from 'remotion';
import { TitleComponent } from '../../types/script';

interface TitleSequenceProps {
    component: TitleComponent;
}

export const TitleSequence: React.FC<TitleSequenceProps> = ({ component }) => {
    const style = component.style || {};
    const position = style.position || { x: 0, y: 0 };

    return (
        <AbsoluteFill>
            <div style={{
                position: 'absolute',
                left: position.x,
                top: position.y,
                fontSize: style.fontSize || 60,
                fontFamily: style.fontFamily || 'Arial',
                color: style.color || 'white',
                textAlign: style.textAlign || 'center',
                width: style.position?.width || 300,
                fontWeight: 'bold',
                transform: 'translate(0, 0)', // Prevent any transform issues
            }}>
                {component.text}
            </div>
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\TransitionSequence.tsx ---

import React from 'react';
import { AbsoluteFill } from 'remotion';
import { TransitionComponent } from '../../types/script';

interface TransitionSequenceProps {
    component: TransitionComponent;
}

export const TransitionSequence: React.FC<TransitionSequenceProps> = ({ component }) => {
    return (
        <AbsoluteFill style={{
            backgroundColor: 'black',
        }} />
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\VideoComponent.tsx ---

import React, { useEffect, useRef, useState } from 'react';
import { useCurrentFrame, useVideoConfig } from 'remotion';
import { VideoComponent as VideoComponentType } from '../../types/script';
import { getAnimationStyle } from '../../utils/animation';

interface VideoComponentProps {
    component: VideoComponentType;
}

export const VideoComponent: React.FC<VideoComponentProps> = ({ component }) => {
    const frame = useCurrentFrame();
    const { fps } = useVideoConfig();
    const videoRef = useRef<HTMLVideoElement>(null);
    const canvasRef = useRef<HTMLCanvasElement>(null);
    const animationFrameRef = useRef<number | undefined>(undefined);
    const [proxyUrl, setProxyUrl] = useState<string | null>(null);
    const [videoLoaded, setVideoLoaded] = useState(false);
    const [videoDuration, setVideoDuration] = useState(0);

    const style = component.style || {};
    const animationStyle = getAnimationStyle(frame, fps, style.animation);

    // Calculate current video time based on frame
    const videoTime = (frame / fps) + (style.startTime || 0);

    useEffect(() => {
        const proxyVideo = async () => {
            try {
                console.log('Proxying video:', component.videoUrl);
                const response = await fetch('http://localhost:3005/proxy_video', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ url: component.videoUrl }),
                });

                if (!response.ok) {
                    throw new Error('Failed to proxy video');
                }

                const data = await response.json();
                console.log('Received proxy URL:', data.url);
                setProxyUrl(data.url);
            } catch (error) {
                console.error('Error proxying video:', error);
            }
        };

        if (component.videoUrl) {
            proxyVideo();
        }

        return () => {
            setProxyUrl(null);
            setVideoLoaded(false);
        };
    }, [component.videoUrl]);

    // Sync video time with timeline
    useEffect(() => {
        const video = videoRef.current;
        if (!video || !videoLoaded) return;

        // Update video time
        if (Math.abs(video.currentTime - videoTime) > 0.1) {
            video.currentTime = videoTime;
        }

        // Update component duration when video metadata is loaded
        if (videoDuration === 0 && video.duration) {
            setVideoDuration(video.duration);
            // If this is a new video, update the component's duration
            if (!component.style?.duration) {
                const durationInFrames = Math.ceil(video.duration * fps);
                // You'll need to implement this update function in your state management
                // updateComponentDuration(component.id, durationInFrames);
            }
        }
    }, [frame, fps, videoLoaded, videoTime, videoDuration]);

    useEffect(() => {
        if (!videoRef.current || !canvasRef.current || !style.chromakey?.enabled || !proxyUrl || !videoLoaded) {
            console.log('Skipping chromakey setup. Conditions:', {
                hasVideoRef: !!videoRef.current,
                hasCanvasRef: !!canvasRef.current,
                chromakeyEnabled: style.chromakey?.enabled,
                hasProxyUrl: !!proxyUrl,
                videoLoaded
            });
            return;
        }

        console.log('Setting up chromakey effect with settings:', style.chromakey);

        const video = videoRef.current;
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        if (!ctx) {
            console.error('Failed to get canvas context');
            return;
        }

        const updateCanvasSize = () => {
            const newWidth = video.videoWidth || video.clientWidth;
            const newHeight = video.videoHeight || video.clientHeight;
            console.log('Updating canvas size:', { width: newWidth, height: newHeight });
            canvas.width = newWidth;
            canvas.height = newHeight;
        };

        const processFrame = () => {
            try {
                // Only process frame if video is at the correct time
                if (Math.abs(video.currentTime - videoTime) <= 0.1) {
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    
                    if (style.chromakey?.enabled) {
                        try {
                            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            const data = imageData.data;

                            const keyColor = style.chromakey.color || '#00ff00';
                            const r = parseInt(keyColor.slice(1, 3), 16);
                            const g = parseInt(keyColor.slice(3, 5), 16);
                            const b = parseInt(keyColor.slice(5, 7), 16);

                            const similarity = (style.chromakey.similarity || 0.4) * 255;
                            const smoothness = style.chromakey.smoothness || 0.1;

                            for (let i = 0; i < data.length; i += 4) {
                                const pixelR = data[i];
                                const pixelG = data[i + 1];
                                const pixelB = data[i + 2];

                                const diff = Math.sqrt(
                                    Math.pow(pixelR - r, 2) * 0.3 +
                                    Math.pow(pixelG - g, 2) * 0.59 +
                                    Math.pow(pixelB - b, 2) * 0.11
                                );

                                if (diff < similarity) {
                                    const alpha = Math.max(0, diff / (similarity * smoothness));
                                    data[i + 3] = Math.min(255, alpha * 255);
                                }
                            }

                            ctx.putImageData(imageData, 0, 0);
                        } catch (error) {
                            console.error('Error processing chromakey:', error);
                        }
                    }
                }

                // Request next frame
                animationFrameRef.current = requestAnimationFrame(processFrame);
            } catch (error) {
                console.error('Error processing frame:', error);
            }
        };

        updateCanvasSize();
        processFrame();

        return () => {
            if (animationFrameRef.current) {
                cancelAnimationFrame(animationFrameRef.current);
            }
        };
    }, [style.chromakey, proxyUrl, videoLoaded, videoTime]);

    const containerStyle: React.CSSProperties = {
        position: 'absolute',
        width: `${style.width || 100}%`,
        height: `${style.height || 100}%`,
        left: `${style.position?.x || 0}%`,
        top: `${style.position?.y || 0}%`,
        transform: `translate(-50%, -50%) scale(${style.scale || 1}) rotate(${style.rotation || 0}deg)`,
        opacity: style.opacity ?? 1,
        ...animationStyle,
    };

    if (!proxyUrl) {
        return <div style={containerStyle}>Loading video...</div>;
    }

    if (style.chromakey?.enabled) {
        return (
            <div style={containerStyle}>
                <video
                    ref={videoRef}
                    src={proxyUrl}
                    style={{ display: 'none' }}
                    autoPlay={false}
                    loop={false}
                    muted
                    playsInline
                    crossOrigin="anonymous"
                    onLoadedData={() => {
                        console.log('Video loaded');
                        setVideoLoaded(true);
                    }}
                />
                <canvas
                    ref={canvasRef}
                    style={{
                        width: '100%',
                        height: '100%',
                        objectFit: 'contain',
                    }}
                />
            </div>
        );
    }

    return (
        <div style={containerStyle}>
            <video
                ref={videoRef}
                src={proxyUrl}
                style={{
                    width: '100%',
                    height: '100%',
                    objectFit: 'contain',
                }}
                autoPlay={false}
                loop={false}
                muted
                playsInline
                crossOrigin="anonymous"
                onLoadedData={() => setVideoLoaded(true)}
            />
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\VideoPositioningScreen.tsx ---

import React from 'react';
import { VideoComponent } from '../../types/script';
import { theme } from '../../styles/theme';

interface VideoPositioningScreenProps {
    component: VideoComponent;
    onChange: (component: VideoComponent) => void;
}

export const VideoPositioningScreen: React.FC<VideoPositioningScreenProps> = ({ component, onChange }) => {
    const handlePositionChange = (x: number, y: number) => {
        onChange({
            ...component,
            style: {
                ...component.style,
                position: { x, y }
            }
        });
    };

    const handleSizeChange = (width: number, height: number) => {
        onChange({
            ...component,
            style: {
                ...component.style,
                width,
                height
            }
        });
    };

    const handleTimeChange = (startTime: number, duration: number) => {
        onChange({
            ...component,
            style: {
                ...component.style,
                startTime,
                duration
            }
        });
    };

    return (
        <div style={styles.container}>
            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Position</h3>
                <div style={styles.inputGroup}>
                    <label style={styles.label}>X Position (%)</label>
                    <input
                        type="number"
                        value={component.style?.position?.x || 0}
                        onChange={(e) => handlePositionChange(Number(e.target.value), component.style?.position?.y || 0)}
                        style={styles.input}
                        min={-100}
                        max={100}
                        step={1}
                    />
                </div>
                <div style={styles.inputGroup}>
                    <label style={styles.label}>Y Position (%)</label>
                    <input
                        type="number"
                        value={component.style?.position?.y || 0}
                        onChange={(e) => handlePositionChange(component.style?.position?.x || 0, Number(e.target.value))}
                        style={styles.input}
                        min={-100}
                        max={100}
                        step={1}
                    />
                </div>
            </div>

            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Size</h3>
                <div style={styles.inputGroup}>
                    <label style={styles.label}>Width (%)</label>
                    <input
                        type="number"
                        value={component.style?.width || 100}
                        onChange={(e) => handleSizeChange(Number(e.target.value), component.style?.height || 100)}
                        style={styles.input}
                        min={1}
                        max={500}
                        step={1}
                    />
                </div>
                <div style={styles.inputGroup}>
                    <label style={styles.label}>Height (%)</label>
                    <input
                        type="number"
                        value={component.style?.height || 100}
                        onChange={(e) => handleSizeChange(component.style?.width || 100, Number(e.target.value))}
                        style={styles.input}
                        min={1}
                        max={500}
                        step={1}
                    />
                </div>
            </div>

            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Time Control</h3>
                <div style={styles.inputGroup}>
                    <label style={styles.label}>Start Time (seconds)</label>
                    <input
                        type="number"
                        value={component.style?.startTime || 0}
                        onChange={(e) => handleTimeChange(Number(e.target.value), component.style?.duration || 0)}
                        style={styles.input}
                        min={0}
                        step={0.1}
                    />
                </div>
                <div style={styles.inputGroup}>
                    <label style={styles.label}>Duration (seconds)</label>
                    <input
                        type="number"
                        value={component.style?.duration || 0}
                        onChange={(e) => handleTimeChange(component.style?.startTime || 0, Number(e.target.value))}
                        style={styles.input}
                        min={0.1}
                        step={0.1}
                    />
                </div>
            </div>
        </div>
    );
};

const styles = {
    container: {
        padding: '1rem',
        backgroundColor: theme.backgroundLight,
        borderRadius: '8px',
        display: 'flex',
        flexDirection: 'column' as const,
        gap: '1rem',
    },
    section: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: '0.5rem',
    },
    sectionTitle: {
        margin: 0,
        color: theme.textPrimary,
        fontSize: '1rem',
        fontWeight: 600,
    },
    inputGroup: {
        display: 'flex',
        alignItems: 'center',
        gap: '0.5rem',
    },
    label: {
        color: theme.textSecondary,
        fontSize: '0.9rem',
        minWidth: '120px',
    },
    input: {
        padding: '0.25rem 0.5rem',
        borderRadius: '4px',
        border: `1px solid ${theme.borderColor}`,
        backgroundColor: theme.backgroundDark,
        color: theme.textPrimary,
        width: '80px',
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\common\ColorPicker.tsx ---

import React from 'react';
import { theme } from '../../styles/theme';

interface ColorPickerProps {
    label: string;
    color: string;
    onChange: (color: string) => void;
}

export const ColorPicker: React.FC<ColorPickerProps> = ({
    label,
    color,
    onChange,
}) => {
    return (
        <div style={styles.container}>
            <label style={styles.label}>{label}</label>
            <div style={styles.inputContainer}>
                <input
                    type="color"
                    value={color}
                    onChange={(e) => onChange(e.target.value)}
                    style={styles.colorInput}
                />
                <input
                    type="text"
                    value={color}
                    onChange={(e) => onChange(e.target.value)}
                    style={styles.textInput}
                />
            </div>
        </div>
    );
};

const styles = {
    container: {
        marginBottom: theme.spacing.sm,
    },
    label: {
        display: 'block',
        marginBottom: theme.spacing.xs,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
    },
    inputContainer: {
        display: 'flex',
        gap: theme.spacing.sm,
        alignItems: 'center',
    },
    colorInput: {
        width: '40px',
        height: '40px',
        padding: 0,
        border: `1px solid ${theme.colors.border}`,
        borderRadius: theme.borderRadius.sm,
        cursor: 'pointer',
    },
    textInput: {
        flex: 1,
        padding: theme.spacing.sm,
        backgroundColor: theme.colors.background.tertiary,
        border: `1px solid ${theme.colors.border}`,
        borderRadius: theme.borderRadius.sm,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\common\IconButton.tsx ---

import React, { useState } from 'react';
import { theme } from '../../styles/theme';

interface IconButtonProps {
    icon: string;
    onClick: () => void;
    tooltip?: string;
    disabled?: boolean;
    size?: 'sm' | 'md' | 'lg';
    variant?: 'primary' | 'secondary' | 'ghost';
}

export const IconButton: React.FC<IconButtonProps> = ({
    icon,
    onClick,
    tooltip,
    disabled = false,
    size = 'md',
    variant = 'ghost',
}) => {
    const [isHovered, setIsHovered] = useState(false);

    const sizeMap = {
        sm: {
            padding: theme.spacing.xs,
            fontSize: theme.fontSizes.sm,
        },
        md: {
            padding: theme.spacing.sm,
            fontSize: theme.fontSizes.md,
        },
        lg: {
            padding: theme.spacing.md,
            fontSize: theme.fontSizes.lg,
        },
    };

    const variantMap = {
        primary: {
            backgroundColor: theme.colors.primary,
            color: theme.colors.text.primary,
            hoverBg: theme.colors.accent.red,
        },
        secondary: {
            backgroundColor: theme.colors.background.tertiary,
            color: theme.colors.text.primary,
            hoverBg: theme.colors.background.secondary,
        },
        ghost: {
            backgroundColor: 'transparent',
            color: theme.colors.text.primary,
            hoverBg: theme.colors.background.tertiary,
        },
    };

    const currentVariant = variantMap[variant];

    return (
        <button
            onClick={onClick}
            disabled={disabled}
            title={tooltip}
            onMouseEnter={() => setIsHovered(true)}
            onMouseLeave={() => setIsHovered(false)}
            style={{
                border: 'none',
                borderRadius: theme.borderRadius.md,
                cursor: disabled ? 'not-allowed' : 'pointer',
                opacity: disabled ? 0.5 : 1,
                transition: theme.transitions.fast,
                backgroundColor: isHovered && !disabled ? currentVariant.hoverBg : currentVariant.backgroundColor,
                color: currentVariant.color,
                ...sizeMap[size],
                display: 'inline-flex',
                alignItems: 'center',
                justifyContent: 'center',
                minWidth: sizeMap[size].fontSize,
                minHeight: sizeMap[size].fontSize,
                padding: sizeMap[size].padding,
                outline: 'none',
                boxShadow: isHovered && !disabled ? theme.shadows.sm : 'none',
            }}
        >
            {icon}
        </button>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\common\Modal.tsx ---

import React from 'react';
import { theme } from '../../styles/theme';

interface ModalProps {
    isOpen: boolean;
    onClose: () => void;
    title: React.ReactNode;
    children: React.ReactNode;
}

export const Modal: React.FC<ModalProps> = ({ isOpen, onClose, title, children }) => {
    if (!isOpen) return null;

    return (
        <div style={{
            position: 'fixed',
            top: '48px', // Header height
            left: 0,
            width: '75%', // Match the timeline section width
            height: 'calc(100vh - 48px)',
            backgroundColor: 'rgba(0, 0, 0, 0.75)',
            display: 'flex',
            justifyContent: 'flex-start',
            alignItems: 'center',
            zIndex: 1000,
            backdropFilter: 'blur(4px)',
            padding: theme.spacing.xl,
        }}>
            <div style={{
                backgroundColor: theme.colors.background.primary,
                borderRadius: theme.borderRadius.lg,
                border: `1px solid ${theme.colors.border}`,
                boxShadow: '0 8px 32px rgba(0, 0, 0, 0.4)',
                width: '90%',
                maxWidth: '800px',
                maxHeight: '90vh',
                display: 'flex',
                flexDirection: 'column',
                overflow: 'hidden',
                marginLeft: theme.spacing.xl,
            }}>
                {/* Header */}
                <div style={{
                    padding: theme.spacing.lg,
                    borderBottom: `1px solid ${theme.colors.border}`,
                    backgroundColor: theme.colors.background.secondary,
                    position: 'relative',
                }}>
                    <button
                        onClick={onClose}
                        style={{
                            position: 'absolute',
                            top: '50%',
                            right: theme.spacing.md,
                            transform: 'translateY(-50%)',
                            background: 'none',
                            border: 'none',
                            color: theme.colors.text.secondary,
                            fontSize: '24px',
                            cursor: 'pointer',
                            width: '32px',
                            height: '32px',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            borderRadius: theme.borderRadius.sm,
                            transition: 'all 0.2s ease',
                        }}
                        onMouseEnter={(e) => {
                            e.currentTarget.style.backgroundColor = theme.colors.background.tertiary;
                            e.currentTarget.style.color = theme.colors.text.primary;
                        }}
                        onMouseLeave={(e) => {
                            e.currentTarget.style.backgroundColor = 'transparent';
                            e.currentTarget.style.color = theme.colors.text.secondary;
                        }}
                    >
                        √ó
                    </button>
                    <div style={{ paddingRight: '32px' }}>
                        {title}
                    </div>
                </div>

                {/* Content */}
                <div style={{
                    flex: 1,
                    overflow: 'auto',
                    padding: theme.spacing.lg,
                }}>
                    {children}
                </div>
            </div>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\common\Slider.tsx ---

import React from 'react';
import { theme } from '../../styles/theme';

interface SliderProps {
    label: string;
    value: number;
    onChange: (value: number) => void;
    min: number;
    max: number;
    step?: number;
}

export const Slider: React.FC<SliderProps> = ({
    label,
    value,
    onChange,
    min,
    max,
    step = 1,
}) => {
    return (
        <div style={styles.container}>
            <div style={styles.header}>
                <label style={styles.label}>{label}</label>
                <input
                    type="number"
                    value={value}
                    onChange={(e) => onChange(Number(e.target.value))}
                    min={min}
                    max={max}
                    step={step}
                    style={styles.numberInput}
                />
            </div>
            <input
                type="range"
                value={value}
                onChange={(e) => onChange(Number(e.target.value))}
                min={min}
                max={max}
                step={step}
                style={styles.slider}
            />
        </div>
    );
};

const styles = {
    container: {
        marginBottom: theme.spacing.sm,
    },
    header: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: theme.spacing.xs,
    },
    label: {
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
    },
    numberInput: {
        width: '60px',
        padding: theme.spacing.xs,
        backgroundColor: theme.colors.background.tertiary,
        border: `1px solid ${theme.colors.border}`,
        borderRadius: theme.borderRadius.sm,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
        textAlign: 'right' as const,
    },
    slider: {
        width: '100%',
        height: '2px',
        WebkitAppearance: 'none',
        background: theme.colors.primary,
        outline: 'none',
        opacity: 0.7,
        transition: 'opacity 0.2s',
        cursor: 'pointer',
        '&:hover': {
            opacity: 1,
        },
        '&::-webkit-slider-thumb': {
            WebkitAppearance: 'none',
            appearance: 'none',
            width: '16px',
            height: '16px',
            background: theme.colors.primary,
            borderRadius: '50%',
            cursor: 'pointer',
        },
        '&::-moz-range-thumb': {
            width: '16px',
            height: '16px',
            background: theme.colors.primary,
            borderRadius: '50%',
            cursor: 'pointer',
        },
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\common\Switch.tsx ---

import React from 'react';
import { theme } from '../../styles/theme';

interface SwitchProps {
    label: string;
    checked: boolean;
    onChange: (checked: boolean) => void;
}

export const Switch: React.FC<SwitchProps> = ({
    label,
    checked,
    onChange,
}) => {
    return (
        <div style={styles.container}>
            <label style={styles.label}>
                <input
                    type="checkbox"
                    checked={checked}
                    onChange={(e) => onChange(e.target.checked)}
                    style={styles.input}
                />
                <span style={styles.switch}>
                    <span style={{
                        ...styles.slider,
                        transform: checked ? 'translateX(20px)' : 'translateX(0)',
                        backgroundColor: checked ? theme.colors.primary : theme.colors.background.tertiary,
                    }} />
                </span>
                <span style={styles.text}>{label}</span>
            </label>
        </div>
    );
};

const styles = {
    container: {
        marginBottom: theme.spacing.sm,
    },
    label: {
        display: 'flex',
        alignItems: 'center',
        cursor: 'pointer',
        userSelect: 'none' as const,
    },
    input: {
        display: 'none',
    },
    switch: {
        position: 'relative' as const,
        display: 'inline-block',
        width: '40px',
        height: '20px',
        backgroundColor: theme.colors.background.secondary,
        borderRadius: '10px',
        marginRight: theme.spacing.sm,
    },
    slider: {
        position: 'absolute' as const,
        top: '2px',
        left: '2px',
        width: '16px',
        height: '16px',
        borderRadius: '50%',
        transition: 'transform 0.2s, background-color 0.2s',
    },
    text: {
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components-dump.txt ---


+--------------------------------------------+
| Dump tree for directory: D:\Projects\Remotion Couples Quiz\my-video\src\components |
+--------------------------------------------+
‚îú‚îÄ‚îÄ Audio
‚îú‚îÄ‚îÄ Comparison.tsx
‚îú‚îÄ‚îÄ ComparisonEditor.tsx
‚îú‚îÄ‚îÄ ConfigMenu
‚îÇ  ‚îî‚îÄ‚îÄ ConfigMenu.tsx
‚îú‚îÄ‚îÄ ImageSelector.tsx
‚îú‚îÄ‚îÄ Layout
‚îÇ  ‚îî‚îÄ‚îÄ AppLayout.tsx
‚îú‚îÄ‚îÄ QuizSetup.tsx
‚îú‚îÄ‚îÄ ScriptEditor
‚îÇ  ‚îú‚îÄ‚îÄ AudioComponentEditor.tsx
‚îÇ  ‚îú‚îÄ‚îÄ CaptionEditor.tsx
‚îÇ  ‚îú‚îÄ‚îÄ CaptionPositioningScreen.tsx
‚îÇ  ‚îú‚îÄ‚îÄ CaptionTimeline.tsx
‚îÇ  ‚îú‚îÄ‚îÄ ComparisonComponentEditor.tsx
‚îÇ  ‚îú‚îÄ‚îÄ ComponentEditor.tsx
‚îÇ  ‚îú‚îÄ‚îÄ ComponentEditors.tsx
‚îÇ  ‚îú‚îÄ‚îÄ ComponentPalette.tsx
‚îÇ  ‚îú‚îÄ‚îÄ CountdownComponentEditor.tsx
‚îÇ  ‚îú‚îÄ‚îÄ DraggablePreview.tsx
‚îÇ  ‚îú‚îÄ‚îÄ ImageComponentEditor.tsx
‚îÇ  ‚îú‚îÄ‚îÄ PositioningScreen.tsx
‚îÇ  ‚îú‚îÄ‚îÄ ScriptEditor.tsx
‚îÇ  ‚îú‚îÄ‚îÄ TextComponentEditor.tsx
‚îÇ  ‚îú‚îÄ‚îÄ Timeline.tsx
‚îÇ  ‚îú‚îÄ‚îÄ TitleComponentEditor.tsx
‚îÇ  ‚îú‚îÄ‚îÄ VideoComponentEditor.tsx
‚îÇ  ‚îú‚îÄ‚îÄ VoiceComponent.tsx
‚îÇ  ‚îú‚îÄ‚îÄ VoiceComponentEditor.tsx
‚îÇ  ‚îî‚îÄ‚îÄ VoiceOverEditor.tsx
‚îú‚îÄ‚îÄ Settings
‚îÇ  ‚îú‚îÄ‚îÄ BackgroundManager.tsx
‚îÇ  ‚îú‚îÄ‚îÄ FontManager.tsx
‚îÇ  ‚îî‚îÄ‚îÄ PositioningPopup.tsx
‚îú‚îÄ‚îÄ Setup
‚îÇ  ‚îú‚îÄ‚îÄ ComparisonEditor.tsx
‚îÇ  ‚îú‚îÄ‚îÄ ImagePicker.tsx
‚îÇ  ‚îú‚îÄ‚îÄ ImageSelector.tsx
‚îÇ  ‚îî‚îÄ‚îÄ Setup.tsx
‚îú‚îÄ‚îÄ SetupPage.tsx
‚îú‚îÄ‚îÄ TemplateManager
‚îÇ  ‚îî‚îÄ‚îÄ TemplateManager.tsx
‚îú‚îÄ‚îÄ Timer.tsx
‚îú‚îÄ‚îÄ Video
‚îÇ  ‚îú‚îÄ‚îÄ AudioComponent.tsx
‚îÇ  ‚îú‚îÄ‚îÄ CaptionRenderer.tsx
‚îÇ  ‚îú‚îÄ‚îÄ ComparisonComponent.tsx
‚îÇ  ‚îú‚îÄ‚îÄ ComparisonSequence.tsx
‚îÇ  ‚îú‚îÄ‚îÄ CountdownSequence.tsx
‚îÇ  ‚îú‚îÄ‚îÄ ImageComponent.tsx
‚îÇ  ‚îú‚îÄ‚îÄ QuizVideo.tsx
‚îÇ  ‚îú‚îÄ‚îÄ RemotionSubtitleCaption.tsx
‚îÇ  ‚îú‚îÄ‚îÄ ScriptVideo.tsx
‚îÇ  ‚îú‚îÄ‚îÄ TextComponent.tsx
‚îÇ  ‚îú‚îÄ‚îÄ TextSequence.tsx
‚îÇ  ‚îú‚îÄ‚îÄ TikTokCaptions.tsx
‚îÇ  ‚îú‚îÄ‚îÄ TitleSequence.tsx
‚îÇ  ‚îú‚îÄ‚îÄ TransitionSequence.tsx
‚îÇ  ‚îú‚îÄ‚îÄ VideoComponent.tsx
‚îÇ  ‚îî‚îÄ‚îÄ VideoPositioningScreen.tsx
‚îî‚îÄ‚îÄ common
   ‚îú‚îÄ‚îÄ ColorPicker.tsx
   ‚îú‚îÄ‚îÄ IconButton.tsx
   ‚îú‚îÄ‚îÄ Modal.tsx
   ‚îú‚îÄ‚îÄ Slider.tsx
   ‚îî‚îÄ‚îÄ Switch.tsx



--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Comparison.tsx ---

import {
	AbsoluteFill,
	useCurrentFrame,
	interpolate,
	spring,
	useVideoConfig,
} from 'remotion';
import {Timer} from './Timer';
import {QuizItem} from '../data/quizData';

interface ComparisonProps {
	data: QuizItem;
	startFrame: number;
}

export const Comparison: React.FC<ComparisonProps> = ({data, startFrame}) => {
	const frame = useCurrentFrame();
	const {fps} = useVideoConfig();
	const relativeFrame = frame - startFrame;
	
	const opacity = spring({
		frame: relativeFrame,
		fps,
		config: {
			damping: 200,
		},
	});

	if (relativeFrame < 0 || relativeFrame > 150) return null;

	return (
		<AbsoluteFill>
			<div style={{
				opacity,
				display: 'flex',
				flexDirection: 'column',
				alignItems: 'center',
				padding: 40,
			}}>
				<h1 style={{
					fontSize: 60,
					color: 'white',
					textAlign: 'center',
					marginBottom: 40,
				}}>
					{data.question}
				</h1>
				
				<div style={{
					display: 'flex',
					width: '100%',
					justifyContent: 'space-between',
				}}>
					{/* Left Option */}
					<div style={{flex: 1, padding: 20}}>
						<img
							src={data.leftOption.image}
							style={{
								width: '100%',
								height: 'auto',
								borderRadius: 20,
							}}
						/>
						<h2 style={{
							color: 'white',
							textAlign: 'center',
							fontSize: 40,
						}}>
							{data.leftOption.text}
						</h2>
					</div>

					{/* Right Option */}
					<div style={{flex: 1, padding: 20}}>
						<img
							src={data.rightOption.image}
							style={{
								width: '100%',
								height: 'auto',
								borderRadius: 20,
							}}
						/>
						<h2 style={{
							color: 'white',
							textAlign: 'center',
							fontSize: 40,
						}}>
							{data.rightOption.text}
						</h2>
					</div>
				</div>

				<Timer startFrame={startFrame} />
			</div>
		</AbsoluteFill>
	);
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ComparisonEditor.tsx ---

import React from 'react';
import {Comparison} from '../types/quiz';
import { ImageSelector } from './ImageSelector';

interface ComparisonEditorProps {
	comparison: Comparison;
	onChange: (updatedComparison: Comparison) => void;
	onDelete: () => void;
}

export const ComparisonEditor: React.FC<ComparisonEditorProps> = ({
	comparison,
	onChange,
	onDelete,
}) => {
	return (
		<div style={{
			padding: '20px',
			border: '1px solid #ccc',
			borderRadius: '8px',
			backgroundColor: '#f8f9fa',
		}}>
			{/* Question Section */}
			<div style={{marginBottom: '20px'}}>
				<label style={{display: 'block', marginBottom: '8px', fontWeight: 'bold'}}>
					Question:
				</label>
				<input
					type="text"
					value={comparison.question}
					onChange={(e) => {
						onChange({
							...comparison,
							question: e.target.value,
						});
					}}
					style={{
						width: '100%',
						padding: '8px',
						fontSize: '16px',
						borderRadius: '4px',
						border: '1px solid #ddd',
					}}
					placeholder="Enter your question..."
				/>
			</div>

			{/* Options Section */}
			<div style={{
				display: 'grid',
				gridTemplateColumns: '1fr 1fr',
				gap: '20px',
			}}>
				{/* Left Option */}
				<div>
					<label style={{display: 'block', marginBottom: '8px', fontWeight: 'bold'}}>
						Left Option:
					</label>
					<input
						type="text"
						value={comparison.leftOption.text}
						onChange={(e) => {
							onChange({
								...comparison,
								leftOption: {
									...comparison.leftOption,
									text: e.target.value,
								},
							});
						}}
						style={{
							width: '100%',
							padding: '8px',
							fontSize: '16px',
							borderRadius: '4px',
							border: '1px solid #ddd',
							marginBottom: '10px',
						}}
						placeholder="Enter left option..."
					/>
					{/* Left Option Image Selection */}
					<ImageSelector
						searchTerm={comparison.leftOption.text}
						onSelect={(imageUrl) => {
							onChange({
								...comparison,
								leftOption: {
									...comparison.leftOption,
									imageUrl,
								},
							});
						}}
						currentImageUrl={comparison.leftOption.imageUrl}
					/>
				</div>

				{/* Right Option */}
				<div>
					<label style={{display: 'block', marginBottom: '8px', fontWeight: 'bold'}}>
						Right Option:
					</label>
					<input
						type="text"
						value={comparison.rightOption.text}
						onChange={(e) => {
							onChange({
								...comparison,
								rightOption: {
									...comparison.rightOption,
									text: e.target.value,
								},
							});
						}}
						style={{
							width: '100%',
							padding: '8px',
							fontSize: '16px',
							borderRadius: '4px',
							border: '1px solid #ddd',
							marginBottom: '10px',
						}}
						placeholder="Enter right option..."
					/>
					{/* Right Option Image Selection */}
					<ImageSelector
						searchTerm={comparison.rightOption.text}
						onSelect={(imageUrl) => {
							onChange({
								...comparison,
								rightOption: {
									...comparison.rightOption,
									imageUrl,
								},
							});
						}}
						currentImageUrl={comparison.rightOption.imageUrl}
					/>
				</div>
			</div>

			{/* Delete Button */}
			<button
				onClick={onDelete}
				style={{
					marginTop: '20px',
					padding: '8px 16px',
					backgroundColor: '#dc3545',
					color: 'white',
					border: 'none',
					borderRadius: '4px',
					cursor: 'pointer',
				}}
			>
				Delete Comparison
			</button>
		</div>
	);
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ConfigMenu\ConfigMenu.tsx ---

import React, { useState, useEffect } from 'react';
import { Modal } from '../common/Modal';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';
import { ImageSelector } from '../Setup/ImageSelector';
import { Script } from '../../types/script';
import { useConfigStore } from '../../store/configStore';
import { useVideoConfig } from 'remotion';
import { useApiKeys } from '../../store/apiKeysStore';
import { FontManager } from '../Settings/FontManager';
import { BackgroundManager } from '../Settings/BackgroundManager';

interface ConfigMenuProps {
    isOpen: boolean;
    onClose: () => void;
    script: Script;
    onScriptChange: (script: Script) => void;
}

interface ExportSettings {
    fps: number;
    width: number;
    height: number;
    codec: 'h264' | 'h265' | 'vp8' | 'vp9';
    quality: number;
}

export const ConfigMenu: React.FC<ConfigMenuProps> = ({
    isOpen,
    onClose,
    script,
    onScriptChange,
}) => {
    const fps = 30;
    const { 
        elevenLabsApiKey, 
        pexelsApiKey, 
        setElevenLabsApiKey,
        setPexelsApiKey,
    } = useApiKeys();

    const [localElevenLabsKey, setLocalElevenLabsKey] = useState(elevenLabsApiKey);
    const [localPexelsKey, setLocalPexelsKey] = useState(pexelsApiKey);
    const [showKeys, setShowKeys] = useState(false);
    const [isFontManagerOpen, setIsFontManagerOpen] = useState(false);
    const [showBackgroundManager, setShowBackgroundManager] = useState(false);
    const [saving, setSaving] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [exportSettings, setExportSettings] = useState<ExportSettings>({
        fps: 30,
        width: 1920,
        height: 1080,
        codec: 'h264',
        quality: 100
    });

    useEffect(() => {
        // Load initial config
        fetch('http://localhost:5003/config')
            .then(res => res.json())
            .then(data => {
                setLocalPexelsKey(data.pexels_api_key || '');
            })
            .catch(err => {
                console.error('Failed to load config:', err);
                setError('Failed to load configuration');
            });
    }, []);

    const handleSave = () => {
        setElevenLabsApiKey(localElevenLabsKey);
        setPexelsApiKey(localPexelsKey);
        
        // Also update the image service config
        fetch('http://localhost:5003/config', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                pexels_api_key: localPexelsKey,
            }),
        }).catch(err => {
            console.error('Failed to update image service config:', err);
        });
        
        onClose();
    };

    const handleBackgroundChange = () => {
        // Create a file input
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*,video/*';
        
        // Handle file selection
        input.onchange = async (e: Event) => {
            const file = (e.target as HTMLInputElement).files?.[0];
            if (!file) return;

            console.log('Selected file:', file.name, file.type);

            // Create form data
            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('http://localhost:3002/set_background', {
                    method: 'POST',
                    body: formData,
                });

                if (!response.ok) {
                    throw new Error('Failed to upload background');
                }

                const { filePath } = await response.json();

                // Update script with new background settings
                const backgroundType = file.type.startsWith('video/') ? 'video' as const : 'image' as const;
                const updatedScript = {
                    ...script,
                    settings: {
                        ...script.settings,
                        background: {
                            type: backgroundType,
                            url: filePath,
                            filePath: file.name,
                            ...(backgroundType === 'video' ? { durationInFrames: 300 } : {})
                        }
                    }
                };

                onScriptChange(updatedScript);
            } catch (error) {
                console.error('Error uploading background:', error);
            }
        };

        // Trigger file selection
        input.click();
    };

    const handleSaveConfig = async () => {
        setSaving(true);
        setError(null);

        try {
            const response = await fetch('http://localhost:5003/config', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    pexels_api_key: pexelsApiKey,
                }),
            });

            if (!response.ok) {
                throw new Error('Failed to save configuration');
            }

            // Show success message or update UI as needed
        } catch (err) {
            console.error('Failed to save config:', err);
            setError(err instanceof Error ? err.message : 'Failed to save configuration');
        } finally {
            setSaving(false);
        }
    };

    return (
        <>
            <Modal
                isOpen={isOpen}
                onClose={onClose}
                title={
                    <h2 style={{
                        ...commonStyles.heading,
                        margin: 0,
                        display: 'flex',
                        alignItems: 'center',
                        gap: theme.spacing.sm,
                        color: theme.colors.text.primary,
                        fontSize: '20px',
                    }}>
                        ‚öôÔ∏è Settings
                    </h2>
                }
            >
                <div style={{
                    display: 'flex',
                    flexDirection: 'column',
                    gap: theme.spacing.md,
                }}>
                    {/* API Key Settings */}
                    <div>
                        <h3 style={commonStyles.heading}>API Keys</h3>
                        <div style={{
                            display: 'flex',
                            justifyContent: 'space-between',
                            alignItems: 'center',
                            marginBottom: '10px',
                        }}>
                            <label style={{ color: theme.colors.text.primary }}>Show API Keys:</label>
                            <input
                                type="checkbox"
                                checked={showKeys}
                                onChange={(e) => setShowKeys(e.target.checked)}
                            />
                        </div>

                        <div style={{ marginBottom: '16px' }}>
                            <label style={{
                                display: 'block',
                                color: theme.colors.text.primary,
                                marginBottom: '8px',
                            }}>
                                ElevenLabs API Key:
                            </label>
                            <input
                                type={showKeys ? 'text' : 'password'}
                                value={localElevenLabsKey}
                                onChange={(e) => setLocalElevenLabsKey(e.target.value)}
                                style={{
                                    width: '100%',
                                    padding: '8px',
                                    backgroundColor: theme.colors.background.secondary,
                                    border: `1px solid ${theme.colors.border}`,
                                    borderRadius: theme.borderRadius.sm,
                                    color: theme.colors.text.primary,
                                }}
                                placeholder="Enter your ElevenLabs API key"
                            />
                        </div>

                        <div style={{ marginBottom: '16px' }}>
                            <label style={{
                                display: 'block',
                                color: theme.colors.text.primary,
                                marginBottom: '8px',
                            }}>
                                Pexels API Key:
                            </label>
                            <input
                                type={showKeys ? 'text' : 'password'}
                                value={localPexelsKey}
                                onChange={(e) => setLocalPexelsKey(e.target.value)}
                                style={{
                                    width: '100%',
                                    padding: '8px',
                                    backgroundColor: theme.colors.background.secondary,
                                    border: `1px solid ${theme.colors.border}`,
                                    borderRadius: theme.borderRadius.sm,
                                    color: theme.colors.text.primary,
                                }}
                                placeholder="Enter your Pexels API key"
                            />
                        </div>
                    </div>

                    {/* Background Settings */}
                    <div>
                        <h3 style={commonStyles.heading}>Background</h3>
                        <div style={{
                            display: 'flex',
                            flexDirection: 'column',
                            gap: theme.spacing.sm,
                        }}>
                            <button
                                onClick={() => setShowBackgroundManager(true)}
                                style={commonStyles.button.secondary}
                            >
                                Manage Backgrounds
                            </button>
                            {script.settings.background?.url && (
                                <button
                                    onClick={() => onScriptChange({
                                        ...script,
                                        settings: {
                                            ...script.settings,
                                            background: {
                                                type: 'none',
                                            },
                                        },
                                    })}
                                    style={{
                                        ...commonStyles.button.secondary,
                                        color: theme.colors.error,
                                    }}
                                >
                                    Reset to Default
                                </button>
                            )}
                            {script.settings.background?.type === 'video' && (
                                <div style={{
                                    color: theme.colors.text.secondary,
                                    fontSize: '0.9em',
                                    marginTop: theme.spacing.sm,
                                }}>
                                    Note: Video will loop if timeline exceeds video length
                                </div>
                            )}
                        </div>
                    </div>

                    {/* Font Manager Button */}
                    <div>
                        <button
                            onClick={() => setIsFontManagerOpen(true)}
                            style={{
                                ...commonStyles.button,
                                width: '100%',
                                padding: theme.spacing.md,
                                backgroundColor: theme.colors.primary,
                                color: theme.colors.text.primary,
                            }}
                        >
                            Manage Custom Fonts
                        </button>
                    </div>

                    {/* Export Settings */}
                    <div>
                        <h3 style={commonStyles.heading}>Export Settings</h3>
                        <div style={{
                            display: 'grid',
                            gridTemplateColumns: '1fr 1fr',
                            gap: theme.spacing.sm,
                        }}>
                            <div>
                                <label style={styles.label}>FPS:</label>
                                <input
                                    type="number"
                                    value={exportSettings.fps}
                                    onChange={(e) => setExportSettings({
                                        ...exportSettings,
                                        fps: Number(e.target.value)
                                    })}
                                    min={1}
                                    max={60}
                                    style={styles.input}
                                />
                            </div>
                            <div>
                                <label style={styles.label}>Quality (%):</label>
                                <input
                                    type="number"
                                    value={exportSettings.quality}
                                    onChange={(e) => setExportSettings({
                                        ...exportSettings,
                                        quality: Number(e.target.value)
                                    })}
                                    min={1}
                                    max={100}
                                    style={styles.input}
                                />
                            </div>
                            <div>
                                <label style={styles.label}>Width:</label>
                                <input
                                    type="number"
                                    value={exportSettings.width}
                                    onChange={(e) => setExportSettings({
                                        ...exportSettings,
                                        width: Number(e.target.value)
                                    })}
                                    min={100}
                                    max={3840}
                                    step={2}
                                    style={styles.input}
                                />
                            </div>
                            <div>
                                <label style={styles.label}>Height:</label>
                                <input
                                    type="number"
                                    value={exportSettings.height}
                                    onChange={(e) => setExportSettings({
                                        ...exportSettings,
                                        height: Number(e.target.value)
                                    })}
                                    min={100}
                                    max={2160}
                                    step={2}
                                    style={styles.input}
                                />
                            </div>
                            <div style={{ gridColumn: '1 / -1' }}>
                                <label style={styles.label}>Codec:</label>
                                <select
                                    value={exportSettings.codec}
                                    onChange={(e) => setExportSettings({
                                        ...exportSettings,
                                        codec: e.target.value as ExportSettings['codec']
                                    })}
                                    style={styles.select}
                                >
                                    <option value="h264">H.264</option>
                                    <option value="h265">H.265 (HEVC)</option>
                                    <option value="vp8">VP8</option>
                                    <option value="vp9">VP9</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    {/* Save Button */}
                    <div style={{
                        display: 'flex',
                        justifyContent: 'flex-end',
                        gap: theme.spacing.sm,
                        marginTop: theme.spacing.md,
                    }}>
                        <button
                            onClick={onClose}
                            style={commonStyles.button.secondary}
                        >
                            Cancel
                        </button>
                        <button
                            onClick={handleSave}
                            style={commonStyles.button.primary}
                        >
                            Save
                        </button>
                    </div>
                </div>
            </Modal>

            {/* Background Manager Modal */}
            {showBackgroundManager && (
                <Modal
                    isOpen={showBackgroundManager}
                    onClose={() => setShowBackgroundManager(false)}
                    title="Background Manager"
                >
                    <BackgroundManager
                        onSelectBackground={(background) => {
                            onScriptChange({
                                ...script,
                                settings: {
                                    ...script.settings,
                                    background: background
                                }
                            });
                            setShowBackgroundManager(false);
                        }}
                    />
                </Modal>
            )}

            {/* Font Manager Modal */}
            {isFontManagerOpen && (
                <FontManager onClose={() => setIsFontManagerOpen(false)} />
            )}
        </>
    );
};

const styles = {
    label: {
        display: 'block',
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
        marginBottom: theme.spacing.xs,
    },
    input: {
        width: '100%',
        padding: theme.spacing.sm,
        backgroundColor: theme.colors.background.secondary,
        border: `1px solid ${theme.colors.border}`,
        borderRadius: theme.borderRadius.sm,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
    },
    select: {
        width: '100%',
        padding: theme.spacing.sm,
        backgroundColor: theme.colors.background.secondary,
        border: `1px solid ${theme.colors.border}`,
        borderRadius: theme.borderRadius.sm,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ImageSelector.tsx ---

import React, { useState, useEffect } from 'react';
import { createClient, Photo } from 'pexels';
import { theme } from '../styles/theme';

const client = createClient('rXEDE5m6pUxOXZPawHmzKj04Z29WlV2y0Us44ld2TmXwdZstXtHUIh2F');

interface ImageSelectorProps {
    searchTerm: string;
    onSelect: (imageUrl: string) => void;
    currentImageUrl?: string;
    orientation?: 'portrait' | 'landscape' | 'square';
}

export const ImageSelector: React.FC<ImageSelectorProps> = ({
    searchTerm,
    onSelect,
    currentImageUrl,
    orientation = 'landscape'
}) => {
    const [images, setImages] = useState<Photo[]>([]);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [page, setPage] = useState(1);
    const [totalPages, setTotalPages] = useState(1);
    const perPage = 6;

    useEffect(() => {
        if (!searchTerm) return;

        const searchImages = async () => {
            setLoading(true);
            setError(null);
            try {
                const result = await client.photos.search({
                    query: searchTerm,
                    per_page: perPage,
                    page,
                    orientation
                });
                setImages(result.photos || []);
                setTotalPages(Math.ceil((result.total_results || 0) / perPage));
            } catch (err) {
                setError('Failed to load images');
                console.error(err);
            } finally {
                setLoading(false);
            }
        };

        searchImages();
    }, [searchTerm, page, orientation]);

    return (
        <div style={styles.container}>
            {loading && <div style={styles.loading}>Loading images...</div>}
            {error && <div style={styles.error}>{error}</div>}
            
            <div style={styles.grid}>
                {images.map((photo) => (
                    <div
                        key={photo.id}
                        style={{
                            ...styles.imageContainer,
                            border: currentImageUrl === photo.src.medium ? `3px solid ${theme.colors.primary}` : '1px solid #ddd',
                        }}
                        onClick={() => onSelect(photo.src.medium)}
                    >
                        <img
                            src={photo.src.medium}
                            alt={photo.alt || 'Option image'}
                            style={styles.image}
                        />
                        <div style={styles.imageOverlay}>
                            <span>Select</span>
                        </div>
                    </div>
                ))}
            </div>

            {totalPages > 1 && (
                <div style={styles.pagination}>
                    <button
                        onClick={() => setPage(p => Math.max(1, p - 1))}
                        disabled={page === 1}
                        style={{
                            ...styles.button,
                            opacity: page === 1 ? 0.5 : 1
                        }}
                    >
                        Previous
                    </button>
                    <span style={styles.pageInfo}>
                        Page {page} of {totalPages}
                    </span>
                    <button
                        onClick={() => setPage(p => Math.min(totalPages, p + 1))}
                        disabled={page === totalPages}
                        style={{
                            ...styles.button,
                            opacity: page === totalPages ? 0.5 : 1
                        }}
                    >
                        Next
                    </button>
                </div>
            )}
        </div>
    );
};

const styles = {
    container: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.md,
    },
    loading: {
        textAlign: 'center' as const,
        padding: theme.spacing.md,
        color: theme.colors.text.secondary,
    },
    error: {
        textAlign: 'center' as const,
        padding: theme.spacing.md,
        color: theme.colors.error,
    },
    grid: {
        display: 'grid',
        gridTemplateColumns: 'repeat(2, 1fr)',
        gap: theme.spacing.md,
    },
    imageContainer: {
        position: 'relative' as const,
        cursor: 'pointer',
        borderRadius: theme.borderRadius.md,
        overflow: 'hidden',
        aspectRatio: '16/9',
        transition: 'transform 0.2s ease-in-out',
        '&:hover': {
            transform: 'scale(1.02)',
        },
    },
    image: {
        width: '100%',
        height: '100%',
        objectFit: 'cover' as const,
    },
    imageOverlay: {
        position: 'absolute' as const,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        background: 'rgba(0, 0, 0, 0.5)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        color: '#fff',
        opacity: 0,
        transition: 'opacity 0.2s ease-in-out',
        '&:hover': {
            opacity: 1,
        },
    },
    pagination: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        gap: theme.spacing.md,
        marginTop: theme.spacing.md,
    },
    pageInfo: {
        color: theme.colors.text.secondary,
    },
    button: {
        padding: `${theme.spacing.sm} ${theme.spacing.md}`,
        backgroundColor: theme.colors.primary,
        color: '#fff',
        border: 'none',
        borderRadius: theme.borderRadius.sm,
        cursor: 'pointer',
        '&:disabled': {
            cursor: 'not-allowed',
        },
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Layout\AppLayout.tsx ---

import React, { useState } from 'react';
import { theme } from '../../styles/theme';
import { ConfigMenu } from '../ConfigMenu/ConfigMenu';
import { Script } from '../../types/script';
import { exportVideo } from '../../services/videoService';

interface AppLayoutProps {
    children: [React.ReactNode, React.ReactNode, React.ReactNode]; // Left, Center, Right content
    script: Script;
    onScriptChange: (script: Script) => void;
}

export const AppLayout: React.FC<AppLayoutProps> = ({ 
    children: [leftContent, centerContent, rightContent],
    script,
    onScriptChange,
}) => {
    const [isConfigOpen, setIsConfigOpen] = useState(false);
    const [isExporting, setIsExporting] = useState(false);

    const handleExportVideo = async () => {
        try {
            console.log('Starting video export...');
            console.log('Script data:', script);
            setIsExporting(true);
            const outputLocation = await exportVideo(script);
            console.log('Video exported successfully to:', outputLocation);
            alert(`Video exported successfully to: ${outputLocation}`);
        } catch (error) {
            console.error('Error exporting video:', error);
            alert('Failed to export video. Check console for details.');
        } finally {
            setIsExporting(false);
        }
    };

    return (
        <div style={{
            minHeight: '100vh',
            backgroundColor: theme.colors.background.primary,
            color: theme.colors.text.primary,
            display: 'grid',
            gridTemplateRows: 'auto 1fr',
            overflowX: 'hidden',
        }}>
            {/* Header */}
            <header style={{
                backgroundColor: theme.colors.background.secondary,
                borderBottom: `1px solid ${theme.colors.border}`,
                padding: `${theme.spacing.md} ${theme.spacing.xl}`,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between',
                boxShadow: theme.shadows.md,
                position: 'sticky',
                top: 0,
                zIndex: 100,
            }}>
                <div style={{ display: 'flex', alignItems: 'center', gap: theme.spacing.md }}>
                    <h1 style={{ 
                        margin: 0, 
                        fontSize: '24px',
                        background: `linear-gradient(135deg, ${theme.colors.primary}, ${theme.colors.secondary})`,
                        WebkitBackgroundClip: 'text',
                        WebkitTextFillColor: 'transparent',
                        fontWeight: 'bold',
                    }}>
                        Couples Quiz Creator
                    </h1>
                </div>
                <nav style={{
                    display: 'flex',
                    gap: theme.spacing.lg,
                }}>
                    <button style={{
                        ...commonButtonStyle,
                        backgroundColor: 'transparent',
                        color: theme.colors.text.primary,
                    }}
                    onClick={() => setIsConfigOpen(true)}
                    >
                        ‚öôÔ∏è Settings
                    </button>
                    <button style={{
                        ...commonButtonStyle,
                        backgroundColor: theme.colors.primary,
                        color: theme.colors.text.primary,
                        opacity: isExporting ? 0.7 : 1,
                        cursor: isExporting ? 'not-allowed' : 'pointer',
                    }}
                    onClick={handleExportVideo}
                    disabled={isExporting}
                    >
                        {isExporting ? 'Exporting...' : 'Export Video'}
                    </button>
                </nav>
            </header>

            {/* Main Content */}
            <main style={{
                padding: `${theme.spacing.lg} ${theme.spacing.lg}`,
                display: 'grid',
                gridTemplateColumns: '280px 1fr minmax(500px, 800px)',
                gap: theme.spacing.lg,
                height: 'calc(100vh - 80px)', // Subtract header height
                position: 'relative',
                overflow: 'hidden', // Prevent content from expanding outside
            }}>
                {/* Left Sidebar - Component Palette */}
                <aside style={{
                    backgroundColor: theme.colors.background.secondary,
                    borderRadius: theme.borderRadius.lg,
                    padding: theme.spacing.md,
                    boxShadow: theme.shadows.md,
                    border: `1px solid ${theme.colors.border}`,
                    position: 'sticky',
                    top: '80px',
                    height: 'fit-content',
                    maxHeight: 'calc(100vh - 100px)',
                    overflowY: 'auto',
                }}>
                    {leftContent}
                </aside>

                {/* Center Content - Preview */}
                <div style={{
                    backgroundColor: theme.colors.background.secondary,
                    borderRadius: theme.borderRadius.lg,
                    padding: theme.spacing.md,
                    boxShadow: theme.shadows.md,
                    border: `1px solid ${theme.colors.border}`,
                    display: 'flex',
                    flexDirection: 'column',
                    gap: theme.spacing.md,
                    overflowY: 'auto',
                }}>
                    {centerContent}
                </div>

                {/* Right Sidebar - Properties */}
                <aside style={{
                    backgroundColor: theme.colors.background.secondary,
                    borderRadius: theme.borderRadius.lg,
                    padding: theme.spacing.md,
                    boxShadow: theme.shadows.md,
                    border: `1px solid ${theme.colors.border}`,
                    position: 'sticky',
                    top: '80px',
                    height: 'calc(100vh - 100px)',
                    overflowY: 'auto',
                }}>
                    {rightContent}
                </aside>
            </main>

            {/* Config Menu */}
            <ConfigMenu
                isOpen={isConfigOpen}
                onClose={() => setIsConfigOpen(false)}
                script={script}
                onScriptChange={onScriptChange}
            />
        </div>
    );
};

// Common styles
const commonButtonStyle = {
    padding: `${theme.spacing.sm} ${theme.spacing.lg}`,
    borderRadius: theme.borderRadius.md,
    border: 'none',
    cursor: 'pointer',
    fontWeight: 'bold',
    transition: 'all 0.2s ease',
    '&:hover': {
        opacity: 0.9,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\QuizSetup.tsx ---

import React from 'react';
import { Photo } from 'pexels';
import { ImageSelector } from './ImageSelector';
import { QuizItem } from '../data/quizData';

interface QuizSetupProps {
  onSave: (quizData: QuizItem[]) => void;
}

export const QuizSetup: React.FC<QuizSetupProps> = ({ onSave }) => {
  const [quizItems, setQuizItems] = React.useState<QuizItem[]>([]);
  const [currentItem, setCurrentItem] = React.useState(0);
  const [selectingFor, setSelectingFor] = React.useState<'left' | 'right' | null>(null);

  const handleImageSelect = (photo: Photo) => {
    if (!selectingFor) return;

    setQuizItems((prev) => {
      const updated = [...prev];
      updated[currentItem] = {
        ...updated[currentItem],
        [selectingFor === 'left' ? 'leftOption' : 'rightOption']: {
          ...updated[currentItem][selectingFor === 'left' ? 'leftOption' : 'rightOption'],
          image: photo.src.large,
          pexelsPhoto: photo,
        },
      };
      return updated;
    });

    setSelectingFor(null);
  };

  return (
    <div>
      {selectingFor && (
        <ImageSelector
          onSelect={handleImageSelect}
          searchQuery={
            selectingFor === 'left'
              ? quizItems[currentItem].leftOption.text
              : quizItems[currentItem].rightOption.text
          }
        />
      )}
      
      {/* Add your UI controls for managing quiz items here */}
    </div>
  );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\AudioComponentEditor.tsx ---

import React, { useRef, useState, useEffect } from 'react';
import { AudioComponent } from '../../types/script';
import { theme } from '../../styles/theme';

interface AudioEffect {
    name: string;
    url: string;
}

interface AudioComponentEditorProps {
    component: AudioComponent;
    onChange: (component: AudioComponent) => void;
    onDelete: () => void;
}

export const AudioComponentEditor: React.FC<AudioComponentEditorProps> = ({
    component,
    onChange,
    onDelete,
}) => {
    const fileInputRef = useRef<HTMLInputElement>(null);
    const [effects, setEffects] = useState<AudioEffect[]>([]);
    const [isLoading, setIsLoading] = useState(false);

    // Fetch available effects on mount
    useEffect(() => {
        fetchEffects();
    }, []);

    const fetchEffects = async () => {
        try {
            console.log('Fetching available audio effects...');
            const response = await fetch('http://localhost:3005/effects/dictionary');
            if (!response.ok) throw new Error('Failed to fetch effects');
            const data = await response.json();
            console.log('Available effects:', data);
            setEffects(Object.entries(data).map(([name, url]) => ({ name, url: url as string })));
        } catch (error) {
            console.error('Error fetching effects:', error);
        }
    };

    const handleStyleChange = (key: string, value: number | boolean | undefined) => {
        onChange({
            ...component,
            style: {
                ...component.style,
                [key]: value,
            },
        });
    };

    const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (!file) return;

        setIsLoading(true);
        try {
            console.log('Uploading audio file:', file.name);
            const formData = new FormData();
            formData.append('file', file);

            const response = await fetch('http://localhost:3005/effects/upload', {
                method: 'POST',
                body: formData,
            });

            if (!response.ok) throw new Error('Failed to upload audio file');
            const data = await response.json();
            console.log('Upload successful:', data);

            onChange({
                ...component,
                audioUrl: data.url,
            });

            // Refresh effects list after upload
            await fetchEffects();
        } catch (error) {
            console.error('Error uploading audio file:', error);
            alert('Failed to upload audio file. Please try again.');
        } finally {
            setIsLoading(false);
        }
    };

    const handleEffectSelect = (effect: AudioEffect) => {
        console.log('Selected effect:', effect);
        onChange({
            ...component,
            audioUrl: effect.url,
        });
    };

    const handleEffectDelete = async (effectName: string) => {
        try {
            console.log('Deleting effect:', effectName);
            const response = await fetch('http://localhost:3005/effects/delete', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ name: effectName }),
            });

            if (!response.ok) throw new Error('Failed to delete effect');
            console.log('Effect deleted successfully');
            
            // Refresh effects list after deletion
            await fetchEffects();
        } catch (error) {
            console.error('Error deleting effect:', error);
            alert('Failed to delete effect. Please try again.');
        }
    };

    return (
        <div style={{ display: 'flex', flexDirection: 'column', gap: theme.spacing.md }}>
            <div style={{
                padding: theme.spacing.md,
                backgroundColor: theme.colors.background.tertiary,
                borderRadius: theme.borderRadius.md,
            }}>
                <h3 style={{
                    margin: 0,
                    marginBottom: theme.spacing.sm,
                    fontSize: theme.fontSizes.lg,
                    color: theme.colors.text.primary,
                }}>Audio Settings</h3>

                {/* Audio Source Selection */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <label style={{
                        display: 'block',
                        marginBottom: theme.spacing.xs,
                        color: theme.colors.text.secondary,
                    }}>
                        Audio Source
                    </label>
                    <div style={{ display: 'flex', gap: theme.spacing.sm }}>
                        <button
                            onClick={() => fileInputRef.current?.click()}
                            style={{
                                padding: theme.spacing.sm,
                                backgroundColor: theme.colors.primary,
                                color: theme.colors.text.primary,
                                border: 'none',
                                borderRadius: theme.borderRadius.sm,
                                cursor: 'pointer',
                            }}
                            disabled={isLoading}
                        >
                            {isLoading ? 'Uploading...' : 'Upload Audio File'}
                        </button>
                        <input
                            ref={fileInputRef}
                            type="file"
                            accept="audio/*"
                            onChange={handleFileUpload}
                            style={{ display: 'none' }}
                        />
                    </div>

                    {/* Available Effects */}
                    {effects.length > 0 && (
                        <div style={{ 
                            marginTop: theme.spacing.md,
                            padding: theme.spacing.sm,
                            backgroundColor: theme.colors.background.secondary,
                            borderRadius: theme.borderRadius.sm,
                        }}>
                            <h4 style={{
                                margin: 0,
                                marginBottom: theme.spacing.sm,
                                color: theme.colors.text.primary,
                            }}>Available Effects</h4>
                            <div style={{ display: 'flex', flexDirection: 'column', gap: theme.spacing.xs }}>
                                {effects.map((effect) => (
                                    <div key={effect.name} style={{
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'space-between',
                                        padding: theme.spacing.xs,
                                        backgroundColor: component.audioUrl === effect.url ? theme.colors.primary : 'transparent',
                                        borderRadius: theme.borderRadius.sm,
                                        cursor: 'pointer',
                                    }}>
                                        <span
                                            onClick={() => handleEffectSelect(effect)}
                                            style={{
                                                flex: 1,
                                                color: theme.colors.text.primary,
                                            }}
                                        >
                                            {effect.name}
                                        </span>
                                        <button
                                            onClick={() => handleEffectDelete(effect.name)}
                                            style={{
                                                padding: `${theme.spacing.xs} ${theme.spacing.sm}`,
                                                backgroundColor: theme.colors.warning,
                                                color: theme.colors.text.primary,
                                                border: 'none',
                                                borderRadius: theme.borderRadius.sm,
                                                cursor: 'pointer',
                                                fontSize: '0.8em',
                                            }}
                                        >
                                            Delete
                                        </button>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}

                    {/* URL Input */}
                    <input
                        type="text"
                        value={component.audioUrl}
                        onChange={(e) => onChange({ ...component, audioUrl: e.target.value })}
                        placeholder="Or enter audio URL"
                        style={{
                            width: '100%',
                            marginTop: theme.spacing.sm,
                            padding: theme.spacing.sm,
                            borderRadius: theme.borderRadius.sm,
                            border: `1px solid ${theme.colors.border}`,
                            backgroundColor: theme.colors.background.secondary,
                            color: theme.colors.text.primary,
                        }}
                    />
                </div>

                {/* Volume Control */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <label style={{
                        display: 'block',
                        marginBottom: theme.spacing.xs,
                        color: theme.colors.text.secondary,
                    }}>
                        Volume
                    </label>
                    <input
                        type="range"
                        min="0"
                        max="1"
                        step="0.1"
                        value={component.style?.volume ?? 1}
                        onChange={(e) => handleStyleChange('volume', parseFloat(e.target.value))}
                        style={{ width: '100%' }}
                    />
                </div>

                {/* Start Time */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <label style={{
                        display: 'block',
                        marginBottom: theme.spacing.xs,
                        color: theme.colors.text.secondary,
                    }}>
                        Start Time (seconds)
                    </label>
                    <input
                        type="number"
                        min="0"
                        step="0.1"
                        value={component.style?.startTime ?? 0}
                        onChange={(e) => handleStyleChange('startTime', parseFloat(e.target.value))}
                        style={{
                            width: '100%',
                            padding: theme.spacing.sm,
                            borderRadius: theme.borderRadius.sm,
                            border: `1px solid ${theme.colors.border}`,
                            backgroundColor: theme.colors.background.secondary,
                            color: theme.colors.text.primary,
                        }}
                    />
                </div>

                {/* Duration */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <label style={{
                        display: 'block',
                        marginBottom: theme.spacing.xs,
                        color: theme.colors.text.secondary,
                    }}>
                        Duration (seconds, leave empty for full duration)
                    </label>
                    <input
                        type="number"
                        min="0"
                        step="0.1"
                        value={component.style?.duration ?? ''}
                        onChange={(e) => handleStyleChange('duration', e.target.value ? parseFloat(e.target.value) : undefined)}
                        style={{
                            width: '100%',
                            padding: theme.spacing.sm,
                            borderRadius: theme.borderRadius.sm,
                            border: `1px solid ${theme.colors.border}`,
                            backgroundColor: theme.colors.background.secondary,
                            color: theme.colors.text.primary,
                        }}
                    />
                </div>

                {/* Loop Toggle */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <label style={{
                        display: 'flex',
                        alignItems: 'center',
                        gap: theme.spacing.sm,
                        color: theme.colors.text.secondary,
                        cursor: 'pointer',
                    }}>
                        <input
                            type="checkbox"
                            checked={component.style?.loop ?? false}
                            onChange={(e) => handleStyleChange('loop', e.target.checked)}
                        />
                        Loop Audio
                    </label>
                </div>
            </div>

            {/* Delete Button */}
            <button
                onClick={onDelete}
                style={{
                    padding: theme.spacing.sm,
                    backgroundColor: theme.colors.warning,
                    color: theme.colors.text.primary,
                    border: 'none',
                    borderRadius: theme.borderRadius.sm,
                    cursor: 'pointer',
                    fontWeight: 'bold',
                }}
            >
                Delete
            </button>

            {/* Audio Preview */}
            {component.audioUrl && (
                <div style={{
                    marginTop: theme.spacing.md,
                    padding: theme.spacing.md,
                    backgroundColor: theme.colors.background.tertiary,
                    borderRadius: theme.borderRadius.md,
                }}>
                    <h4 style={{
                        margin: 0,
                        marginBottom: theme.spacing.sm,
                        color: theme.colors.text.primary,
                    }}>Preview</h4>
                    <audio
                        controls
                        src={component.audioUrl}
                        style={{ width: '100%' }}
                    />
                </div>
            )}
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\CaptionEditor.tsx ---

import React, { useState } from 'react';
import { WordTiming } from '../../types/script';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';

interface CaptionEditorProps {
    wordTimings: WordTiming[];
    onWordTimingsChange: (newTimings: WordTiming[]) => void;
    onClose: () => void;
}

export const CaptionEditor: React.FC<CaptionEditorProps> = ({
    wordTimings,
    onWordTimingsChange,
    onClose,
}) => {
    const [editingWord, setEditingWord] = useState<number | null>(null);
    const [localTimings, setLocalTimings] = useState<WordTiming[]>(wordTimings);

    const handleWordChange = (index: number, field: keyof WordTiming, value: string | number) => {
        const newTimings = [...localTimings];
        newTimings[index] = {
            ...newTimings[index],
            [field]: field === 'word' ? value : Number(value),
        };
        setLocalTimings(newTimings);
    };

    const handleSave = () => {
        onWordTimingsChange(localTimings);
        onClose();
    };

    return (
        <div style={{
            padding: theme.spacing.md,
            display: 'flex',
            flexDirection: 'column',
            gap: theme.spacing.md,
            maxHeight: '80vh',
            overflow: 'auto',
        }}>
            <div style={{
                display: 'flex',
                flexDirection: 'column',
                gap: theme.spacing.sm,
            }}>
                {localTimings.map((timing, index) => (
                    <div
                        key={index}
                        style={{
                            display: 'flex',
                            gap: theme.spacing.md,
                            alignItems: 'center',
                            padding: theme.spacing.sm,
                            backgroundColor: theme.colors.background.secondary,
                            borderRadius: theme.borderRadius.sm,
                        }}
                    >
                        <input
                            value={timing.word}
                            onChange={(e) => handleWordChange(index, 'word', e.target.value)}
                            style={{
                                flex: 2,
                                padding: '4px 8px',
                                borderRadius: theme.borderRadius.sm,
                                border: `1px solid ${theme.colors.border}`,
                                backgroundColor: theme.colors.background.tertiary,
                                color: theme.colors.text.primary,
                            }}
                        />
                        <div style={{ display: 'flex', gap: theme.spacing.sm, alignItems: 'center' }}>
                            <label>Start:</label>
                            <input
                                type="number"
                                step="0.1"
                                value={timing.start}
                                onChange={(e) => handleWordChange(index, 'start', e.target.value)}
                                style={{
                                    width: '80px',
                                    padding: '4px 8px',
                                    borderRadius: theme.borderRadius.sm,
                                    border: `1px solid ${theme.colors.border}`,
                                    backgroundColor: theme.colors.background.tertiary,
                                    color: theme.colors.text.primary,
                                }}
                            />
                        </div>
                        <div style={{ display: 'flex', gap: theme.spacing.sm, alignItems: 'center' }}>
                            <label>End:</label>
                            <input
                                type="number"
                                step="0.1"
                                value={timing.end}
                                onChange={(e) => handleWordChange(index, 'end', e.target.value)}
                                style={{
                                    width: '80px',
                                    padding: '4px 8px',
                                    borderRadius: theme.borderRadius.sm,
                                    border: `1px solid ${theme.colors.border}`,
                                    backgroundColor: theme.colors.background.tertiary,
                                    color: theme.colors.text.primary,
                                }}
                            />
                        </div>
                    </div>
                ))}
            </div>

            <div style={{
                display: 'flex',
                justifyContent: 'flex-end',
                gap: theme.spacing.md,
                marginTop: theme.spacing.md,
            }}>
                <button
                    onClick={onClose}
                    style={commonStyles.button.secondary}
                >
                    Cancel
                </button>
                <button
                    onClick={handleSave}
                    style={commonStyles.button.primary}
                >
                    Save Changes
                </button>
            </div>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\CaptionPositioningScreen.tsx ---

import React, { useState } from 'react';
import { CaptionStyleOptions } from '../../types/script';
import { theme } from '../../styles/theme';

interface CaptionPositioningScreenProps {
    style: CaptionStyleOptions;
    onChange: (style: CaptionStyleOptions) => void;
}

export const CaptionPositioningScreen: React.FC<CaptionPositioningScreenProps> = ({
    style,
    onChange,
}) => {
    const [isDragging, setIsDragging] = useState(false);
    const [startPos, setStartPos] = useState({ x: 0, y: 0 });

    const handleMouseDown = (e: React.MouseEvent) => {
        setIsDragging(true);
        setStartPos({
            x: e.clientX - (style.x || 0),
            y: e.clientY - (style.y || 0),
        });
    };

    const handleMouseMove = (e: React.MouseEvent) => {
        if (!isDragging) return;

        const newX = e.clientX - startPos.x;
        const newY = e.clientY - startPos.y;

        onChange({
            ...style,
            x: newX,
            y: newY,
        });
    };

    const handleMouseUp = () => {
        setIsDragging(false);
    };

    return (
        <div style={styles.container}>
            <div style={styles.header}>
                <h3>Caption Positioning</h3>
                <p>Drag to position the captions or use the controls below</p>
            </div>

            <div 
                style={styles.previewArea}
                onMouseMove={handleMouseMove}
                onMouseUp={handleMouseUp}
                onMouseLeave={handleMouseUp}
            >
                <div
                    style={{
                        ...styles.captionPreview,
                        transform: `translate(${style.x || 0}px, ${style.y || 0}px) scale(${style.scale || 1}) rotate(${style.rotation || 0}deg)`,
                        cursor: isDragging ? 'grabbing' : 'grab',
                        fontSize: style.fontSize,
                        color: style.color,
                        backgroundColor: style.backgroundColor,
                        fontFamily: style.fontFamily,
                        fontWeight: style.fontWeight,
                        fontStyle: style.fontStyle,
                        textDecoration: style.textDecoration,
                        padding: style.padding,
                        margin: style.margin,
                        borderRadius: style.borderRadius,
                        border: style.border,
                        boxShadow: style.boxShadow,
                        opacity: style.opacity,
                    }}
                    onMouseDown={handleMouseDown}
                >
                    Sample Caption Text
                </div>
            </div>

            <div style={styles.controls}>
                <div style={styles.controlGroup}>
                    <label>Position X:</label>
                    <input
                        type="number"
                        value={style.x || 0}
                        onChange={(e) => onChange({ ...style, x: Number(e.target.value) })}
                    />
                </div>

                <div style={styles.controlGroup}>
                    <label>Position Y:</label>
                    <input
                        type="number"
                        value={style.y || 0}
                        onChange={(e) => onChange({ ...style, y: Number(e.target.value) })}
                    />
                </div>

                <div style={styles.controlGroup}>
                    <label>Scale:</label>
                    <input
                        type="range"
                        min="0.1"
                        max="2"
                        step="0.1"
                        value={style.scale || 1}
                        onChange={(e) => onChange({ ...style, scale: Number(e.target.value) })}
                    />
                </div>

                <div style={styles.controlGroup}>
                    <label>Rotation:</label>
                    <input
                        type="range"
                        min="-180"
                        max="180"
                        value={style.rotation || 0}
                        onChange={(e) => onChange({ ...style, rotation: Number(e.target.value) })}
                    />
                </div>
            </div>
        </div>
    );
};

const styles = {
    container: {
        padding: theme.spacing.md,
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.md,
    },
    header: {
        textAlign: 'center' as const,
    },
    previewArea: {
        width: '100%',
        height: '300px',
        backgroundColor: '#f0f0f0',
        position: 'relative' as const,
        overflow: 'hidden',
        border: '1px solid #ccc',
        borderRadius: theme.borderRadius.md,
    },
    captionPreview: {
        position: 'absolute' as const,
        userSelect: 'none' as const,
        padding: '10px 20px',
        borderRadius: '5px',
        transition: 'transform 0.1s ease-out',
    },
    controls: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.sm,
    },
    controlGroup: {
        display: 'flex',
        alignItems: 'center',
        gap: theme.spacing.sm,
        '& label': {
            minWidth: '100px',
        },
        '& input': {
            flex: 1,
            padding: theme.spacing.sm,
            borderRadius: theme.borderRadius.sm,
            border: '1px solid #ccc',
        },
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\CaptionTimeline.tsx ---

import React, { useState, useRef, useEffect } from 'react';
import { CaptionTrack, Script, VoiceComponent, WordTiming } from '../../types/script';
import { theme } from '../../styles/theme';
import { Modal } from '../common/Modal';
import { CaptionEditor } from './CaptionEditor';

interface CaptionTimelineProps {
    script: Script;
    onScriptChange: (script: Script) => void;
}

const TRACK_HEIGHT = 40;
const PIXELS_PER_SECOND = 100;
const FRAMES_PER_SECOND = 30;

export const CaptionTimeline: React.FC<CaptionTimelineProps> = ({
    script,
    onScriptChange,
}) => {
    const [draggingId, setDraggingId] = useState<string | null>(null);
    const [dragOffset, setDragOffset] = useState(0);
    const [editingCaption, setEditingCaption] = useState<string | null>(null);
    const [editingWordTimings, setEditingWordTimings] = useState<{id: string, isTrack: boolean} | null>(null);
    const containerRef = useRef<HTMLDivElement>(null);

    // Calculate timeline width based on all components and caption tracks
    const timelineWidth = Math.max(
        ...script.components
            .filter(c => c.type === 'voice')
            .map(c => {
                const start = c.startFrame || 0;
                const duration = c.durationInFrames || 150;
                return (start + duration) / FRAMES_PER_SECOND * PIXELS_PER_SECOND;
            }),
        ...(script.captionTracks || []).map(track => {
            const start = track.startFrame;
            const lastWord = track.wordTimings[track.wordTimings.length - 1];
            const duration = lastWord ? (lastWord.end * FRAMES_PER_SECOND) : 150;
            return (start + duration) / FRAMES_PER_SECOND * PIXELS_PER_SECOND;
        }),
        PIXELS_PER_SECOND * 10 // Minimum width of 10 seconds
    );

    const handleUnlink = (componentId: string) => {
        // Find the voice component
        const component = script.components.find(
            c => c.id === componentId && c.type === 'voice'
        ) as VoiceComponent | undefined;

        if (!component?.wordTimings) return;

        // Create a new caption track
        const newTrack: CaptionTrack = {
            id: `caption_${Date.now()}`,
            originalComponentId: componentId,
            isLinked: false,
            wordTimings: component.wordTimings,
            startFrame: component.startFrame || 0,
            text: component.text,
        };

        // Add to caption tracks
        onScriptChange({
            ...script,
            captionTracks: [...(script.captionTracks || []), newTrack],
        });
    };

    const handleRelink = (trackId: string) => {
        const track = script.captionTracks?.find(t => t.id === trackId);
        if (!track?.originalComponentId) return;

        // Update the original component with the track's timings
        const updatedComponents = script.components.map(comp => {
            if (comp.id === track.originalComponentId && comp.type === 'voice') {
                return {
                    ...comp,
                    wordTimings: track.wordTimings,
                    startFrame: track.startFrame,
                };
            }
            return comp;
        });

        // Remove this track from caption tracks
        onScriptChange({
            ...script,
            components: updatedComponents,
            captionTracks: script.captionTracks?.filter(t => t.id !== trackId) || [],
        });
    };

    const handleDragStart = (e: React.DragEvent, track: CaptionTrack) => {
        const rect = e.currentTarget.getBoundingClientRect();
        const offsetX = e.clientX - rect.left;
        setDragOffset(Math.round((offsetX / PIXELS_PER_SECOND) * FRAMES_PER_SECOND));
        setDraggingId(track.id);
    };

    const handleDrag = (e: React.DragEvent) => {
        if (!draggingId) return;

        const rect = e.currentTarget.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const newStartFrame = Math.max(0, Math.round((x / PIXELS_PER_SECOND) * FRAMES_PER_SECOND) - dragOffset);

        const updatedTracks = script.captionTracks?.map(track => 
            track.id === draggingId ? { ...track, startFrame: newStartFrame } : track
        );

        onScriptChange({
            ...script,
            captionTracks: updatedTracks || [],
        });
    };

    const handleEditText = (trackId: string, newText: string) => {
        const updatedTracks = script.captionTracks?.map(track => 
            track.id === trackId ? { ...track, text: newText } : track
        );

        onScriptChange({
            ...script,
            captionTracks: updatedTracks || [],
        });
    };

    const handleWordTimingsChange = (id: string, isTrack: boolean, newTimings: WordTiming[]) => {
        if (isTrack) {
            // Update caption track
            const updatedTracks = script.captionTracks?.map(track => 
                track.id === id ? { ...track, wordTimings: newTimings } : track
            );
            onScriptChange({
                ...script,
                captionTracks: updatedTracks || [],
            });
        } else {
            // Update voice component
            const updatedComponents = script.components.map(comp => 
                comp.id === id && comp.type === 'voice'
                    ? { ...comp, wordTimings: newTimings }
                    : comp
            );
            onScriptChange({
                ...script,
                components: updatedComponents,
            });
        }
    };

    return (
        <>
            <div style={{
                backgroundColor: theme.colors.background.secondary,
                padding: theme.spacing.lg,
                borderRadius: theme.borderRadius.md,
                marginTop: theme.spacing.xl,
                borderTop: `2px solid ${theme.colors.border}`,
            }}>
                <div style={{
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    marginBottom: theme.spacing.lg,
                }}>
                    <h3 style={{ 
                        color: theme.colors.text.primary, 
                        margin: 0,
                        fontSize: '16px',
                        fontWeight: 'bold',
                    }}>
                        Captions Timeline
                    </h3>
                </div>

                <div 
                    ref={containerRef}
                    style={{
                        backgroundColor: theme.colors.background.tertiary,
                        borderRadius: theme.borderRadius.sm,
                        padding: theme.spacing.sm,
                    }}
                >
                    <div style={{
                        width: `${timelineWidth}px`,
                        position: 'relative',
                    }}>
                        {/* Time markers */}
                        <div style={{
                            height: '30px',
                            borderBottom: `1px solid ${theme.colors.border}`,
                            position: 'relative',
                            marginBottom: theme.spacing.sm,
                        }}>
                            {Array.from({ length: Math.ceil(timelineWidth / PIXELS_PER_SECOND) }).map((_, i) => (
                                <div
                                    key={i}
                                    style={{
                                        position: 'absolute',
                                        left: `${i * PIXELS_PER_SECOND}px`,
                                        width: '1px',
                                        height: '15px',
                                        backgroundColor: theme.colors.border,
                                    }}
                                >
                                    <span style={{
                                        position: 'absolute',
                                        top: '-20px',
                                        left: '2px',
                                        fontSize: '12px',
                                        color: theme.colors.text.secondary,
                                        fontFamily: 'monospace',
                                    }}>
                                        {i}s
                                    </span>
                                </div>
                            ))}
                        </div>

                        {/* Empty tracks */}
                        {Array.from({ length: 3 }).map((_, index) => (
                            <div
                                key={`empty-track-${index}`}
                                style={{
                                    height: TRACK_HEIGHT,
                                    borderBottom: `1px solid ${theme.colors.border}`,
                                    position: 'relative',
                                    backgroundColor: index % 2 === 0 ? theme.colors.background.secondary : 'transparent',
                                    marginBottom: theme.spacing.sm,
                                }}
                            />
                        ))}

                        {/* Voice components with captions */}
                        {script.components
                            .filter(c => c.type === 'voice' && (c as VoiceComponent).wordTimings)
                            .map((component) => {
                                const voiceComponent = component as VoiceComponent;
                                const isUnlinked = script.captionTracks?.some(
                                    t => t.originalComponentId === component.id
                                );

                                return (
                                    <div
                                        key={component.id}
                                        style={{
                                            height: TRACK_HEIGHT,
                                            borderBottom: `1px solid ${theme.colors.border}`,
                                            position: 'relative',
                                            backgroundColor: theme.colors.background.secondary,
                                            marginBottom: theme.spacing.sm,
                                        }}
                                    >
                                        <div style={{
                                            position: 'absolute',
                                            left: `${((component.startFrame || 0) / FRAMES_PER_SECOND) * PIXELS_PER_SECOND}px`,
                                            height: TRACK_HEIGHT,
                                            backgroundColor: isUnlinked ? theme.colors.background.tertiary : theme.colors.primary,
                                            padding: '0 8px',
                                            display: 'flex',
                                            alignItems: 'center',
                                            borderRadius: theme.borderRadius.sm,
                                            cursor: 'pointer',
                                            whiteSpace: 'nowrap',
                                            overflow: 'hidden',
                                            textOverflow: 'ellipsis',
                                            minWidth: '100px',
                                        }}>
                                            <span style={{ marginRight: '8px' }}>
                                                {voiceComponent.text.substring(0, 30)}...
                                            </span>
                                            {!isUnlinked && (
                                                <button
                                                    onClick={() => handleUnlink(component.id)}
                                                    style={{
                                                        padding: '4px 8px',
                                                        backgroundColor: theme.colors.secondary,
                                                        border: 'none',
                                                        borderRadius: theme.borderRadius.sm,
                                                        cursor: 'pointer',
                                                        color: 'white',
                                                        whiteSpace: 'nowrap',
                                                    }}
                                                >
                                                    Unlink
                                                </button>
                                            )}
                                        </div>
                                    </div>
                                );
                            })}

                        {/* Caption tracks */}
                        {script.captionTracks?.map((track, index) => (
                            <div
                                key={track.id}
                                style={{
                                    height: TRACK_HEIGHT,
                                    borderBottom: `1px solid ${theme.colors.border}`,
                                    position: 'relative',
                                    backgroundColor: index % 2 === 0 ? theme.colors.background.secondary : 'transparent',
                                    marginBottom: theme.spacing.sm,
                                }}
                                onDragOver={(e) => e.preventDefault()}
                                onDrop={(e) => {
                                    e.preventDefault();
                                    setDraggingId(null);
                                }}
                            >
                                <div
                                    draggable
                                    onDragStart={(e) => handleDragStart(e, track)}
                                    onDrag={handleDrag}
                                    onDragEnd={() => setDraggingId(null)}
                                    style={{
                                        position: 'absolute',
                                        left: `${(track.startFrame / FRAMES_PER_SECOND) * PIXELS_PER_SECOND}px`,
                                        height: TRACK_HEIGHT,
                                        backgroundColor: theme.colors.secondary,
                                        padding: '0 8px',
                                        display: 'flex',
                                        alignItems: 'center',
                                        borderRadius: theme.borderRadius.sm,
                                        cursor: 'grab',
                                    }}
                                >
                                    {editingCaption === track.id ? (
                                        <input
                                            value={track.text}
                                            onChange={(e) => handleEditText(track.id, e.target.value)}
                                            onBlur={() => setEditingCaption(null)}
                                            autoFocus
                                            style={{
                                                width: '200px',
                                                padding: '4px',
                                                border: 'none',
                                                borderRadius: theme.borderRadius.sm,
                                            }}
                                        />
                                    ) : (
                                        <>
                                            <span
                                                onClick={() => setEditingCaption(track.id)}
                                                style={{ marginRight: '8px', cursor: 'text' }}
                                            >
                                                {track.text.substring(0, 20)}...
                                            </span>
                                            <button
                                                onClick={() => handleRelink(track.id)}
                                                style={{
                                                    padding: '4px 8px',
                                                    backgroundColor: theme.colors.primary,
                                                    border: 'none',
                                                    borderRadius: theme.borderRadius.sm,
                                                    cursor: 'pointer',
                                                    color: 'white',
                                                }}
                                            >
                                                Relink
                                            </button>
                                        </>
                                    )}
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            </div>

            {/* Caption Editor Modal */}
            {editingWordTimings && (
                <Modal
                    isOpen={true}
                    onClose={() => setEditingWordTimings(null)}
                    title="Edit Captions"
                >
                    <CaptionEditor
                        wordTimings={
                            editingWordTimings.isTrack
                                ? script.captionTracks?.find(t => t.id === editingWordTimings.id)?.wordTimings || []
                                : (script.components.find(c => c.id === editingWordTimings.id) as VoiceComponent)?.wordTimings || []
                        }
                        onWordTimingsChange={(newTimings) => 
                            handleWordTimingsChange(editingWordTimings.id, editingWordTimings.isTrack, newTimings)
                        }
                        onClose={() => setEditingWordTimings(null)}
                    />
                </Modal>
            )}
        </>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\ComparisonComponentEditor.tsx ---

import React from 'react';
import { ComparisonComponent, AnimationOptions } from '../../types/script';
import { ImageSelector } from '../ImageSelector';
import { theme } from '../../styles/theme';

interface ComparisonComponentEditorProps {
    component: ComparisonComponent;
    onChange: (updated: ComparisonComponent) => void;
}

export const ComparisonComponentEditor: React.FC<ComparisonComponentEditorProps> = ({
    component,
    onChange,
}) => {
    const handleStyleChange = (updated: Partial<ComparisonComponent['style']>) => {
        onChange({
            ...component,
            style: {
                ...component.style,
                ...updated
            }
        });
    };

    const handleAnimationChange = (updates: Partial<AnimationOptions>) => {
        const currentAnimation = component.style?.animation || {
            type: 'none',
            direction: 'in',
            easing: 'easeInOut',
            duration: 30,
            delay: 0,
            stagger: 0
        };
        handleStyleChange({
            animation: {
                ...currentAnimation,
                ...updates,
            }
        });
    };

    const handleBorderChange = (updates: Partial<NonNullable<ComparisonComponent['style']>['imageBorder']>) => {
        const currentBorder = component.style?.imageBorder || { enabled: false, color: '#000000', width: 1 };
        handleStyleChange({
            imageBorder: {
                ...currentBorder,
                ...updates,
            }
        });
    };

    const handleShadowChange = (updates: Partial<NonNullable<ComparisonComponent['style']>['imageDropShadow']>) => {
        const currentShadow = component.style?.imageDropShadow || { enabled: false, color: '#000000', blur: 10, spread: 0, x: 0, y: 4 };
        handleStyleChange({
            imageDropShadow: {
                ...currentShadow,
                ...updates,
            }
        });
    };

    const handlePositionChange = (updates: Partial<{ x: number; y: number }>) => {
        const currentPosition = component.style?.imagePosition || { x: 0, y: 0 };
        handleStyleChange({
            imagePosition: {
                ...currentPosition,
                ...updates
            }
        });
    };

    return (
        <div style={styles.container}>
            {/* Question */}
            <div style={styles.section}>
                <label style={styles.label}>
                    Question:
                </label>
                <input
                    type="text"
                    value={component.question}
                    onChange={(e) => {
                        onChange({
                            ...component,
                            question: e.target.value || '',
                        });
                    }}
                    style={styles.input}
                    placeholder="Enter your question..."
                />
            </div>

            {/* Settings */}
            <div style={styles.section}>
                <h4 style={styles.sectionTitle}>Settings</h4>
                <div style={styles.settingsGrid}>
                    <div>
                        <label style={styles.label}>Orientation:</label>
                        <select
                            value={component.orientation || 'horizontal'}
                            onChange={(e) => {
                                onChange({
                                    ...component,
                                    orientation: e.target.value as 'horizontal' | 'vertical'
                                });
                            }}
                            style={styles.input}
                        >
                            <option value="horizontal">Side by Side</option>
                            <option value="vertical">Top and Bottom</option>
                        </select>
                    </div>

                    <div>
                        <label style={styles.label}>Duration (frames):</label>
                        <input
                            type="number"
                            min="1"
                            value={component.durationInFrames || 150}
                            onChange={(e) => {
                                onChange({
                                    ...component,
                                    durationInFrames: parseInt(e.target.value)
                                });
                            }}
                            style={styles.input}
                        />
                    </div>
                </div>

                <div style={{ marginTop: theme.spacing.md }}>
                    <label style={{
                        ...styles.label,
                        display: 'flex',
                        alignItems: 'center',
                        gap: theme.spacing.sm,
                    }}>
                        <input
                            type="checkbox"
                            checked={component.style?.showText !== false}
                            onChange={(e) => {
                                onChange({
                                    ...component,
                                    style: {
                                        ...component.style,
                                        showText: e.target.checked
                                    }
                                });
                            }}
                        />
                        Show Text Labels
                    </label>
                </div>

                {component.style?.showText !== false && (
                    <div style={{ marginTop: theme.spacing.md }}>
                        <div style={styles.settingsGrid}>
                            <div>
                                <label style={styles.label}>Font Size:</label>
                                <input
                                    type="number"
                                    value={component.style?.fontSize || 32}
                                    onChange={(e) => {
                                        onChange({
                                            ...component,
                                            style: {
                                                ...component.style,
                                                fontSize: parseInt(e.target.value)
                                            }
                                        });
                                    }}
                                    style={styles.input}
                                />
                            </div>

                            <div>
                                <label style={styles.label}>Text Color:</label>
                                <input
                                    type="color"
                                    value={component.style?.textColor || '#ffffff'}
                                    onChange={(e) => {
                                        onChange({
                                            ...component,
                                            style: {
                                                ...component.style,
                                                textColor: e.target.value
                                            }
                                        });
                                    }}
                                    style={styles.input}
                                />
                            </div>
                        </div>
                    </div>
                )}
            </div>

            {/* Image Style Settings */}
            <div style={{ marginTop: theme.spacing.md }}>
                <h4 style={styles.sectionTitle}>Image Styles</h4>
                
                {/* Border Settings */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <div style={styles.row}>
                        <input
                            type="checkbox"
                            checked={component.style?.imageBorder?.enabled ?? false}
                            onChange={(e) => handleBorderChange({ enabled: e.target.checked })}
                            style={styles.checkbox}
                        />
                        <label style={styles.label}>Enable Border</label>
                    </div>
                    {component.style?.imageBorder?.enabled && (
                        <div style={styles.row}>
                            <input
                                type="color"
                                value={component.style.imageBorder.color ?? '#000000'}
                                onChange={(e) => handleBorderChange({ color: e.target.value })}
                                style={styles.input}
                            />
                            <input
                                type="number"
                                value={component.style.imageBorder.width ?? 1}
                                onChange={(e) => handleBorderChange({ width: Number(e.target.value) })}
                                placeholder="Width"
                                min="1"
                                max="20"
                                style={styles.input}
                            />
                        </div>
                    )}
                </div>

                {/* Drop Shadow Settings */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <div style={styles.row}>
                        <input
                            type="checkbox"
                            checked={component.style?.imageDropShadow?.enabled ?? false}
                            onChange={(e) => handleShadowChange({ enabled: e.target.checked })}
                            style={styles.checkbox}
                        />
                        <label style={styles.label}>Enable Drop Shadow</label>
                    </div>
                    {component.style?.imageDropShadow?.enabled && (
                        <>
                            <div style={styles.row}>
                                <input
                                    type="color"
                                    value={component.style.imageDropShadow.color ?? '#000000'}
                                    onChange={(e) => handleShadowChange({ color: e.target.value })}
                                    style={styles.input}
                                />
                                <input
                                    type="number"
                                    value={component.style.imageDropShadow.blur ?? 10}
                                    onChange={(e) => handleShadowChange({ blur: Number(e.target.value) })}
                                    placeholder="Blur"
                                    min="0"
                                    max="50"
                                    style={styles.input}
                                />
                            </div>
                            <div style={styles.row}>
                                <input
                                    type="number"
                                    value={component.style.imageDropShadow.x ?? 0}
                                    onChange={(e) => handleShadowChange({ x: Number(e.target.value) })}
                                    placeholder="X Offset"
                                    style={styles.input}
                                />
                                <input
                                    type="number"
                                    value={component.style.imageDropShadow.y ?? 0}
                                    onChange={(e) => handleShadowChange({ y: Number(e.target.value) })}
                                    placeholder="Y Offset"
                                    style={styles.input}
                                />
                                <input
                                    type="number"
                                    value={component.style.imageDropShadow.spread ?? 0}
                                    onChange={(e) => handleShadowChange({ spread: Number(e.target.value) })}
                                    placeholder="Spread"
                                    style={styles.input}
                                />
                            </div>
                        </>
                    )}
                </div>

                {/* Layout Settings */}
                <div style={{ marginBottom: theme.spacing.md }}>
                    <h4 style={styles.sectionTitle}>Layout</h4>
                    <div style={styles.settingsGrid}>
                        <div>
                            <label style={styles.label}>Image Size (%):</label>
                            <input
                                type="number"
                                min="10"
                                max="500"
                                value={component.style?.imageSize || 100}
                                onChange={(e) => {
                                    const size = Math.max(10, Math.min(500, parseInt(e.target.value) || 100));
                                    handleStyleChange({
                                        imageSize: size
                                    });
                                }}
                                style={styles.input}
                            />
                        </div>
                        <div>
                            <label style={styles.label}>Gap Between Images (px):</label>
                            <input
                                type="number"
                                min="0"
                                max="200"
                                value={component.style?.imageGap || 20}
                                onChange={(e) => {
                                    const gap = Math.max(0, Math.min(200, parseInt(e.target.value) || 20));
                                    handleStyleChange({
                                        imageGap: gap
                                    });
                                }}
                                style={styles.input}
                            />
                        </div>
                    </div>

                    <div style={styles.row}>
                        <input
                            type="checkbox"
                            checked={component.style?.forceSameSize ?? true}
                            onChange={(e) => handleStyleChange({ forceSameSize: e.target.checked })}
                            style={styles.checkbox}
                        />
                        <label style={styles.label}>Force Images to Same Size</label>
                    </div>

                    <div style={styles.settingsGrid}>
                        <div>
                            <label style={styles.label}>Horizontal Position (%):</label>
                            <input
                                type="range"
                                min="-100"
                                max="100"
                                value={component.style?.imagePosition?.x || 0}
                                onChange={(e) => {
                                    handlePositionChange({ x: parseInt(e.target.value) });
                                }}
                                style={styles.input}
                            />
                        </div>
                        <div>
                            <label style={styles.label}>Vertical Position (%):</label>
                            <input
                                type="range"
                                min="-100"
                                max="100"
                                value={component.style?.imagePosition?.y || 0}
                                onChange={(e) => {
                                    handlePositionChange({ y: parseInt(e.target.value) });
                                }}
                                style={styles.input}
                            />
                        </div>
                    </div>
                </div>
            </div>

            {/* Animation Controls */}
            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Animation Settings</h3>
                <div style={styles.row}>
                    <select
                        value={component.style?.animation?.type ?? 'none'}
                        onChange={(e) => handleAnimationChange({ type: e.target.value as AnimationOptions['type'] })}
                        style={styles.input}
                    >
                        <option value="none">None</option>
                        <option value="fade">Fade</option>
                        <option value="scale">Scale</option>
                        <option value="rotate">Rotate</option>
                        <option value="slide">Slide</option>
                    </select>
                </div>
                {component.style?.animation?.type !== 'none' && (
                    <>
                        <div style={styles.row}>
                            <select
                                value={component.style?.animation?.direction ?? 'in'}
                                onChange={(e) => handleAnimationChange({ direction: e.target.value as AnimationOptions['direction'] })}
                                style={styles.input}
                            >
                                <option value="in">In</option>
                                <option value="out">Out</option>
                            </select>
                            <select
                                value={component.style?.animation?.easing ?? 'easeInOut'}
                                onChange={(e) => handleAnimationChange({ easing: e.target.value as AnimationOptions['easing'] })}
                                style={styles.input}
                            >
                                <option value="linear">Linear</option>
                                <option value="easeIn">Ease In</option>
                                <option value="easeOut">Ease Out</option>
                                <option value="easeInOut">Ease In Out</option>
                            </select>
                        </div>
                        <div style={styles.row}>
                            <input
                                type="number"
                                value={component.style?.animation?.duration ?? 30}
                                onChange={(e) => handleAnimationChange({ duration: Number(e.target.value) })}
                                placeholder="Duration (frames)"
                                min="1"
                                style={styles.input}
                            />
                            <input
                                type="number"
                                value={component.style?.animation?.delay ?? 0}
                                onChange={(e) => handleAnimationChange({ delay: Number(e.target.value) })}
                                placeholder="Delay (frames)"
                                min="0"
                                style={styles.input}
                            />
                            <input
                                type="number"
                                value={component.style?.animation?.stagger ?? 0}
                                onChange={(e) => handleAnimationChange({ stagger: Number(e.target.value) })}
                                placeholder="Stagger (frames)"
                                min="0"
                                style={styles.input}
                            />
                        </div>
                    </>
                )}
            </div>

            {/* Options */}
            <div style={{
                ...styles.optionsGrid,
                gridTemplateColumns: component.orientation === 'horizontal' ? '1fr 1fr' : '1fr',
            }}>
                {/* First Option */}
                <div style={styles.optionSection}>
                    <h4 style={styles.sectionTitle}>
                        {component.orientation === 'horizontal' ? 'Left Option' : 'Top Option'}
                    </h4>
                    <input
                        type="text"
                        value={component.leftOption.text}
                        onChange={(e) => {
                            onChange({
                                ...component,
                                leftOption: {
                                    ...component.leftOption,
                                    text: e.target.value || '',
                                }
                            });
                        }}
                        style={styles.input}
                        placeholder="Enter text..."
                    />
                    <ImageSelector
                        onSelect={(url) => {
                            onChange({
                                ...component,
                                leftOption: {
                                    ...component.leftOption,
                                    imageUrl: url,
                                }
                            });
                        }}
                        searchTerm={component.leftOption.text || 'image'}
                    />
                </div>

                {/* Second Option */}
                <div style={styles.optionSection}>
                    <h4 style={styles.sectionTitle}>
                        {component.orientation === 'horizontal' ? 'Right Option' : 'Bottom Option'}
                    </h4>
                    <input
                        type="text"
                        value={component.rightOption.text}
                        onChange={(e) => {
                            onChange({
                                ...component,
                                rightOption: {
                                    ...component.rightOption,
                                    text: e.target.value || '',
                                }
                            });
                        }}
                        style={styles.input}
                        placeholder="Enter text..."
                    />
                    <ImageSelector
                        onSelect={(url) => {
                            onChange({
                                ...component,
                                rightOption: {
                                    ...component.rightOption,
                                    imageUrl: url,
                                }
                            });
                        }}
                        searchTerm={component.rightOption.text || 'image'}
                    />
                </div>
            </div>
        </div>
    );
};

const styles = {
    container: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.md,
        height: '100%',
        backgroundColor: 'transparent',
    },
    section: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.sm,
        padding: theme.spacing.md,
        backgroundColor: theme.colors.background.secondary,
        borderRadius: theme.borderRadius.md,
        border: `1px solid ${theme.colors.border}`,
    },
    sectionTitle: {
        margin: '0 0 8px 0',
        color: theme.colors.text.primary,
        fontSize: '1rem',
        fontWeight: 600,
    },
    label: {
        fontSize: '0.9rem',
        fontWeight: 500,
        color: theme.colors.text.primary,
    },
    input: {
        padding: '0.5rem',
        borderRadius: theme.borderRadius.sm,
        border: `1px solid ${theme.colors.border}`,
        backgroundColor: theme.colors.background.tertiary,
        color: theme.colors.text.primary,
        width: '100%',
        minWidth: 0,
    },
    settingsGrid: {
        display: 'grid',
        gridTemplateColumns: '1fr 1fr',
        gap: theme.spacing.sm,
    },
    optionsGrid: {
        display: 'grid',
        gap: theme.spacing.md,
    },
    optionSection: {
        backgroundColor: theme.colors.background.secondary,
        padding: theme.spacing.md,
        borderRadius: theme.borderRadius.md,
        border: `1px solid ${theme.colors.border}`,
    },
    row: {
        display: 'flex',
        gap: theme.spacing.sm,
        alignItems: 'center',
        flexWrap: 'wrap' as const,
    },
    preview: {
        width: '100%',
        maxHeight: '200px',
        objectFit: 'contain' as const,
        backgroundColor: theme.colors.background.tertiary,
        borderRadius: theme.borderRadius.md,
        marginBottom: theme.spacing.sm,
    },
    checkbox: {
        margin: 0,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\ComponentEditor.tsx ---

import React, { useState } from 'react';
import { ScriptComponent, TextStyle, TextComponent, TitleComponent, CountdownComponent } from '../../types/script';
import { TextComponentEditor } from './TextComponentEditor';
import { TitleComponentEditor } from './TitleComponentEditor';
import { ComparisonComponentEditor } from './ComparisonComponentEditor';
import { CountdownComponentEditor } from './CountdownComponentEditor';
import { VoiceComponentEditor } from './VoiceComponentEditor';
import { PositioningScreen } from './PositioningScreen';
import { theme } from '../../styles/theme';
import { VideoComponentEditor } from './VideoComponentEditor';
import { AudioComponentEditor } from './AudioComponentEditor';

export interface ComponentEditorProps {
    component: ScriptComponent;
    onChange: (updated: ScriptComponent) => void;
    onDelete: () => void;
    onEditPosition?: (componentId: string | null) => void;
}

const defaultStyle: TextStyle = {
    fontSize: 40,
    fontFamily: 'Arial',
    color: '#ffffff',
    textAlign: 'center',
};

const hasStyle = (component: ScriptComponent): component is TextComponent | TitleComponent | CountdownComponent => {
    return ['text', 'title', 'countdown'].includes(component.type);
};

export const ComponentEditor: React.FC<ComponentEditorProps> = ({
    component,
    onChange,
    onDelete,
    onEditPosition,
}) => {
    const [showPositioning, setShowPositioning] = useState(false);

    // Ensure component has a style property if it's a type that requires it
    const componentWithStyle = React.useMemo(() => {
        if (hasStyle(component) && !component.style) {
            return {
                ...component,
                style: defaultStyle,
            };
        }
        return component;
    }, [component]);

    const handlePositionChange = (position: { x: number; y: number }) => {
        if (hasStyle(componentWithStyle)) {
            onChange({
                ...componentWithStyle,
                style: {
                    ...componentWithStyle.style,
                    position: {
                        x: position.x,
                        y: position.y,
                        width: componentWithStyle.style.position?.width || 300,
                    },
                },
            });
        }
    };

    const handleDelete = () => {
        onDelete();
    };

    return (
        <div style={{
            display: 'flex',
            flexDirection: 'column',
            gap: theme.spacing.md,
        }}>
            {/* Header */}
            <div style={{
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                padding: theme.spacing.sm,
                backgroundColor: theme.colors.background.tertiary,
                borderRadius: theme.borderRadius.sm,
            }}>
                <h3 style={{
                    margin: 0,
                    fontSize: theme.fontSizes.lg,
                    color: theme.colors.text.primary,
                }}>
                    {componentWithStyle.type.charAt(0).toUpperCase() + componentWithStyle.type.slice(1)} Settings
                </h3>
                <button
                    onClick={handleDelete}
                    style={{
                        backgroundColor: theme.colors.error,
                        color: 'white',
                        border: 'none',
                        padding: `${theme.spacing.xs} ${theme.spacing.sm}`,
                        borderRadius: theme.borderRadius.sm,
                        cursor: 'pointer',
                        fontSize: theme.fontSizes.sm,
                    }}
                >
                    Delete
                </button>
            </div>

            {/* Component-specific editors */}
            <div style={{
                padding: theme.spacing.sm,
                backgroundColor: theme.colors.background.tertiary,
                borderRadius: theme.borderRadius.sm,
            }}>
                {(() => {
                    switch (componentWithStyle.type) {
                        case 'text':
                            return <TextComponentEditor component={componentWithStyle as TextComponent} onChange={onChange} />;
                        case 'title':
                            return <TitleComponentEditor component={componentWithStyle as TitleComponent} onChange={onChange} />;
                        case 'comparison':
                            return <ComparisonComponentEditor component={componentWithStyle} onChange={onChange} />;
                        case 'countdown':
                            return <CountdownComponentEditor component={componentWithStyle as CountdownComponent} onChange={onChange} />;
                        case 'voice':
                            return <VoiceComponentEditor component={componentWithStyle} onChange={onChange} />;
                        case 'video':
                            return <VideoComponentEditor component={componentWithStyle} onChange={onChange} />;
                        case 'audio':
                            return <AudioComponentEditor component={componentWithStyle} onChange={onChange} onDelete={onDelete} />;
                        default:
                            return <div>Unknown component type: {componentWithStyle.type}</div>;
                    }
                })()}
            </div>

            {/* Position Toggle */}
            {hasStyle(componentWithStyle) && (
                <div style={{
                    padding: theme.spacing.sm,
                    backgroundColor: theme.colors.background.tertiary,
                    borderRadius: theme.borderRadius.sm,
                }}>
                    <button
                        onClick={() => setShowPositioning(!showPositioning)}
                        style={{
                            width: '100%',
                            backgroundColor: showPositioning ? theme.colors.primary : 'transparent',
                            color: showPositioning ? 'white' : theme.colors.text.primary,
                            border: `1px solid ${showPositioning ? theme.colors.primary : theme.colors.border}`,
                            padding: theme.spacing.sm,
                            borderRadius: theme.borderRadius.sm,
                            cursor: 'pointer',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            gap: theme.spacing.sm,
                            transition: 'all 0.2s ease',
                        }}
                    >
                        <span>üìç</span>
                        {showPositioning ? 'Hide Position Editor' : 'Edit Position'}
                    </button>
                </div>
            )}

            {/* Positioning Screen */}
            {showPositioning && hasStyle(componentWithStyle) && (
                <PositioningScreen
                    component={componentWithStyle}
                    onPositionChange={handlePositionChange}
                    onClose={() => setShowPositioning(false)}
                />
            )}

            {/* Position display */}
            {hasStyle(componentWithStyle) && componentWithStyle.style?.position && (
                <div style={{
                    display: 'flex',
                    gap: theme.spacing.md,
                    justifyContent: 'center',
                    color: theme.colors.text.secondary,
                    fontSize: theme.fontSizes.sm,
                    padding: theme.spacing.sm,
                    backgroundColor: theme.colors.background.tertiary,
                    borderRadius: theme.borderRadius.sm,
                }}>
                    <span>X: {Math.round(componentWithStyle.style.position.x)}</span>
                    <span>Y: {Math.round(componentWithStyle.style.position.y)}</span>
                </div>
            )}
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\ComponentEditors.tsx ---

import React from 'react';
import { Component } from '../../types/script';
import { TextComponentEditor } from './TextComponentEditor';
import { ComparisonComponentEditor } from './ComparisonComponentEditor';
import { VoiceComponentEditor } from './VoiceComponentEditor';
import { VideoComponentEditor } from './VideoComponentEditor';
import { AudioComponentEditor } from './AudioComponentEditor';

interface ComponentEditorProps {
    component: Component;
    onChange: (component: Component) => void;
}

const componentEditors: Record<string, React.ComponentType<any>> = {
    text: TextComponentEditor,
    comparison: ComparisonComponentEditor,
    voice: VoiceComponentEditor,
    video: VideoComponentEditor,
    audio: AudioComponentEditor,
};

export const ComponentEditor: React.FC<ComponentEditorProps> = ({ component, onChange }) => {
    const EditorComponent = componentEditors[component.type];

    if (!EditorComponent) {
        return <div>No editor available for component type: {component.type}</div>;
    }

    return <EditorComponent component={component} onChange={onChange} />;
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\ComponentPalette.tsx ---

import React from 'react';
import { ComponentType } from '../../types/script';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';

interface ComponentPaletteProps {
    onDragStart: (type: ComponentType) => void;
}

interface ComponentOption {
    type: ComponentType;
    label: string;
    icon: string;
    description: string;
    create: () => any;
}

const components: ComponentOption[] = [
    {
        type: 'text',
        label: 'Text',
        icon: 'üìù',
        description: 'Add text with optional voice-over',
        create: () => ({
            type: 'text',
            text: '',
            style: {
                fontSize: '16px',
                fontWeight: 'normal',
                color: '#000000',
                lineHeight: '1.5',
            },
        }),
    },
    {
        type: 'title',
        label: 'Title',
        icon: 'üî§',
        description: 'Large text with optional subtitle',
        create: () => ({
            type: 'title',
            text: '',
            style: {
                fontSize: '24px',
                fontWeight: 'bold',
                color: '#000000',
                lineHeight: '1.2',
            },
        }),
    },
    {
        type: 'comparison',
        label: 'Comparison',
        icon: '‚öñÔ∏è',
        description: 'Compare two options side by side',
        create: () => ({
            type: 'comparison',
            options: [],
            style: {
                width: '100%',
                height: 'auto',
            },
        }),
    },
    {
        type: 'countdown',
        label: 'Countdown',
        icon: '‚è±Ô∏è',
        description: 'Animated countdown timer',
        create: () => ({
            type: 'countdown',
            duration: 60,
            style: {
                width: '100%',
                height: 'auto',
            },
        }),
    },
    {
        type: 'transition',
        label: 'Transition',
        icon: 'üîÑ',
        description: 'Smooth transition between scenes',
        create: () => ({
            type: 'transition',
            duration: 1,
            style: {
                width: '100%',
                height: 'auto',
            },
        }),
    },
    {
        type: 'voice',
        label: 'Voice',
        icon: 'üéôÔ∏è',
        description: 'Generate voice with synchronized captions',
        create: () => ({
            type: 'voice',
            text: '',
            style: {
                fontSize: '16px',
                fontWeight: 'normal',
                color: '#000000',
                lineHeight: '1.5',
            },
        }),
    },
    {
        type: 'video',
        label: 'Video',
        icon: 'üé¨',
        description: 'Add custom video content',
        create: () => ({
            type: 'video',
            videoUrl: '',
            style: {
                width: '100%',
                height: 'auto',
            },
        }),
    },
    {
        type: 'audio',
        label: 'Audio Effect',
        icon: 'üéµ',
        description: 'Add audio effect',
        create: () => ({
            type: 'audio',
            audioUrl: '',
            style: {
                volume: 1,
                loop: false,
                startTime: 0,
            },
        }),
    },
];

export const ComponentPalette: React.FC<ComponentPaletteProps> = ({ onDragStart }) => {
    return (
        <div>
            <h3 style={commonStyles.heading}>Components</h3>
            <div style={{
                display: 'flex',
                gap: theme.spacing.sm,
                flexWrap: 'wrap',
            }}>
                {components.map(({ type, label, icon, description }) => (
                    <div
                        key={type}
                        draggable
                        onDragStart={(e) => {
                            e.dataTransfer.setData('componentType', type);
                            onDragStart(type);
                        }}
                        style={{
                            backgroundColor: theme.colors.background.tertiary,
                            borderRadius: theme.borderRadius.md,
                            padding: theme.spacing.sm,
                            cursor: 'grab',
                            transition: 'all 0.2s ease',
                            border: `1px solid ${theme.colors.border}`,
                            flex: '0 0 auto',
                            display: 'flex',
                            alignItems: 'center',
                            gap: theme.spacing.sm,
                            minWidth: 'auto',
                        }}
                    >
                        <span style={{ fontSize: '1.2em' }}>{icon}</span>
                        <span style={{
                            color: theme.colors.text.primary,
                            fontWeight: 'bold',
                        }}>
                            {label}
                        </span>
                    </div>
                ))}
            </div>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\CountdownComponentEditor.tsx ---

import React from 'react';
import { CountdownComponent } from '../../types/script';
import { TextField, Grid, Switch, FormControlLabel } from '@mui/material';

interface CountdownComponentEditorProps {
    component: CountdownComponent;
    onChange: (component: CountdownComponent) => void;
}

export const CountdownComponentEditor: React.FC<CountdownComponentEditorProps> = ({ component, onChange }) => {
    return (
        <Grid container spacing={2}>
            <Grid item xs={12}>
                <TextField
                    fullWidth
                    type="number"
                    label="Count From"
                    value={component.from}
                    onChange={(e) => onChange({
                        ...component,
                        from: parseInt(e.target.value) || 0
                    })}
                />
            </Grid>
            <Grid item xs={12}>
                <FormControlLabel
                    control={
                        <Switch
                            checked={component.sound ?? false}
                            onChange={(e) => onChange({
                                ...component,
                                sound: e.target.checked
                            })}
                        />
                    }
                    label="Play Sound"
                />
            </Grid>
        </Grid>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\DraggablePreview.tsx ---

import React, { useState, useRef } from 'react';
import { TextStyle } from '../../types/script';

interface DraggablePreviewProps {
    text: string;
    style: TextStyle;
    onChange: (updates: Partial<TextStyle>) => void;
}

export const DraggablePreview: React.FC<DraggablePreviewProps> = ({
    text,
    style,
    onChange,
}) => {
    const containerRef = useRef<HTMLDivElement>(null);
    const elementRef = useRef<HTMLDivElement>(null);
    const [isDragging, setIsDragging] = useState(false);
    const [isResizing, setIsResizing] = useState(false);
    const [startPos, setStartPos] = useState({ x: 0, y: 0 });

    const position = style.position || { x: 50, y: 50, width: 80 };

    const handleMouseDown = (e: React.MouseEvent, mode: 'drag' | 'resize') => {
        if (mode === 'drag') setIsDragging(true);
        if (mode === 'resize') setIsResizing(true);
        setStartPos({ x: e.clientX, y: e.clientY });
        e.preventDefault();
    };

    const handleMouseMove = (e: React.MouseEvent) => {
        if (!isDragging && !isResizing) return;
        if (!containerRef.current) return;

        const containerRect = containerRef.current.getBoundingClientRect();
        
        if (isDragging) {
            const dx = e.clientX - startPos.x;
            const dy = e.clientY - startPos.y;

            const newX = position.x + (dx / containerRect.width * 100);
            const newY = position.y + (dy / containerRect.height * 100);

            onChange({
                position: {
                    ...position,
                    x: Math.max(0, Math.min(100, newX)),
                    y: Math.max(0, Math.min(100, newY)),
                }
            });
        }

        if (isResizing) {
            const dx = e.clientX - startPos.x;
            const newWidth = position.width + (dx / containerRect.width * 100);

            onChange({
                position: {
                    ...position,
                    width: Math.max(10, Math.min(100, newWidth)),
                }
            });
        }

        setStartPos({ x: e.clientX, y: e.clientY });
    };

    const handleMouseUp = () => {
        setIsDragging(false);
        setIsResizing(false);
    };

    return (
        <div
            ref={containerRef}
            style={{
                position: 'relative',
                width: '100%',
                height: '400px',
                backgroundColor: '#1a1a1a',
                borderRadius: '8px',
                overflow: 'hidden',
                cursor: isDragging ? 'grabbing' : 'default',
            }}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseUp}
        >
            <div
                ref={elementRef}
                style={{
                    position: 'absolute',
                    left: `${position.x}%`,
                    top: `${position.y}%`,
                    width: `${position.width}%`,
                    transform: 'translate(-50%, -50%)',
                    cursor: isDragging ? 'grabbing' : 'grab',
                    userSelect: 'none',
                    backgroundColor: 'rgba(255, 255, 255, 0.1)',
                    padding: '20px',
                    borderRadius: '8px',
                    border: '2px solid rgba(255, 255, 255, 0.2)',
                }}
            >
                <div
                    style={{
                        padding: '10px',
                        fontFamily: style.fontFamily,
                        fontSize: `${style.fontSize}px`,
                        color: style.color || '#fff',
                        textAlign: style.textAlign || 'center',
                        fontWeight: style.fontWeight,
                    }}
                    onMouseDown={(e) => handleMouseDown(e, 'drag')}
                >
                    {text || 'Preview text will appear here...'}
                </div>
                <div
                    style={{
                        position: 'absolute',
                        right: '-5px',
                        top: '50%',
                        transform: 'translateY(-50%)',
                        width: '10px',
                        height: '20px',
                        backgroundColor: 'rgba(255, 255, 255, 0.5)',
                        cursor: 'ew-resize',
                        borderRadius: '4px',
                    }}
                    onMouseDown={(e) => handleMouseDown(e, 'resize')}
                />
            </div>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\ImageComponentEditor.tsx ---

import React, { useState } from 'react';
import { ImageComponent } from '../../types/script';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';
import { ColorPicker } from '../common/ColorPicker';
import { Slider } from '../common/Slider';
import { Switch } from '../common/Switch';

interface PexelsImage {
    id: number;
    thumbnail: string;
    url: string;
    photographer: string;
    width: number;
    height: number;
}

interface ImageComponentEditorProps {
    component: ImageComponent;
    onChange: (component: ImageComponent) => void;
}

export const ImageComponentEditor: React.FC<ImageComponentEditorProps> = ({
    component,
    onChange,
}) => {
    const [uploadingImage, setUploadingImage] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [searchQuery, setSearchQuery] = useState('');
    const [searching, setSearching] = useState(false);
    const [pexelsImages, setPexelsImages] = useState<PexelsImage[]>([]);
    const [showPexelsSearch, setShowPexelsSearch] = useState(false);

    const handleImageUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (!file) return;

        setUploadingImage(true);
        setError(null);

        try {
            const formData = new FormData();
            formData.append('file', file);

            const response = await fetch('http://localhost:5003/upload_image', {
                method: 'POST',
                body: formData,
            });

            if (!response.ok) {
                throw new Error('Failed to upload image');
            }

            const data = await response.json();
            onChange({
                ...component,
                imageUrl: data.url,
            });
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to upload image');
        } finally {
            setUploadingImage(false);
        }
    };

    const handlePexelsSearch = async () => {
        if (!searchQuery.trim()) return;

        setSearching(true);
        setError(null);

        try {
            const response = await fetch(`http://localhost:5003/search_pexels?query=${encodeURIComponent(searchQuery)}`);
            if (!response.ok) {
                throw new Error('Failed to search Pexels');
            }

            const images = await response.json();
            setPexelsImages(images);
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to search Pexels');
        } finally {
            setSearching(false);
        }
    };

    const handlePexelsSelect = async (pexelsImage: PexelsImage) => {
        setUploadingImage(true);
        setError(null);

        try {
            const response = await fetch('http://localhost:5003/download_pexels', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ url: pexelsImage.url }),
            });

            if (!response.ok) {
                throw new Error('Failed to download image');
            }

            const data = await response.json();
            onChange({
                ...component,
                imageUrl: data.url,
                style: {
                    ...component.style,
                    width: pexelsImage.width,
                    height: pexelsImage.height,
                },
            });
            setShowPexelsSearch(false);
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to download image');
        } finally {
            setUploadingImage(false);
        }
    };

    const handleStyleChange = (updates: Partial<ImageComponent['style']>) => {
        onChange({
            ...component,
            style: {
                ...component.style,
                ...updates,
            },
        });
    };

    const handleDropShadowChange = (updates: Partial<ImageComponent['style']['dropShadow']>) => {
        handleStyleChange({
            dropShadow: {
                ...component.style?.dropShadow,
                ...updates,
            },
        });
    };

    const handleBorderChange = (updates: Partial<ImageComponent['style']['border']>) => {
        handleStyleChange({
            border: {
                ...component.style?.border,
                ...updates,
            },
        });
    };

    return (
        <div style={styles.container}>
            {/* Image Upload */}
            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Image</h3>
                <div style={styles.uploadButtons}>
                    <input
                        type="file"
                        accept="image/*"
                        onChange={handleImageUpload}
                        style={{ display: 'none' }}
                        id="image-upload"
                    />
                    <label htmlFor="image-upload" style={styles.uploadButton}>
                        {uploadingImage ? 'Uploading...' : 'Upload Image'}
                    </label>
                    <button
                        onClick={() => setShowPexelsSearch(!showPexelsSearch)}
                        style={styles.uploadButton}
                    >
                        Search Pexels
                    </button>
                </div>

                {showPexelsSearch && (
                    <div style={styles.pexelsSearch}>
                        <div style={styles.searchBar}>
                            <input
                                type="text"
                                value={searchQuery}
                                onChange={(e) => setSearchQuery(e.target.value)}
                                onKeyDown={(e) => e.key === 'Enter' && handlePexelsSearch()}
                                placeholder="Search Pexels images..."
                                style={styles.searchInput}
                            />
                            <button
                                onClick={handlePexelsSearch}
                                style={styles.searchButton}
                                disabled={searching}
                            >
                                {searching ? 'Searching...' : 'Search'}
                            </button>
                        </div>
                        <div style={styles.pexelsResults}>
                            {pexelsImages.map((image) => (
                                <div
                                    key={image.id}
                                    onClick={() => handlePexelsSelect(image)}
                                    style={styles.pexelsImage}
                                >
                                    <img
                                        src={image.thumbnail}
                                        alt={`By ${image.photographer}`}
                                        style={styles.pexelsThumbnail}
                                    />
                                    <div style={styles.photographerCredit}>
                                        By {image.photographer}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                )}

                {error && <div style={styles.error}>{error}</div>}
                {component.imageUrl && (
                    <img
                        src={component.imageUrl}
                        alt="Preview"
                        style={styles.preview}
                    />
                )}
            </div>

            {/* Size and Position */}
            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Size & Position</h3>
                <Slider
                    label="Width"
                    value={component.style?.width ?? 400}
                    onChange={(value) => handleStyleChange({ width: value })}
                    min={50}
                    max={1920}
                />
                <Slider
                    label="Height"
                    value={component.style?.height ?? 400}
                    onChange={(value) => handleStyleChange({ height: value })}
                    min={50}
                    max={1080}
                />
                <Slider
                    label="X Position"
                    value={component.style?.position?.x ?? 0}
                    onChange={(value) => handleStyleChange({ position: { ...component.style?.position, x: value } })}
                    min={-1920}
                    max={1920}
                />
                <Slider
                    label="Y Position"
                    value={component.style?.position?.y ?? 0}
                    onChange={(value) => handleStyleChange({ position: { ...component.style?.position, y: value } })}
                    min={-1080}
                    max={1080}
                />
            </div>

            {/* Transform */}
            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Transform</h3>
                <Slider
                    label="Scale"
                    value={component.style?.scale ?? 1}
                    onChange={(value) => handleStyleChange({ scale: value })}
                    min={0.1}
                    max={5}
                    step={0.1}
                />
                <Slider
                    label="Rotation"
                    value={component.style?.rotation ?? 0}
                    onChange={(value) => handleStyleChange({ rotation: value })}
                    min={-180}
                    max={180}
                />
                <Slider
                    label="Opacity"
                    value={component.style?.opacity ?? 1}
                    onChange={(value) => handleStyleChange({ opacity: value })}
                    min={0}
                    max={1}
                    step={0.1}
                />
            </div>

            {/* Border */}
            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Border</h3>
                <Switch
                    label="Enable Border"
                    checked={component.style?.border?.enabled ?? false}
                    onChange={(checked) => handleBorderChange({ enabled: checked })}
                />
                {component.style?.border?.enabled && (
                    <>
                        <ColorPicker
                            label="Border Color"
                            color={component.style.border.color}
                            onChange={(color) => handleBorderChange({ color })}
                        />
                        <Slider
                            label="Border Width"
                            value={component.style.border.width}
                            onChange={(value) => handleBorderChange({ width: value })}
                            min={1}
                            max={20}
                        />
                    </>
                )}
            </div>

            {/* Drop Shadow */}
            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Drop Shadow</h3>
                <Switch
                    label="Enable Shadow"
                    checked={component.style?.dropShadow?.enabled ?? false}
                    onChange={(checked) => handleDropShadowChange({ enabled: checked })}
                />
                {component.style?.dropShadow?.enabled && (
                    <>
                        <ColorPicker
                            label="Shadow Color"
                            color={component.style.dropShadow.color}
                            onChange={(color) => handleDropShadowChange({ color })}
                        />
                        <Slider
                            label="Blur Radius"
                            value={component.style.dropShadow.blur}
                            onChange={(value) => handleDropShadowChange({ blur: value })}
                            min={0}
                            max={50}
                        />
                        <Slider
                            label="Spread"
                            value={component.style.dropShadow.spread}
                            onChange={(value) => handleDropShadowChange({ spread: value })}
                            min={0}
                            max={50}
                        />
                        <Slider
                            label="X Offset"
                            value={component.style.dropShadow.x}
                            onChange={(value) => handleDropShadowChange({ x: value })}
                            min={-50}
                            max={50}
                        />
                        <Slider
                            label="Y Offset"
                            value={component.style.dropShadow.y}
                            onChange={(value) => handleDropShadowChange({ y: value })}
                            min={-50}
                            max={50}
                        />
                    </>
                )}
            </div>
        </div>
    );
};

const styles = {
    container: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.lg,
    },
    section: {
        backgroundColor: theme.colors.background.secondary,
        padding: theme.spacing.md,
        borderRadius: theme.borderRadius.md,
    },
    sectionTitle: {
        margin: 0,
        marginBottom: theme.spacing.sm,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.md,
    },
    uploadButtons: {
        display: 'flex',
        gap: theme.spacing.sm,
        marginBottom: theme.spacing.md,
    },
    uploadButton: {
        ...commonStyles.button.primary,
        display: 'inline-block',
        cursor: 'pointer',
        marginBottom: theme.spacing.md,
    },
    preview: {
        width: '100%',
        height: '200px',
        objectFit: 'cover' as const,
        borderRadius: theme.borderRadius.sm,
        marginTop: theme.spacing.sm,
    },
    error: {
        color: theme.colors.error,
        marginTop: theme.spacing.sm,
        fontSize: theme.fontSizes.sm,
    },
    pexelsSearch: {
        marginTop: theme.spacing.md,
    },
    searchBar: {
        display: 'flex',
        gap: theme.spacing.sm,
        marginBottom: theme.spacing.md,
    },
    searchInput: {
        flex: 1,
        padding: theme.spacing.sm,
        backgroundColor: theme.colors.background.tertiary,
        border: `1px solid ${theme.colors.border}`,
        borderRadius: theme.borderRadius.sm,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
    },
    searchButton: {
        ...commonStyles.button.primary,
    },
    pexelsResults: {
        display: 'grid',
        gridTemplateColumns: 'repeat(auto-fill, minmax(150px, 1fr))',
        gap: theme.spacing.md,
        maxHeight: '400px',
        overflowY: 'auto',
    },
    pexelsImage: {
        cursor: 'pointer',
        borderRadius: theme.borderRadius.sm,
        overflow: 'hidden',
        backgroundColor: theme.colors.background.tertiary,
        transition: 'transform 0.2s',
        '&:hover': {
            transform: 'scale(1.05)',
        },
    },
    pexelsThumbnail: {
        width: '100%',
        height: '150px',
        objectFit: 'cover' as const,
    },
    photographerCredit: {
        padding: theme.spacing.xs,
        fontSize: theme.fontSizes.xs,
        color: theme.colors.text.secondary,
        textAlign: 'center' as const,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\PositioningScreen.tsx ---

import React, { useRef, useState, useEffect, useCallback } from 'react';
import { TextComponent } from '../../types/script';
import { theme } from '../../styles/theme';

const PREVIEW_WIDTH = 400; // Doubled from 200
const PREVIEW_HEIGHT = 712; // Doubled from 356
const SCALE_FACTOR = 2.7; // Halved from 5.4 since we doubled the preview size

interface Props {
    component: TextComponent;
    onPositionChange: (position: { x: number; y: number }) => void;
    onClose: () => void;
}

const getInitialPosition = (component: TextComponent) => {
    if (component.style?.position) {
        return {
            x: component.style.position.x / SCALE_FACTOR,
            y: component.style.position.y / SCALE_FACTOR,
        };
    }
    return {
        x: PREVIEW_WIDTH / 2,
        y: PREVIEW_HEIGHT / 2,
    };
};

export const PositioningScreen: React.FC<Props> = React.memo(({ component, onPositionChange, onClose }) => {
    const containerRef = useRef<HTMLDivElement>(null);
    const [state, setState] = useState(() => ({
        isDragging: false,
        position: getInitialPosition(component)
    }));

    const updatePosition = useCallback((clientX: number, clientY: number) => {
        if (containerRef.current) {
            const rect = containerRef.current.getBoundingClientRect();
            const x = Math.min(Math.max(0, clientX - rect.left), PREVIEW_WIDTH);
            const y = Math.min(Math.max(0, clientY - rect.top), PREVIEW_HEIGHT);
            
            setState(prev => ({
                ...prev,
                position: { x, y }
            }));
            onPositionChange({
                x: Math.round(x * SCALE_FACTOR),
                y: Math.round(y * SCALE_FACTOR),
            });
        }
    }, [onPositionChange]);

    const handleMouseDown = useCallback((e: React.MouseEvent) => {
        setState(prev => ({ ...prev, isDragging: true }));
        updatePosition(e.clientX, e.clientY);
    }, [updatePosition]);

    const handleMouseMove = useCallback((e: MouseEvent) => {
        if (state.isDragging) {
            updatePosition(e.clientX, e.clientY);
        }
    }, [state.isDragging, updatePosition]);

    const handleMouseUp = useCallback(() => {
        setState(prev => ({ ...prev, isDragging: false }));
    }, []);

    useEffect(() => {
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        return () => {
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
        };
    }, [handleMouseMove, handleMouseUp]);

    return (
        <div style={{
            display: 'flex',
            flexDirection: 'column',
            gap: theme.spacing.sm,
        }}>
            <div
                ref={containerRef}
                onMouseDown={handleMouseDown}
                style={{
                    width: PREVIEW_WIDTH,
                    height: PREVIEW_HEIGHT,
                    backgroundColor: '#1a1a1a',
                    position: 'relative',
                    borderRadius: theme.borderRadius.sm,
                    overflow: 'hidden',
                    cursor: state.isDragging ? 'grabbing' : 'grab',
                }}
            >
                {/* Grid lines */}
                <div style={{
                    position: 'absolute',
                    inset: 0,
                    backgroundImage: `
                        linear-gradient(to right, #333 1px, transparent 1px),
                        linear-gradient(to bottom, #333 1px, transparent 1px)
                    `,
                    backgroundSize: '40px 40px',
                    opacity: 0.5,
                    pointerEvents: 'none',
                }} />

                {/* Center dot */}
                <div
                    style={{
                        position: 'absolute',
                        left: state.position.x,
                        top: state.position.y,
                        width: 8,
                        height: 8,
                        backgroundColor: theme.colors.primary,
                        borderRadius: '50%',
                        transform: 'translate(-50%, -50%)',
                        pointerEvents: 'none',
                        boxShadow: '0 0 0 2px rgba(255, 255, 255, 0.3)',
                    }}
                />
            </div>

            {/* Position display */}
            <div style={{
                display: 'flex',
                gap: theme.spacing.md,
                justifyContent: 'center',
                color: theme.colors.text.secondary,
                fontSize: theme.fontSizes.sm,
            }}>
                <span>X: {Math.round(state.position.x * SCALE_FACTOR)}</span>
                <span>Y: {Math.round(state.position.y * SCALE_FACTOR)}</span>
            </div>
        </div>
    );
}); 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\ScriptEditor.tsx ---

import React, { useState } from 'react';
import { Script, ScriptComponent, ComponentType } from '../../types/script';
import { ComponentEditor } from './ComponentEditor';
import { StyleEditor } from './StyleEditor';
import { Player } from '@remotion/player';
import { ScriptVideo } from '../Video/ScriptVideo';
import { ComponentPalette } from './ComponentPalette';
import { Timeline } from './Timeline';
import '../../styles/timeline.css';
import { ConfigMenu } from '../ConfigMenu/ConfigMenu';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';
import { Modal } from '../common/Modal';
import { TemplateManager } from '../TemplateManager/TemplateManager';
import { CaptionTimeline } from './CaptionTimeline';

export const ScriptEditor: React.FC = () => {
    const [script, setScript] = useState<Script>({
        id: Date.now().toString(),
        title: 'New Quiz',
        components: [],
        captionTracks: [],
        settings: {
            defaultTextStyle: {
                fontSize: 40,
                color: 'white',
                fontFamily: 'Arial',
                textAlign: 'center',
            },
            defaultCaptionStyle: {
                fontSize: 24,
                color: 'white',
                fontFamily: 'Arial',
                textAlign: 'center',
            },
            background: {
                type: 'none',
            }
        },
    });

    const [selectedComponentId, setSelectedComponentId] = useState<string>();
    const [isConfigOpen, setIsConfigOpen] = useState(false);
    const [isTemplateManagerOpen, setIsTemplateManagerOpen] = useState(false);

    const handleComponentChange = (updated: ScriptComponent) => {
        setScript(prev => ({
            ...prev,
            components: prev.components.map(c => 
                c.id === updated.id ? updated : c
            ),
        }));
    };

    const handleComponentDelete = (id: string) => {
        setScript(prev => ({
            ...prev,
            components: prev.components.filter(c => c.id !== id),
        }));
        setSelectedComponentId(undefined);
    };

    const handleDragStart = (type: ComponentType) => {
        // This can be empty or add visual feedback
    };

    const handleReorder = (newComponents: ScriptComponent[]) => {
        setScript(prev => ({
            ...prev,
            components: newComponents,
        }));
    };

    const selectedComponent = script.components.find(c => c.id === selectedComponentId);

    // Calculate total duration, minimum 30 frames (1 second)
    const totalDuration = Math.max(
        ...script.components.map(comp => {
            const start = comp.startFrame || 0;
            const duration = comp.durationInFrames || 150; // Default 5 seconds if not specified
            return start + duration;
        }),
        30 // Minimum 1 second
    );

    const PreviewPanel = ({ script }: { script: Script }) => (
        <>
            <div style={{
                padding: theme.spacing.md,
                borderBottom: `1px solid ${theme.colors.border}`,
                backgroundColor: theme.colors.background.secondary,
            }}>
                <h3 style={{
                    ...commonStyles.heading,
                    margin: 0,
                    fontSize: '16px',
                }}>
                    Preview
                </h3>
            </div>
            <div style={{
                flex: 1,
                padding: theme.spacing.md,
                display: 'flex',
                flexDirection: 'column',
                gap: theme.spacing.md,
            }}>
                <div style={{
                    position: 'relative',
                    width: '100%',
                    aspectRatio: '9/16',
                    backgroundColor: '#000',
                    borderRadius: theme.borderRadius.md,
                    overflow: 'hidden',
                }}>
                    <Player
                        component={ScriptVideo}
                        durationInFrames={totalDuration}
                        fps={30}
                        compositionWidth={1080}
                        compositionHeight={1920}
                        style={{
                            width: '100%',
                            height: '100%',
                        }}
                        controls
                        autoPlay
                        loop
                        inputProps={{ script }}
                    />
                </div>
            </div>
        </>
    );

    return (
        <div style={{
            backgroundColor: theme.colors.background.primary,
            minHeight: '100vh',
            display: 'flex',
            flexDirection: 'column',
        }}>
            {/* Header */}
            <header style={{
                backgroundColor: theme.colors.background.secondary,
                padding: `${theme.spacing.sm} ${theme.spacing.md}`,
                borderBottom: `1px solid ${theme.colors.border}`,
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                height: '48px',
            }}>
                <h1 style={{ margin: 0, fontSize: '24px' }}>Video Editor</h1>
                <div style={{ display: 'flex', gap: theme.spacing.md }}>
                    <button
                        onClick={() => setIsTemplateManagerOpen(true)}
                        style={{
                            ...commonStyles.button.secondary,
                            display: 'flex',
                            alignItems: 'center',
                            gap: theme.spacing.sm,
                        }}
                    >
                        üìã Templates
                    </button>
                    <button
                        onClick={() => setIsConfigOpen(true)}
                        style={{
                            ...commonStyles.button.secondary,
                            display: 'flex',
                            alignItems: 'center',
                            gap: theme.spacing.sm,
                        }}
                    >
                        ‚öôÔ∏è Settings
                    </button>
                </div>
            </header>

            {/* Main Content */}
            <div style={{
                display: 'grid',
                gridTemplateColumns: '4fr 1fr',
                gap: theme.spacing.sm,
                padding: theme.spacing.sm,
                flex: 1,
                height: 'calc(100vh - 48px)',
                overflow: 'hidden',
            }}>
                {/* Left Panel */}
                <div style={{
                    display: 'flex',
                    flexDirection: 'column',
                    gap: theme.spacing.sm,
                    overflow: 'hidden',
                }}>
                    {/* Component Palette */}
                    <div style={{
                        ...commonStyles.card,
                        padding: theme.spacing.sm,
                    }}>
                        <ComponentPalette onDragStart={handleDragStart} />
                    </div>

                    {/* Timeline Container */}
                    <div style={{
                        ...commonStyles.card,
                        padding: theme.spacing.sm,
                        display: 'flex',
                        flexDirection: 'column',
                        gap: theme.spacing.md,
                        overflow: 'visible',
                    }}>
                        {/* Main Timeline */}
                        <div>
                            <h3 style={{ 
                                color: theme.colors.text.primary, 
                                margin: 0,
                                marginBottom: theme.spacing.md,
                                fontSize: '16px',
                                fontWeight: 'bold',
                            }}>
                                Timeline
                            </h3>
                            <Timeline
                                script={script}
                                onReorder={handleReorder}
                                onSelect={setSelectedComponentId}
                                selectedId={selectedComponentId}
                                onDelete={handleComponentDelete}
                            />
                        </div>

                        {/* Caption Timeline */}
                        <CaptionTimeline
                            script={script}
                            onScriptChange={setScript}
                        />
                    </div>
                </div>

                {/* Right Panel */}
                <div style={{
                    flex: 1,
                    display: 'flex',
                    flexDirection: 'column',
                    padding: theme.spacing.md,
                    backgroundColor: theme.colors.background.primary,
                    overflow: 'auto',
                }}>
                    {/* Preview */}
                    <div style={{
                        position: 'relative',
                        width: '100%',
                        maxWidth: '300px',
                        margin: '0 auto',
                        aspectRatio: '9/16',
                        backgroundColor: '#000',
                        borderRadius: theme.borderRadius.lg,
                        overflow: 'hidden',
                    }}>
                        <Player
                            component={ScriptVideo}
                            durationInFrames={totalDuration}
                            fps={30}
                            compositionWidth={1080}
                            compositionHeight={1920}
                            style={{
                                width: '100%',
                                height: '100%',
                            }}
                            controls
                            autoPlay
                            loop
                            inputProps={{
                                script
                            }}
                        />
                    </div>
                </div>
            </div>

            {/* Component Editor Modal */}
            <Modal
                isOpen={!!selectedComponentId}
                onClose={() => setSelectedComponentId(undefined)}
                title={
                    selectedComponent && (
                        <h2 style={{
                            ...commonStyles.heading,
                            margin: 0,
                            display: 'flex',
                            alignItems: 'center',
                            gap: theme.spacing.sm,
                            color: theme.colors.text.primary,
                            fontSize: '20px',
                        }}>
                            <span style={{ fontSize: '1.2em' }}>
                                {selectedComponent.type === 'title' && 'üìë'}
                                {selectedComponent.type === 'text' && 'üìù'}
                                {selectedComponent.type === 'comparison' && '‚öñÔ∏è'}
                                {selectedComponent.type === 'countdown' && '‚è≤Ô∏è'}
                                {selectedComponent.type === 'transition' && 'üîÑ'}
                            </span>
                            Edit {selectedComponent.type.charAt(0).toUpperCase() + selectedComponent.type.slice(1)}
                        </h2>
                    )
                }
            >
                {selectedComponent && (
                    <ComponentEditor
                        component={selectedComponent}
                        onChange={handleComponentChange}
                        onDelete={handleComponentDelete}
                    />
                )}
            </Modal>

            <ConfigMenu 
                isOpen={isConfigOpen} 
                onClose={() => setIsConfigOpen(false)} 
                script={script}
                onScriptChange={setScript}
            />

            {/* Template Manager Modal */}
            <Modal
                isOpen={isTemplateManagerOpen}
                onClose={() => setIsTemplateManagerOpen(false)}
                title="Template Manager"
            >
                <TemplateManager
                    currentScript={script}
                    onTemplateSelect={(newScript) => {
                        setScript(newScript);
                        setIsTemplateManagerOpen(false);
                    }}
                />
            </Modal>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\TextComponentEditor.tsx ---

import React, { useState, useEffect } from 'react';
import { TextComponent } from '../../types/script';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';
import { PositioningScreen } from './PositioningScreen';

interface TextComponentEditorProps {
    component: TextComponent;
    onChange: (updated: TextComponent) => void;
}

// Predefined fonts list
const FONTS = {
    system: [
        'Arial',
        'Helvetica',
        'Times New Roman',
        'Georgia',
        'Verdana',
        'Roboto',
        'Open Sans',
        'Montserrat',
    ],
    getCustomFonts: (): string[] => {
        try {
            const savedFonts = localStorage.getItem('customFonts');
            if (savedFonts) {
                const fonts = JSON.parse(savedFonts);
                return fonts.map((font: { name: string }) => font.name);
            }
        } catch (error) {
            console.error('Error loading custom fonts:', error);
        }
        return [];
    },
};

const styles = {
    section: {
        backgroundColor: theme.colors.background.tertiary,
        padding: theme.spacing.md,
        borderRadius: theme.borderRadius.md,
        marginBottom: theme.spacing.md,
    },
    sectionTitle: {
        fontSize: '14px',
        fontWeight: 'bold',
        color: theme.colors.text.primary,
        margin: 0,
        marginBottom: theme.spacing.sm,
    },
    input: {
        width: '100%',
        padding: '10px 14px',
        borderRadius: '8px',
        border: `1px solid ${theme.colors.border}`,
        backgroundColor: theme.colors.background.tertiary,
        color: theme.colors.text.primary,
        fontSize: '14px',
        '&:focus': {
            outline: 'none',
            borderColor: theme.colors.primary,
        },
    },
    textarea: {
        ...commonStyles.input,
        minHeight: '120px',
        resize: 'vertical' as const,
        whiteSpace: 'pre-wrap',
        lineHeight: '1.5',
        padding: '12px 16px',
    },
    grid: {
        display: 'grid',
        gridTemplateColumns: 'repeat(2, 1fr)',
        gap: '20px',
    },
    previewArea: {
        width: '1920px',
        height: '1080px',
        backgroundColor: 'rgba(0, 0, 0, 0.8)',
        position: 'relative' as const,
        transform: 'scale(0.25)',
        transformOrigin: 'top left',
        cursor: 'pointer',
    },
    animationTimingGrid: {
        marginTop: '12px',
        display: 'grid',
        gap: '12px',
        gridTemplateColumns: '1fr 1fr',
    },
    animationInput: {
        width: '100%',
        padding: '8px 12px',
        borderRadius: '6px',
        border: `1px solid ${theme.colors.border}`,
        backgroundColor: theme.colors.background.tertiary,
        color: theme.colors.text.primary,
        fontSize: '14px',
        fontFamily: 'monospace',
    },
    animationLabel: {
        fontWeight: 'bold',
        marginBottom: '6px',
        color: theme.colors.text.primary,
        fontSize: '12px',
    },
};

export const TextComponentEditor: React.FC<TextComponentEditorProps> = ({
    component,
    onChange,
}) => {
    const style = component.style || {};
    const [customFonts, setCustomFonts] = useState<string[]>([]);
    const [isPositioningPopupOpen, setIsPositioningPopupOpen] = useState(false);

    useEffect(() => {
        const updateCustomFonts = () => {
            setCustomFonts(FONTS.getCustomFonts());
        };

        updateCustomFonts();
        window.addEventListener('storage', updateCustomFonts);
        return () => window.removeEventListener('storage', updateCustomFonts);
    }, []);

    const handleTextChange = (text: string) => {
        if (text && style.wordsPerLine && style.wordsPerLine > 0) {
            const cleanText = text.replace(/[\n\r]+/g, ' ').replace(/\s+/g, ' ').trim();
            const words = cleanText.split(' ');
            const lines = [];
            
            for (let i = 0; i < words.length; i += style.wordsPerLine) {
                const line = words.slice(i, i + style.wordsPerLine).join(' ');
                if (line) lines.push(line);
            }
            
            text = lines.join('\n');
        }

        onChange({
            ...component,
            text,
        });
    };

    const handleBlockStyleToggle = (value: string) => {
        console.log('Block style changed to:', value);
        
        let backgroundColor, textColor;
        if (value === 'white') {
            backgroundColor = '#FFFFFF';
            textColor = '#000000';
        } else if (value === 'black') {
            backgroundColor = '#000000';
            textColor = '#FFFFFF';
        } else {
            backgroundColor = undefined;
            textColor = '#FFFFFF';
        }

        console.log('Setting colors:', { backgroundColor, textColor });
        
        const newStyle = {
            ...style,
            blockStyle: { enabled: value !== 'disabled' },
            backgroundColor,
            color: textColor,
            textTransform: value !== 'disabled' ? 'uppercase' as const : 'none' as const,
            fontWeight: value !== 'disabled' ? 'bold' : 'normal',
            padding: value !== 'disabled' ? '20px 40px' : undefined,
            borderRadius: value !== 'disabled' ? '15px' : undefined,
            textAlign: value !== 'disabled' ? 'center' as const : (style.textAlign || 'center'),
        };
        
        console.log('New style:', newStyle);
        
        onChange({
            ...component,
            style: newStyle,
        });
    };

    const handlePositionChange = (position: { x: number; y: number }) => {
        onChange({
            ...component,
            style: {
                ...style,
                position,
            },
        });
    };

    return (
        <>
            {/* Basic Settings */}
            <div style={styles.grid}>
                <div>
                    <label style={styles.sectionTitle}>Duration (seconds)</label>
                    <input
                        type="number"
                        value={component.durationInFrames / 30}
                        onChange={(e) => onChange({
                            ...component,
                            durationInFrames: Math.max(1, parseFloat(e.target.value)) * 30,
                        })}
                        style={styles.input}
                        min="0.1"
                        step="0.1"
                    />
                </div>
                <div>
                    <label style={styles.sectionTitle}>Block Style</label>
                    <select
                        value={style.blockStyle?.enabled ? 
                            (style.backgroundColor === '#FFFFFF' ? 'white' : 'black') 
                            : 'disabled'}
                        onChange={(e) => handleBlockStyleToggle(e.target.value)}
                        style={styles.input}
                    >
                        <option value="disabled">Normal Text</option>
                        <option value="white">White Block with Black Text</option>
                        <option value="black">Black Block with White Text</option>
                    </select>
                </div>
            </div>

            {/* Content */}
            <div style={{ marginTop: theme.spacing.lg }}>
                <div style={{
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    marginBottom: theme.spacing.sm,
                }}>
                    <h3 style={styles.sectionTitle}>Content</h3>
                    <button style={{
                        backgroundColor: 'rgb(255, 75, 75)',
                        color: 'white',
                        border: 'none',
                        padding: '4px 8px',
                        borderRadius: '4px',
                        cursor: 'pointer',
                        fontSize: '13px',
                    }}>Delete</button>
                </div>
                <textarea
                    value={component.text}
                    onChange={(e) => handleTextChange(e.target.value)}
                    style={styles.textarea}
                    placeholder="Enter your text..."
                />
            </div>

            {/* Font Settings */}
            <div style={{ marginTop: theme.spacing.lg }}>
                <h3 style={styles.sectionTitle}>Font Settings</h3>
                <div style={styles.grid}>
                    <div>
                        <label style={styles.sectionTitle}>Font Family</label>
                        <select
                            value={style.fontFamily}
                            onChange={(e) => onChange({
                                ...component,
                                style: {
                                    ...style,
                                    fontFamily: e.target.value,
                                },
                            })}
                            style={styles.input}
                        >
                            <optgroup label="System Fonts">
                                {FONTS.system.map(font => (
                                    <option key={font} value={font}>{font}</option>
                                ))}
                            </optgroup>
                            {customFonts.length > 0 && (
                                <optgroup label="Custom Fonts">
                                    {customFonts.map(font => (
                                        <option key={font} value={font}>{font}</option>
                                    ))}
                                </optgroup>
                            )}
                        </select>
                    </div>
                    <div>
                        <label style={styles.sectionTitle}>Font Size (px)</label>
                        <input
                            type="number"
                            value={style.fontSize}
                            onChange={(e) => onChange({
                                ...component,
                                style: {
                                    ...style,
                                    fontSize: parseInt(e.target.value),
                                },
                            })}
                            style={styles.input}
                            min="12"
                            max="200"
                        />
                    </div>
                    <div>
                        <label style={styles.sectionTitle}>Font Weight</label>
                        <select
                            value={style.fontWeight}
                            onChange={(e) => onChange({
                                ...component,
                                style: {
                                    ...style,
                                    fontWeight: e.target.value,
                                },
                            })}
                            style={styles.input}
                        >
                            <option value="300">Light</option>
                            <option value="400">Regular</option>
                            <option value="500">Medium</option>
                            <option value="600">Semi Bold</option>
                            <option value="700">Bold</option>
                            <option value="800">Extra Bold</option>
                        </select>
                    </div>
                    <div>
                        <label style={styles.sectionTitle}>Line Height</label>
                        <select
                            value={style.lineHeight || '1.5'}
                            onChange={(e) => onChange({
                                ...component,
                                style: {
                                    ...style,
                                    lineHeight: e.target.value,
                                },
                            })}
                            style={styles.input}
                        >
                            <option value="1">Tight</option>
                            <option value="1.2">Compact</option>
                            <option value="1.5">Normal</option>
                            <option value="1.8">Relaxed</option>
                            <option value="2">Spacious</option>
                        </select>
                    </div>
                </div>
            </div>

            {/* Style Settings */}
            <div style={{ marginTop: theme.spacing.lg }}>
                <h3 style={styles.sectionTitle}>Style Settings</h3>
                <div style={styles.grid}>
                    <div>
                        <label style={styles.sectionTitle}>Text Color</label>
                        <div style={{ display: 'flex', gap: '8px' }}>
                            <input
                                type="color"
                                value={style.color || '#FFFFFF'}
                                onChange={(e) => onChange({
                                    ...component,
                                    style: {
                                        ...style,
                                        color: e.target.value,
                                    },
                                })}
                                style={{ ...styles.input, width: '50px', padding: '2px' }}
                            />
                            <input
                                type="text"
                                value={style.color || '#FFFFFF'}
                                onChange={(e) => onChange({
                                    ...component,
                                    style: {
                                        ...style,
                                        color: e.target.value,
                                    },
                                })}
                                style={{ ...styles.input, flex: 1 }}
                                placeholder="#FFFFFF"
                            />
                        </div>
                    </div>
                    <div>
                        <label style={styles.sectionTitle}>Text Alignment</label>
                        <select
                            value={style.textAlign || 'center'}
                            onChange={(e) => onChange({
                                ...component,
                                style: {
                                    ...style,
                                    textAlign: e.target.value as 'left' | 'center' | 'right' | 'justify',
                                },
                            })}
                            style={styles.input}
                        >
                            <option value="left">Left</option>
                            <option value="center">Center</option>
                            <option value="right">Right</option>
                            <option value="justify">Justify</option>
                        </select>
                    </div>
                </div>
            </div>

            {/* Animation Settings */}
            <div style={{ marginTop: theme.spacing.lg }}>
                <h3 style={styles.sectionTitle}>Animation Settings</h3>
                <div style={styles.grid}>
                    <div>
                        <label style={styles.sectionTitle}>Entrance Animation</label>
                        <select
                            value={style.animation?.in?.type || 'none'}
                            onChange={(e) => onChange({
                                ...component,
                                style: {
                                    ...style,
                                    animation: {
                                        ...style.animation,
                                        in: {
                                            ...style.animation?.in,
                                            type: e.target.value,
                                            startFrame: style.animation?.in?.startFrame || 0,
                                            endFrame: style.animation?.in?.endFrame || 30,
                                        },
                                    },
                                },
                            })}
                            style={styles.input}
                        >
                            <option value="none">None</option>
                            <option value="slide-left">Slide In from Left</option>
                            <option value="slide-right">Slide In from Right</option>
                        </select>
                        {style.animation?.in?.type && style.animation.in.type !== 'none' && (
                            <div style={styles.animationTimingGrid}>
                                <div>
                                    <label style={styles.animationLabel}>Start Frame</label>
                                    <input
                                        type="number"
                                        value={style.animation?.in?.startFrame ?? 0}
                                        onChange={(e) => {
                                            const newValue = parseInt(e.target.value);
                                            if (!isNaN(newValue)) {
                                                console.log('Updating in animation start frame to:', newValue);
                                                const updatedStyle = {
                                                    ...style,
                                                    animation: {
                                                        ...style.animation,
                                                        in: {
                                                            ...style.animation?.in,
                                                            startFrame: newValue,
                                                        },
                                                    },
                                                };
                                                console.log('Updated style:', updatedStyle);
                                                onChange({
                                                    ...component,
                                                    style: updatedStyle,
                                                });
                                            }
                                        }}
                                        style={styles.animationInput}
                                        min="0"
                                    />
                                </div>
                                <div>
                                    <label style={styles.animationLabel}>End Frame</label>
                                    <input
                                        type="number"
                                        value={style.animation?.in?.endFrame ?? 30}
                                        onChange={(e) => {
                                            const newValue = parseInt(e.target.value);
                                            if (!isNaN(newValue)) {
                                                console.log('Updating in animation end frame to:', newValue);
                                                const updatedStyle = {
                                                    ...style,
                                                    animation: {
                                                        ...style.animation,
                                                        in: {
                                                            ...style.animation?.in,
                                                            endFrame: newValue,
                                                        },
                                                    },
                                                };
                                                console.log('Updated style:', updatedStyle);
                                                onChange({
                                                    ...component,
                                                    style: updatedStyle,
                                                });
                                            }
                                        }}
                                        style={styles.animationInput}
                                        min={style.animation?.in?.startFrame ?? 0}
                                    />
                                </div>
                            </div>
                        )}
                    </div>
                    <div>
                        <label style={styles.sectionTitle}>Exit Animation</label>
                        <select
                            value={style.animation?.out?.type || 'none'}
                            onChange={(e) => {
                                const updatedStyle = {
                                    ...style,
                                    animation: {
                                        ...style.animation,
                                        out: {
                                            ...style.animation?.out,
                                            type: e.target.value,
                                            startFrame: style.animation?.out?.startFrame ?? 30,
                                            endFrame: style.animation?.out?.endFrame ?? 0,
                                        },
                                    },
                                };
                                console.log('Updated exit animation style:', updatedStyle);
                                onChange({
                                    ...component,
                                    style: updatedStyle,
                                });
                            }}
                            style={styles.input}
                        >
                            <option value="none">None</option>
                            <option value="slide-left">Slide Out to Left</option>
                            <option value="slide-right">Slide Out to Right</option>
                        </select>
                        {style.animation?.out?.type && style.animation.out.type !== 'none' && (
                            <div style={styles.animationTimingGrid}>
                                <div>
                                    <label style={styles.animationLabel}>Start Frame (from end)</label>
                                    <input
                                        type="number"
                                        value={style.animation?.out?.startFrame ?? 30}
                                        onChange={(e) => {
                                            const newValue = parseInt(e.target.value);
                                            if (!isNaN(newValue)) {
                                                console.log('Updating out animation start frame to:', newValue);
                                                const updatedStyle = {
                                                    ...style,
                                                    animation: {
                                                        ...style.animation,
                                                        out: {
                                                            ...style.animation?.out,
                                                            startFrame: newValue,
                                                        },
                                                    },
                                                };
                                                console.log('Updated style:', updatedStyle);
                                                onChange({
                                                    ...component,
                                                    style: updatedStyle,
                                                });
                                            }
                                        }}
                                        style={styles.animationInput}
                                        min={style.animation?.out?.endFrame ?? 0}
                                    />
                                </div>
                                <div>
                                    <label style={styles.animationLabel}>End Frame (from end)</label>
                                    <input
                                        type="number"
                                        value={style.animation?.out?.endFrame ?? 0}
                                        onChange={(e) => {
                                            const newValue = parseInt(e.target.value);
                                            if (!isNaN(newValue)) {
                                                console.log('Updating out animation end frame to:', newValue);
                                                const updatedStyle = {
                                                    ...style,
                                                    animation: {
                                                        ...style.animation,
                                                        out: {
                                                            ...style.animation?.out,
                                                            endFrame: newValue,
                                                        },
                                                    },
                                                };
                                                console.log('Updated style:', updatedStyle);
                                                onChange({
                                                    ...component,
                                                    style: updatedStyle,
                                                });
                                            }
                                        }}
                                        style={styles.animationInput}
                                        min="0"
                                    />
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            </div>

            {/* Position */}
            <div style={{ marginTop: theme.spacing.lg }}>
                <div style={{
                    display: 'flex',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    marginBottom: theme.spacing.sm,
                }}>
                    <h3 style={styles.sectionTitle}>Position</h3>
                    <button
                        onClick={() => setIsPositioningPopupOpen(true)}
                        style={{
                            backgroundColor: theme.colors.primary,
                            color: theme.colors.text.primary,
                            border: 'none',
                            borderRadius: '4px',
                            padding: '4px 8px',
                            cursor: 'pointer',
                            fontSize: '13px',
                        }}
                    >
                        Open Large Preview
                    </button>
                </div>
                <div style={{
                    width: '200px',
                    height: '356px',
                    backgroundColor: '#1a1a1a',
                    position: 'relative',
                    borderRadius: theme.borderRadius.sm,
                    overflow: 'hidden',
                    cursor: 'pointer',
                }}
                onClick={(e) => {
                    const rect = e.currentTarget.getBoundingClientRect();
                    const x = (e.clientX - rect.left) * 5.4;
                    const y = (e.clientY - rect.top) * 5.4;
                    handlePositionChange({ x, y });
                }}>
                    {/* Grid lines */}
                    <div style={{
                        position: 'absolute',
                        inset: 0,
                        backgroundImage: `
                            linear-gradient(to right, #333 1px, transparent 1px),
                            linear-gradient(to bottom, #333 1px, transparent 1px)
                        `,
                        backgroundSize: '20px 20px',
                        opacity: 0.5,
                        pointerEvents: 'none',
                    }} />

                    {/* Center dot */}
                    <div style={{
                        position: 'absolute',
                        left: (style.position?.x || 0) / 5.4,
                        top: (style.position?.y || 0) / 5.4,
                        width: 6,
                        height: 6,
                        backgroundColor: theme.colors.primary,
                        borderRadius: '50%',
                        transform: 'translate(-50%, -50%)',
                        pointerEvents: 'none',
                        boxShadow: '0 0 0 2px rgba(255, 255, 255, 0.3)',
                    }} />
                </div>
            </div>

            {/* Positioning Popup */}
            {isPositioningPopupOpen && (
                <PositioningScreen
                    component={component}
                    onPositionChange={handlePositionChange}
                    onClose={() => setIsPositioningPopupOpen(false)}
                />
            )}
        </>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\Timeline.tsx ---

import React, { useState, useRef, useEffect } from 'react';
import { Script, BaseScriptComponent, ComponentType } from '../../types/script';
import { theme } from '../../styles/theme';
import { createComponent } from '../../utils/componentFactory';

interface TimelineProps {
    script: Script;
    onReorder: (components: BaseScriptComponent[]) => void;
    onSelect: (id: string) => void;
    selectedId?: string;
    onDelete: (id: string) => void;
    zoom?: number;
}

const TRACK_HEIGHT = 40;
const PIXELS_PER_SECOND = 100;
const FRAMES_PER_SECOND = 30;
const NUM_TRACKS = 5;

export const Timeline: React.FC<TimelineProps> = ({
    script,
    onReorder,
    onSelect,
    selectedId,
    onDelete,
    zoom = 1,
}) => {
    const [draggingId, setDraggingId] = useState<string | null>(null);
    const [dragOffset, setDragOffset] = useState(0);
    const containerRef = useRef<HTMLDivElement>(null);

    // Calculate timeline width based on the maximum end time of all components
    const timelineWidth = Math.max(
        ...script.components.map(comp => {
            const start = comp.startFrame || 0;
            const duration = comp.durationInFrames || 150;
            return (start + duration) / FRAMES_PER_SECOND * PIXELS_PER_SECOND * zoom;
        }),
        PIXELS_PER_SECOND * 10 * zoom // Minimum width of 10 seconds
    );

    useEffect(() => {
        // Scroll to show the rightmost component if it's out of view
        if (containerRef.current) {
            const maxEndTime = Math.max(...script.components.map(comp => {
                const start = comp.startFrame || 0;
                const duration = comp.durationInFrames || 150;
                return start + duration;
            }));
            const scrollPosition = (maxEndTime / FRAMES_PER_SECOND) * PIXELS_PER_SECOND * zoom;
            const clientWidth = containerRef.current.clientWidth;

            if (scrollPosition > clientWidth) {
                containerRef.current.scrollLeft = scrollPosition - clientWidth + 100;
            }
        }
    }, [script.components, zoom]);

    const handleDragStart = (e: React.DragEvent, component: BaseScriptComponent) => {
        e.stopPropagation();
        const rect = e.currentTarget.getBoundingClientRect();
        const offsetX = e.clientX - rect.left;
        setDragOffset(Math.round((offsetX / (PIXELS_PER_SECOND * zoom)) * FRAMES_PER_SECOND));
        setDraggingId(component.id);
        e.dataTransfer.effectAllowed = 'move';
    };

    const handleDrop = (e: React.DragEvent, trackIndex: number) => {
        e.preventDefault();
        e.stopPropagation();
        
        const rect = containerRef.current?.getBoundingClientRect();
        if (!rect) return;

        const scrollLeft = containerRef.current?.scrollLeft || 0;
        const x = e.clientX - rect.left + scrollLeft;
        const startFrame = Math.round((x / (PIXELS_PER_SECOND * zoom)) * FRAMES_PER_SECOND);

        if (draggingId) {
            // Update existing component position
            const updatedComponents = script.components.map(comp => {
                if (comp.id === draggingId) {
                    const newStartFrame = Math.max(0, startFrame - dragOffset);
                    const newComp = {
                        ...comp,
                        startFrame: newStartFrame,
                        track: trackIndex,
                    };
                    
                    // Only handle style for text components
                    if (comp.type === 'text' && 'style' in comp) {
                        return {
                            ...newComp,
                            style: {
                                ...comp.style,
                                position: comp.style.position
                            }
                        };
                    }
                    
                    return newComp;
                }
                return comp;
            });
            onReorder(updatedComponents);
        } else {
            // Handle new component from palette
            const componentType = e.dataTransfer.getData('componentType') as ComponentType;
            if (componentType) {
                const newComponent = createComponent(
                    componentType,
                    script.settings.defaultTextStyle,
                    script.settings.defaultCaptionStyle
                );
                newComponent.startFrame = Math.max(0, startFrame);
                newComponent.track = trackIndex;
                onReorder([...script.components, newComponent]);
            }
        }
        setDraggingId(null);
        setDragOffset(0);
    };

    const handleDrag = (e: React.DragEvent, trackIndex: number) => {
        e.preventDefault();
        e.stopPropagation();
        
        if (!draggingId || !containerRef.current || !e.clientX) return;

        const rect = containerRef.current.getBoundingClientRect();
        const scrollLeft = containerRef.current.scrollLeft;
        const x = e.clientX - rect.left + scrollLeft;
        const newStartFrame = Math.max(0, Math.round((x / (PIXELS_PER_SECOND * zoom)) * FRAMES_PER_SECOND) - dragOffset);

        // Auto-scroll when dragging near the right edge
        const SCROLL_THRESHOLD = 100; // pixels from the right edge
        const SCROLL_SPEED = 10;
        
        if (e.clientX > rect.right - SCROLL_THRESHOLD) {
            containerRef.current.scrollLeft += SCROLL_SPEED;
        }

        const updatedComponents = script.components.map(comp => {
            if (comp.id === draggingId) {
                return {
                    ...comp,
                    startFrame: newStartFrame,
                    track: trackIndex
                };
            }
            return comp;
        });

        onReorder(updatedComponents);
    };

    // Calculate timeline width including extra space for dragging
    const timelineWidthIncludingExtraSpace = Math.max(
        containerRef.current?.clientWidth || 0,
        script.components.reduce((max, comp) => {
            const endFrame = comp.startFrame + comp.durationInFrames;
            return Math.max(max, endFrame);
        }, 0) * (PIXELS_PER_SECOND * zoom) / FRAMES_PER_SECOND + 500 // Add extra space
    );

    return (
        <div 
            ref={containerRef}
            style={{
                overflow: 'auto',
                backgroundColor: theme.colors.background.tertiary,
                borderRadius: theme.borderRadius.sm,
            }}
        >
            <div style={{
                width: `${timelineWidthIncludingExtraSpace}px`,
                minHeight: TRACK_HEIGHT * NUM_TRACKS,
                position: 'relative',
            }}>
                {/* Time markers */}
                <div style={{
                    height: '20px',
                    borderBottom: `1px solid ${theme.colors.border}`,
                    position: 'relative',
                }}>
                    {Array.from({ length: Math.ceil(timelineWidthIncludingExtraSpace / PIXELS_PER_SECOND) }).map((_, i) => (
                        <div
                            key={i}
                            style={{
                                position: 'absolute',
                                left: `${i * PIXELS_PER_SECOND}px`,
                                height: '100%',
                                borderLeft: `1px solid ${theme.colors.border}`,
                            }}
                        >
                            <span style={{
                                position: 'absolute',
                                top: '2px',
                                left: '4px',
                                fontSize: '10px',
                                color: theme.colors.text.secondary,
                            }}>
                                {i}s
                            </span>
                        </div>
                    ))}
                </div>

                {/* Tracks */}
                {Array.from({ length: NUM_TRACKS }).map((_, trackIndex) => (
                    <div
                        key={trackIndex}
                        style={{
                            height: TRACK_HEIGHT,
                            borderBottom: `1px solid ${theme.colors.border}`,
                            position: 'relative',
                            backgroundColor: theme.colors.background.secondary,
                        }}
                        onDragOver={(e) => {
                            e.preventDefault();
                            handleDrag(e, trackIndex);
                        }}
                        onDrop={(e) => handleDrop(e, trackIndex)}
                    >
                        {script.components
                            .filter(comp => (comp.track || 0) === trackIndex)
                            .map(component => (
                                <div
                                    key={component.id}
                                    draggable
                                    onClick={() => onSelect(component.id)}
                                    onDragStart={(e) => handleDragStart(e, component as BaseScriptComponent)}
                                    onDragEnd={() => setDraggingId(null)}
                                    style={{
                                        position: 'absolute',
                                        left: `${((component.startFrame || 0) / FRAMES_PER_SECOND) * PIXELS_PER_SECOND * zoom}px`,
                                        width: `${((component.durationInFrames || 150) / FRAMES_PER_SECOND) * PIXELS_PER_SECOND * zoom}px`,
                                        height: TRACK_HEIGHT - 2,
                                        backgroundColor: selectedId === component.id ? theme.colors.primary : theme.colors.secondary,
                                        borderRadius: theme.borderRadius.sm,
                                        cursor: 'grab',
                                        display: 'flex',
                                        alignItems: 'center',
                                        padding: '0 8px',
                                        fontSize: '12px',
                                        color: 'white',
                                        whiteSpace: 'nowrap',
                                        overflow: 'hidden',
                                        textOverflow: 'ellipsis',
                                        transition: theme.transitions.fast,
                                    }}
                                >
                                    {component.type}
                                </div>
                        ))}
                    </div>
                ))}
            </div>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\TitleComponentEditor.tsx ---

import React from 'react';
import { TitleComponent } from '../../types/script';
import { TextField, Grid } from '@mui/material';

interface TitleComponentEditorProps {
    component: TitleComponent;
    onChange: (component: TitleComponent) => void;
}

export const TitleComponentEditor: React.FC<TitleComponentEditorProps> = ({ component, onChange }) => {
    return (
        <Grid container spacing={2}>
            <Grid item xs={12}>
                <TextField
                    fullWidth
                    label="Title Text"
                    value={component.text}
                    onChange={(e) => onChange({
                        ...component,
                        text: e.target.value
                    })}
                />
            </Grid>
            <Grid item xs={12}>
                <TextField
                    fullWidth
                    label="Subtitle"
                    value={component.subtitle || ''}
                    onChange={(e) => onChange({
                        ...component,
                        subtitle: e.target.value
                    })}
                />
            </Grid>
        </Grid>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\VideoComponentEditor.tsx ---

import React from 'react';
import { VideoComponent, AnimationOptions } from '../../types/script';
import { theme } from '../../styles/theme';

interface VideoComponentEditorProps {
    component: VideoComponent;
    onChange: (updated: VideoComponent) => void;
}

export const VideoComponentEditor: React.FC<VideoComponentEditorProps> = ({
    component,
    onChange,
}) => {
    const handleStyleChange = (updated: Partial<VideoComponent['style']>) => {
        onChange({
            ...component,
            style: {
                ...component.style,
                ...updated
            }
        });
    };

    const handleAnimationChange = (updates: Partial<AnimationOptions>) => {
        const currentAnimation = component.style?.animation || {
            type: 'none',
            direction: 'in',
            easing: 'easeInOut',
            duration: 30,
            delay: 0,
            stagger: 0
        };
        handleStyleChange({
            animation: {
                ...currentAnimation,
                ...updates,
            }
        });
    };

    const handleChromakeyChange = (updates: Partial<NonNullable<VideoComponent['style']>['chromakey']>) => {
        const currentChromakey = component.style?.chromakey || {
            enabled: false,
            color: '#00ff00',
            similarity: 0.4,
            smoothness: 0.1
        };
        handleStyleChange({
            chromakey: {
                ...currentChromakey,
                ...updates,
            }
        });
    };

    return (
        <div style={styles.container}>
            {/* Video URL */}
            <div style={styles.section}>
                <label style={styles.label}>Video URL:</label>
                <input
                    type="text"
                    value={component.videoUrl}
                    onChange={(e) => {
                        onChange({
                            ...component,
                            videoUrl: e.target.value
                        });
                    }}
                    style={styles.input}
                    placeholder="Enter video URL (supports video files and GIFs)..."
                />
            </div>

            {/* Size and Position */}
            <div style={styles.section}>
                <h4 style={styles.sectionTitle}>Size & Position</h4>
                <div style={styles.settingsGrid}>
                    <div>
                        <label style={styles.label}>Width (%):</label>
                        <input
                            type="number"
                            min="1"
                            max="100"
                            value={component.style?.width || 100}
                            onChange={(e) => handleStyleChange({ width: Number(e.target.value) })}
                            style={styles.input}
                        />
                    </div>
                    <div>
                        <label style={styles.label}>Height (%):</label>
                        <input
                            type="number"
                            min="1"
                            max="100"
                            value={component.style?.height || 100}
                            onChange={(e) => handleStyleChange({ height: Number(e.target.value) })}
                            style={styles.input}
                        />
                    </div>
                </div>

                <div style={styles.settingsGrid}>
                    <div>
                        <label style={styles.label}>X Position (%):</label>
                        <input
                            type="range"
                            min="-100"
                            max="100"
                            value={component.style?.position?.x || 0}
                            onChange={(e) => handleStyleChange({
                                position: {
                                    x: Number(e.target.value),
                                    y: component.style?.position?.y || 0
                                }
                            })}
                            style={styles.input}
                        />
                    </div>
                    <div>
                        <label style={styles.label}>Y Position (%):</label>
                        <input
                            type="range"
                            min="-100"
                            max="100"
                            value={component.style?.position?.y || 0}
                            onChange={(e) => handleStyleChange({
                                position: {
                                    x: component.style?.position?.x || 0,
                                    y: Number(e.target.value)
                                }
                            })}
                            style={styles.input}
                        />
                    </div>
                </div>
            </div>

            {/* Transform */}
            <div style={styles.section}>
                <h4 style={styles.sectionTitle}>Transform</h4>
                <div style={styles.settingsGrid}>
                    <div>
                        <label style={styles.label}>Scale:</label>
                        <input
                            type="number"
                            min="0.1"
                            max="5"
                            step="0.1"
                            value={component.style?.scale || 1}
                            onChange={(e) => handleStyleChange({ scale: Number(e.target.value) })}
                            style={styles.input}
                        />
                    </div>
                    <div>
                        <label style={styles.label}>Rotation (deg):</label>
                        <input
                            type="number"
                            min="-360"
                            max="360"
                            value={component.style?.rotation || 0}
                            onChange={(e) => handleStyleChange({ rotation: Number(e.target.value) })}
                            style={styles.input}
                        />
                    </div>
                    <div>
                        <label style={styles.label}>Opacity:</label>
                        <input
                            type="range"
                            min="0"
                            max="1"
                            step="0.1"
                            value={component.style?.opacity || 1}
                            onChange={(e) => handleStyleChange({ opacity: Number(e.target.value) })}
                            style={styles.input}
                        />
                    </div>
                </div>
            </div>

            {/* Playback Settings */}
            <div style={styles.section}>
                <h4 style={styles.sectionTitle}>Playback Settings</h4>
                <div style={styles.settingsGrid}>
                    <div>
                        <label style={styles.label}>Volume:</label>
                        <input
                            type="range"
                            min="0"
                            max="1"
                            step="0.1"
                            value={component.style?.volume || 1}
                            onChange={(e) => handleStyleChange({ volume: Number(e.target.value) })}
                            style={styles.input}
                        />
                    </div>
                    <div>
                        <label style={styles.label}>Playback Rate:</label>
                        <input
                            type="number"
                            min="0.5"
                            max="2"
                            step="0.1"
                            value={component.style?.playbackRate || 1}
                            onChange={(e) => handleStyleChange({ playbackRate: Number(e.target.value) })}
                            style={styles.input}
                        />
                    </div>
                </div>
                <div style={styles.row}>
                    <label style={styles.checkboxLabel}>
                        <input
                            type="checkbox"
                            checked={component.style?.loop || false}
                            onChange={(e) => handleStyleChange({ loop: e.target.checked })}
                        />
                        Loop Video
                    </label>
                    <label style={styles.checkboxLabel}>
                        <input
                            type="checkbox"
                            checked={component.style?.muted || false}
                            onChange={(e) => handleStyleChange({ muted: e.target.checked })}
                        />
                        Mute Audio
                    </label>
                </div>
            </div>

            {/* Animation Controls */}
            <div style={styles.section}>
                <h4 style={styles.sectionTitle}>Animation</h4>
                <div style={styles.row}>
                    <select
                        value={component.style?.animation?.type ?? 'none'}
                        onChange={(e) => handleAnimationChange({ type: e.target.value as AnimationOptions['type'] })}
                        style={styles.input}
                    >
                        <option value="none">None</option>
                        <option value="fade">Fade</option>
                        <option value="scale">Scale</option>
                        <option value="rotate">Rotate</option>
                        <option value="slide">Slide</option>
                    </select>
                </div>
                {component.style?.animation?.type !== 'none' && (
                    <>
                        <div style={styles.row}>
                            <select
                                value={component.style?.animation?.direction ?? 'in'}
                                onChange={(e) => handleAnimationChange({ direction: e.target.value as AnimationOptions['direction'] })}
                                style={styles.input}
                            >
                                <option value="in">In</option>
                                <option value="out">Out</option>
                            </select>
                            <select
                                value={component.style?.animation?.easing ?? 'easeInOut'}
                                onChange={(e) => handleAnimationChange({ easing: e.target.value as AnimationOptions['easing'] })}
                                style={styles.input}
                            >
                                <option value="linear">Linear</option>
                                <option value="easeIn">Ease In</option>
                                <option value="easeOut">Ease Out</option>
                                <option value="easeInOut">Ease In Out</option>
                            </select>
                        </div>
                        <div style={styles.row}>
                            <input
                                type="number"
                                value={component.style?.animation?.duration ?? 30}
                                onChange={(e) => handleAnimationChange({ duration: Number(e.target.value) })}
                                placeholder="Duration (frames)"
                                min="1"
                                style={styles.input}
                            />
                            <input
                                type="number"
                                value={component.style?.animation?.delay ?? 0}
                                onChange={(e) => handleAnimationChange({ delay: Number(e.target.value) })}
                                placeholder="Delay (frames)"
                                min="0"
                                style={styles.input}
                            />
                            <input
                                type="number"
                                value={component.style?.animation?.stagger ?? 0}
                                onChange={(e) => handleAnimationChange({ stagger: Number(e.target.value) })}
                                placeholder="Stagger (frames)"
                                min="0"
                                style={styles.input}
                            />
                        </div>
                    </>
                )}
            </div>

            {/* Chromakey Settings */}
            <div style={styles.section}>
                <h4 style={styles.sectionTitle}>Chromakey</h4>
                <div style={styles.row}>
                    <label style={styles.checkboxLabel}>
                        <input
                            type="checkbox"
                            checked={component.style?.chromakey?.enabled || false}
                            onChange={(e) => handleChromakeyChange({ enabled: e.target.checked })}
                        />
                        Enable Chromakey
                    </label>
                </div>
                {component.style?.chromakey?.enabled && (
                    <>
                        <div style={styles.row}>
                            <div style={{ flex: 1 }}>
                                <label style={styles.label}>Color to Remove:</label>
                                <input
                                    type="color"
                                    value={component.style.chromakey.color || '#00ff00'}
                                    onChange={(e) => handleChromakeyChange({ color: e.target.value })}
                                    style={styles.input}
                                />
                            </div>
                        </div>
                        <div style={styles.settingsGrid}>
                            <div>
                                <label style={styles.label}>Color Similarity:</label>
                                <input
                                    type="range"
                                    min="0"
                                    max="1"
                                    step="0.01"
                                    value={component.style.chromakey.similarity || 0.4}
                                    onChange={(e) => handleChromakeyChange({ similarity: Number(e.target.value) })}
                                    style={styles.input}
                                />
                            </div>
                            <div>
                                <label style={styles.label}>Edge Smoothness:</label>
                                <input
                                    type="range"
                                    min="0"
                                    max="1"
                                    step="0.01"
                                    value={component.style.chromakey.smoothness || 0.1}
                                    onChange={(e) => handleChromakeyChange({ smoothness: Number(e.target.value) })}
                                    style={styles.input}
                                />
                            </div>
                        </div>
                    </>
                )}
            </div>
        </div>
    );
};

const styles = {
    container: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.md,
        height: '100%',
        backgroundColor: 'transparent',
    },
    section: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: theme.spacing.sm,
        padding: theme.spacing.md,
        backgroundColor: theme.colors.background.secondary,
        borderRadius: theme.borderRadius.md,
        border: `1px solid ${theme.colors.border}`,
    },
    sectionTitle: {
        margin: '0 0 8px 0',
        color: theme.colors.text.primary,
        fontSize: '1rem',
        fontWeight: 600,
    },
    label: {
        fontSize: '0.9rem',
        fontWeight: 500,
        color: theme.colors.text.primary,
    },
    input: {
        padding: '0.5rem',
        borderRadius: theme.borderRadius.sm,
        border: `1px solid ${theme.colors.border}`,
        backgroundColor: theme.colors.background.tertiary,
        color: theme.colors.text.primary,
        width: '100%',
        minWidth: 0,
    },
    settingsGrid: {
        display: 'grid',
        gridTemplateColumns: '1fr 1fr',
        gap: theme.spacing.sm,
    },
    row: {
        display: 'flex',
        gap: theme.spacing.sm,
        alignItems: 'center',
        flexWrap: 'wrap' as const,
    },
    checkboxLabel: {
        display: 'flex',
        alignItems: 'center',
        gap: theme.spacing.sm,
        fontSize: '0.9rem',
        fontWeight: 500,
        color: theme.colors.text.primary,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\VoiceComponent.tsx ---

import React, { useState } from 'react';
import { VoiceComponent } from '../../types/script';
import { generateSpeech } from '../../services/elevenLabs';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';
import { DraggablePreview } from './DraggablePreview';

interface VoiceComponentEditorProps {
    component: VoiceComponent;
    onChange: (updated: VoiceComponent) => void;
}

type VoiceStatus = 'none' | 'generating' | 'success' | 'error';

const styles = {
    container: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: '20px',
    },
    section: {
        backgroundColor: theme.colors.background.secondary,
        padding: theme.spacing.lg,
        borderRadius: theme.borderRadius.md,
        border: `1px solid ${theme.colors.border}`,
    },
    label: {
        ...commonStyles.label,
        color: theme.colors.text.primary,
        display: 'block',
        marginBottom: theme.spacing.xs,
    },
    input: {
        ...commonStyles.input,
        backgroundColor: theme.colors.background.tertiary,
        border: `1px solid ${theme.colors.border}`,
        color: theme.colors.text.primary,
        padding: theme.spacing.sm,
        borderRadius: theme.borderRadius.sm,
        width: '100%',
    },
    button: {
        ...commonStyles.button.primary,
        display: 'flex',
        alignItems: 'center',
        gap: theme.spacing.sm,
        padding: `${theme.spacing.sm} ${theme.spacing.md}`,
    },
    grid: {
        display: 'grid',
        gridTemplateColumns: '1fr 1fr',
        gap: '20px',
    },
};

export const VoiceComponentEditor: React.FC<VoiceComponentEditorProps> = ({
    component,
    onChange,
}) => {
    const [voiceStatus, setVoiceStatus] = useState<VoiceStatus>(
        component.audioUrl ? 'success' : 'none'
    );
    const [errorMessage, setErrorMessage] = useState<string>('');
    const style = component.style || {};

    const handleVoiceGeneration = async () => {
        try {
            if (!component.text) {
                setErrorMessage('Please enter text for voice generation');
                return;
            }

            setVoiceStatus('generating');
            setErrorMessage('');
            
            const { audioUrl, wordTimings } = await generateSpeech({
                text: component.text,
                voiceId: component.voiceSettings?.voiceId || 'GhJYgP4Lrji0pwS3kQwv',
                settings: {
                    stability: component.voiceSettings?.stability || 0.75,
                    similarity_boost: component.voiceSettings?.similarity_boost || 0.75,
                },
            });

            onChange({
                ...component,
                audioUrl,
                wordTimings,
            });
            setVoiceStatus('success');
        } catch (error) {
            console.error('Voice generation failed:', error);
            setVoiceStatus('error');
            setErrorMessage(error instanceof Error ? error.message : 'Voice generation failed');
        }
    };

    const getStatusColor = () => {
        switch (voiceStatus) {
            case 'generating': return '#ffd700';
            case 'success': return '#4caf50';
            case 'error': return '#f44336';
            default: return '#007bff';
        }
    };

    return (
        <div style={styles.container}>
            {/* Voice Generation Section */}
            <div style={styles.section}>
                <h4 style={{ marginTop: 0 }}>Voice Generation</h4>
                <div style={{ marginBottom: theme.spacing.md }}>
                    <label style={styles.label}>Voice Text:</label>
                    <textarea
                        value={component.text}
                        onChange={(e) => onChange({
                            ...component,
                            text: e.target.value,
                        })}
                        style={{
                            ...styles.input,
                            minHeight: '100px',
                        }}
                        placeholder="Enter text for voice generation..."
                    />
                </div>

                <div style={styles.grid}>
                    <div>
                        <label style={styles.label}>Voice:</label>
                        <select
                            value={component.voiceSettings?.voiceId}
                            onChange={(e) => onChange({
                                ...component,
                                voiceSettings: {
                                    ...component.voiceSettings,
                                    voiceId: e.target.value,
                                },
                            })}
                            style={styles.input}
                        >
                            <option value="GhJYgP4Lrji0pwS3kQwv">Josh (Default)</option>
                            <option value="21m00Tcm4TlvDq8ikWAM">Rachel</option>
                            <option value="AZnzlk1XvdvUeBnXmlld">Domi</option>
                            <option value="EXAVITQu4vr4xnSDxMaL">Bella</option>
                            <option value="MF3mGyEYCl7XYWbV9V6O">Elli</option>
                        </select>
                    </div>

                    <div>
                        <label style={styles.label}>Stability:</label>
                        <input
                            type="range"
                            min="0"
                            max="100"
                            value={((component.voiceSettings?.stability || 0.75) * 100)}
                            onChange={(e) => onChange({
                                ...component,
                                voiceSettings: {
                                    ...component.voiceSettings,
                                    stability: parseInt(e.target.value) / 100,
                                },
                            })}
                            style={styles.input}
                        />
                    </div>

                    <div>
                        <label style={styles.label}>Similarity Boost:</label>
                        <input
                            type="range"
                            min="0"
                            max="100"
                            value={((component.voiceSettings?.similarity_boost || 0.75) * 100)}
                            onChange={(e) => onChange({
                                ...component,
                                voiceSettings: {
                                    ...component.voiceSettings,
                                    similarity_boost: parseInt(e.target.value) / 100,
                                },
                            })}
                            style={styles.input}
                        />
                    </div>
                </div>

                <div style={{ marginTop: theme.spacing.md }}>
                    <button
                        onClick={handleVoiceGeneration}
                        disabled={voiceStatus === 'generating'}
                        style={{
                            ...styles.button,
                            backgroundColor: getStatusColor(),
                        }}
                    >
                        {voiceStatus === 'generating' && (
                            <div style={{
                                width: '16px',
                                height: '16px',
                                border: '2px solid white',
                                borderTop: '2px solid transparent',
                                borderRadius: '50%',
                                animation: 'spin 1s linear infinite',
                            }}>
                                <style>
                                    {`
                                        @keyframes spin {
                                            0% { transform: rotate(0deg); }
                                            100% { transform: rotate(360deg); }
                                        }
                                    `}
                                </style>
                            </div>
                        )}
                        {voiceStatus === 'generating' ? 'Generating...' : 
                         voiceStatus === 'success' ? 'Regenerate Voice' : 
                         voiceStatus === 'error' ? 'Try Again' : 
                         'Generate Voice'}
                    </button>
                    {voiceStatus === 'success' && (
                        <span style={{ color: '#4caf50', marginLeft: '10px' }}>‚úì Voice generated successfully</span>
                    )}
                    {voiceStatus === 'error' && (
                        <span style={{ color: '#f44336', marginLeft: '10px' }}>‚ö†Ô∏è {errorMessage}</span>
                    )}
                </div>

                {/* Audio Preview */}
                {component.audioUrl && (
                    <div style={{ marginTop: theme.spacing.md }}>
                        <label style={styles.label}>Preview Audio:</label>
                        <audio
                            controls
                            src={component.audioUrl}
                            style={{ width: '100%' }}
                        />
                    </div>
                )}
            </div>

            {/* Caption Settings */}
            <div style={styles.section}>
                <div style={{ 
                    display: 'flex', 
                    alignItems: 'center', 
                    gap: theme.spacing.md,
                    marginBottom: theme.spacing.md 
                }}>
                    <h4 style={{ margin: 0 }}>Caption Settings</h4>
                    <label style={{
                        display: 'flex',
                        alignItems: 'center',
                        gap: theme.spacing.sm,
                    }}>
                        <input
                            type="checkbox"
                            checked={component.showCaptions}
                            onChange={(e) => onChange({
                                ...component,
                                showCaptions: e.target.checked,
                            })}
                        />
                        Show Captions
                    </label>
                </div>

                {component.showCaptions && (
                    <>
                        {/* Text Styling */}
                        <div style={styles.grid}>
                            <div>
                                <label style={styles.label}>Font Size:</label>
                                <input
                                    type="number"
                                    value={style.fontSize || 24}
                                    onChange={(e) => onChange({
                                        ...component,
                                        style: {
                                            ...style,
                                            fontSize: parseInt(e.target.value),
                                        },
                                    })}
                                    style={styles.input}
                                    min="12"
                                    max="72"
                                />
                            </div>

                            <div>
                                <label style={styles.label}>Font Family:</label>
                                <select
                                    value={style.fontFamily || 'Arial'}
                                    onChange={(e) => onChange({
                                        ...component,
                                        style: {
                                            ...style,
                                            fontFamily: e.target.value,
                                        },
                                    })}
                                    style={styles.input}
                                >
                                    <option value="Arial">Arial</option>
                                    <option value="Times New Roman">Times New Roman</option>
                                    <option value="Helvetica">Helvetica</option>
                                    <option value="Georgia">Georgia</option>
                                    <option value="Verdana">Verdana</option>
                                </select>
                            </div>

                            <div>
                                <label style={styles.label}>Text Color:</label>
                                <input
                                    type="color"
                                    value={style.color || '#ffffff'}
                                    onChange={(e) => onChange({
                                        ...component,
                                        style: {
                                            ...style,
                                            color: e.target.value,
                                        },
                                    })}
                                    style={styles.input}
                                />
                            </div>

                            <div>
                                <label style={styles.label}>Background Color:</label>
                                <input
                                    type="color"
                                    value={component.captionStyle?.backgroundColor || '#000000'}
                                    onChange={(e) => onChange({
                                        ...component,
                                        captionStyle: {
                                            ...component.captionStyle,
                                            backgroundColor: e.target.value,
                                        },
                                    })}
                                    style={styles.input}
                                />
                            </div>

                            <div>
                                <label style={styles.label}>Font Weight:</label>
                                <select
                                    value={style.fontWeight || 'normal'}
                                    onChange={(e) => onChange({
                                        ...component,
                                        style: {
                                            ...style,
                                            fontWeight: e.target.value,
                                        },
                                    })}
                                    style={styles.input}
                                >
                                    <option value="normal">Normal</option>
                                    <option value="bold">Bold</option>
                                    <option value="lighter">Light</option>
                                </select>
                            </div>

                            <div>
                                <label style={styles.label}>Text Alignment:</label>
                                <select
                                    value={style.textAlign || 'center'}
                                    onChange={(e) => onChange({
                                        ...component,
                                        style: {
                                            ...style,
                                            textAlign: e.target.value as 'left' | 'center' | 'right',
                                        },
                                    })}
                                    style={styles.input}
                                >
                                    <option value="left">Left</option>
                                    <option value="center">Center</option>
                                    <option value="right">Right</option>
                                </select>
                            </div>
                        </div>

                        {/* Position Preview */}
                        <div style={{ marginTop: theme.spacing.lg }}>
                            <h4 style={{ marginBottom: '10px' }}>Position & Preview</h4>
                            <DraggablePreview
                                text={component.text}
                                style={style}
                                onChange={(updates) => onChange({
                                    ...component,
                                    style: {
                                        ...style,
                                        ...updates,
                                    },
                                })}
                            />
                        </div>
                    </>
                )}
            </div>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\VoiceComponentEditor.tsx ---

import React, { useState } from 'react';
import { VoiceComponent } from '../../types/script';
import { generateSpeech, generateCaptions } from '../../services/elevenLabs';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';
import { CaptionPositioningScreen } from './CaptionPositioningScreen';

interface VoiceComponentEditorProps {
    component: VoiceComponent;
    onChange: (updated: VoiceComponent) => void;
}

type VoiceStatus = 'none' | 'generating' | 'success' | 'error';

const styles = {
    container: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: '20px',
    },
    section: {
        backgroundColor: theme.colors.background.secondary,
        padding: theme.spacing.lg,
        borderRadius: theme.borderRadius.md,
        border: `1px solid ${theme.colors.border}`,
    },
    label: {
        ...commonStyles.label,
        color: theme.colors.text.primary,
        display: 'block',
        marginBottom: theme.spacing.xs,
    },
    input: {
        ...commonStyles.input,
        backgroundColor: theme.colors.background.tertiary,
        border: `1px solid ${theme.colors.border}`,
        color: theme.colors.text.primary,
        padding: theme.spacing.sm,
        borderRadius: theme.borderRadius.sm,
        width: '100%',
    },
    button: {
        ...commonStyles.button.primary,
        display: 'flex',
        alignItems: 'center',
        gap: theme.spacing.sm,
        padding: `${theme.spacing.sm} ${theme.spacing.md}`,
    },
    grid: {
        display: 'grid',
        gridTemplateColumns: '1fr 1fr',
        gap: '20px',
    },
    modal: {
        position: 'fixed' as const,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        zIndex: 1000,
    },
    modalContent: {
        backgroundColor: '#fff',
        padding: theme.spacing.lg,
        borderRadius: theme.borderRadius.md,
        maxWidth: '90%',
        maxHeight: '90%',
        overflow: 'auto',
        position: 'relative' as const,
    },
};

export const VoiceComponentEditor: React.FC<VoiceComponentEditorProps> = ({
    component,
    onChange,
}) => {
    const [voiceStatus, setVoiceStatus] = useState<VoiceStatus>(
        component.audioUrl ? 'success' : 'none'
    );
    const [errorMessage, setErrorMessage] = useState<string>('');
    const [showPositioningScreen, setShowPositioningScreen] = useState(false);
    const style = component.style || {};

    const handleVoiceGeneration = async () => {
        try {
            if (!component.text) {
                setErrorMessage('Please enter text for voice generation');
                return;
            }

            setVoiceStatus('generating');
            setErrorMessage('');
            
            // Generate speech with the new interface
            const { audioUrl } = await generateSpeech({
                text: component.text,
                voiceId: component.voiceSettings?.voiceId || 'GhJYgP4Lrji0pwS3kQwv',
                settings: {
                    stability: component.voiceSettings?.stability || 0.75,
                    similarity_boost: component.voiceSettings?.similarity_boost || 0.75
                }
            });

            onChange({
                ...component,
                audioUrl,
                // Note: wordTimings are now included in the generateSpeech response
            });
            setVoiceStatus('success');
        } catch (error) {
            console.error('Voice generation failed:', error);
            setVoiceStatus('error');
            setErrorMessage(error instanceof Error ? error.message : 'Voice generation failed');
        }
    };

    const getStatusColor = () => {
        switch (voiceStatus) {
            case 'generating': return '#ffd700';
            case 'success': return '#4caf50';
            case 'error': return '#f44336';
            default: return '#007bff';
        }
    };

    return (
        <div style={styles.container}>
            {/* Voice Generation Section */}
            <div style={styles.section}>
                <h4 style={{ marginTop: 0 }}>Voice Generation</h4>
                <div style={{ marginBottom: theme.spacing.md }}>
                    <label style={styles.label}>Voice Text:</label>
                    <textarea
                        value={component.text}
                        onChange={(e) => onChange({
                            ...component,
                            text: e.target.value,
                        })}
                        style={{
                            ...styles.input,
                            minHeight: '100px',
                        }}
                        placeholder="Enter text for voice generation..."
                    />
                </div>

                <div style={styles.grid}>
                    <div>
                        <label style={styles.label}>Voice:</label>
                        <select
                            value={component.voiceSettings?.voiceId}
                            onChange={(e) => onChange({
                                ...component,
                                voiceSettings: {
                                    ...component.voiceSettings,
                                    voiceId: e.target.value,
                                },
                            })}
                            style={styles.input}
                        >
                            <option value="GhJYgP4Lrji0pwS3kQwv">Josh (Default)</option>
                            <option value="21m00Tcm4TlvDq8ikWAM">Rachel</option>
                            <option value="AZnzlk1XvdvUeBnXmlld">Domi</option>
                            <option value="EXAVITQu4vr4xnSDxMaL">Bella</option>
                            <option value="MF3mGyEYCl7XYWbV9V6O">Elli</option>
                        </select>
                    </div>

                    <div>
                        <label style={styles.label}>Stability:</label>
                        <input
                            type="range"
                            min="0"
                            max="100"
                            value={((component.voiceSettings?.stability || 0.75) * 100)}
                            onChange={(e) => onChange({
                                ...component,
                                voiceSettings: {
                                    ...component.voiceSettings,
                                    stability: parseInt(e.target.value) / 100,
                                },
                            })}
                            style={styles.input}
                        />
                    </div>
                </div>

                <div style={{ marginTop: theme.spacing.md }}>
                    <button
                        onClick={handleVoiceGeneration}
                        style={{
                            ...styles.button,
                            backgroundColor: getStatusColor(),
                        }}
                        disabled={voiceStatus === 'generating'}
                    >
                        {voiceStatus === 'generating' ? 'Generating...' : 'Generate Voice'}
                    </button>
                    {errorMessage && (
                        <div style={{ color: theme.colors.error, marginTop: theme.spacing.sm }}>
                            {errorMessage}
                        </div>
                    )}
                </div>

                {component.audioUrl && (
                    <div style={{ marginTop: theme.spacing.md }}>
                        <label style={styles.label}>Preview Audio:</label>
                        <audio
                            controls
                            src={component.audioUrl}
                            style={{ width: '100%' }}
                        />
                        
                        <div style={{ marginTop: theme.spacing.md }}>
                            <button
                                onClick={async () => {
                                    try {
                                        if (!component.audioUrl) return;

                                        // Get the audio file as a blob
                                        const response = await fetch(component.audioUrl);
                                        const audioBlob = await response.blob();
                                        
                                        // Create form data for transcription
                                        const formData = new FormData();
                                        formData.append('audio', audioBlob, 'speech.mp3');
                                        
                                        // Send to Whisper service
                                        const transcriptionResponse = await fetch('http://localhost:5000/transcribe', {
                                            method: 'POST',
                                            body: formData
                                        });

                                        if (!transcriptionResponse.ok) {
                                            throw new Error('Failed to generate captions');
                                        }

                                        const transcriptionData = await transcriptionResponse.json();
                                        
                                        // Update the component with captions
                                        onChange({
                                            ...component,
                                            wordTimings: transcriptionData.wordTimings,
                                            showCaptions: true,
                                            captionStyle: {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            }
                                        });
                                    } catch (error) {
                                        console.error('Error generating captions:', error);
                                        setErrorMessage('Failed to generate captions');
                                    }
                                }}
                                style={styles.button}
                                disabled={!component.audioUrl}
                            >
                                Generate Captions
                            </button>
                        </div>
                    </div>
                )}

                {/* Caption Settings */}
                {component.wordTimings && (
                    <div style={styles.section}>
                        <div style={{ 
                            display: 'flex', 
                            alignItems: 'center', 
                            gap: theme.spacing.md,
                            marginBottom: theme.spacing.md 
                        }}>
                            <h4 style={{ margin: 0 }}>Caption Settings</h4>
                            <label style={{
                                display: 'flex',
                                alignItems: 'center',
                                gap: theme.spacing.sm,
                                color: theme.colors.text.primary,
                            }}>
                                <input
                                    type="checkbox"
                                    checked={component.showCaptions}
                                    onChange={(e) => onChange({
                                        ...component,
                                        showCaptions: e.target.checked
                                    })}
                                />
                                Show Captions
                            </label>
                        </div>

                        {component.showCaptions && (
                            <div style={{ display: 'flex', flexDirection: 'column', gap: theme.spacing.md }}>
                                <div>
                                    <label style={styles.label}>Font Family:</label>
                                    <select
                                        value={component.captionStyle?.fontFamily || 'Arial'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    fontFamily: e.target.value
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    >
                                        <option value="Arial">Arial</option>
                                        <option value="Times New Roman">Times New Roman</option>
                                        <option value="Courier New">Courier New</option>
                                        <option value="Georgia">Georgia</option>
                                        <option value="Verdana">Verdana</option>
                                    </select>
                                </div>

                                <div>
                                    <label style={styles.label}>Font Size:</label>
                                    <input
                                        type="number"
                                        value={component.captionStyle?.fontSize || 24}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    fontSize: parseInt(e.target.value)
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <div>
                                    <label style={styles.label}>Font Weight:</label>
                                    <select
                                        value={component.captionStyle?.fontWeight || 'normal'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    fontWeight: e.target.value
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    >
                                        <option value="normal">Normal</option>
                                        <option value="bold">Bold</option>
                                        <option value="100">100</option>
                                        <option value="200">200</option>
                                        <option value="300">300</option>
                                        <option value="400">400</option>
                                        <option value="500">500</option>
                                        <option value="600">600</option>
                                        <option value="700">700</option>
                                        <option value="800">800</option>
                                        <option value="900">900</option>
                                    </select>
                                </div>

                                <div>
                                    <label style={styles.label}>Font Style:</label>
                                    <select
                                        value={component.captionStyle?.fontStyle || 'normal'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    fontStyle: e.target.value as 'normal' | 'italic'
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    >
                                        <option value="normal">Normal</option>
                                        <option value="italic">Italic</option>
                                    </select>
                                </div>

                                <div>
                                    <label style={styles.label}>Text Color:</label>
                                    <input
                                        type="color"
                                        value={component.captionStyle?.color || '#ffffff'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    color: e.target.value
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <div>
                                    <label style={styles.label}>Background Color:</label>
                                    <input
                                        type="color"
                                        value={component.captionStyle?.backgroundColor || 'rgba(0, 0, 0, 0.7)'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    backgroundColor: e.target.value
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <div>
                                    <label style={styles.label}>Position:</label>
                                    <select
                                        value={component.captionStyle?.position || 'bottom'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    position: e.target.value as 'top' | 'bottom'
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    >
                                        <option value="top">Top</option>
                                        <option value="bottom">Bottom</option>
                                    </select>
                                </div>

                                <div>
                                    <label style={styles.label}>Word Window:</label>
                                    <input
                                        type="number"
                                        min="1"
                                        max="10"
                                        value={component.captionStyle?.wordWindow || 1}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    wordWindow: parseInt(e.target.value)
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <div>
                                    <label style={styles.label}>Border Radius:</label>
                                    <input
                                        type="text"
                                        value={component.captionStyle?.borderRadius || '5px'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    borderRadius: e.target.value
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <div>
                                    <label style={styles.label}>Padding:</label>
                                    <input
                                        type="text"
                                        value={component.captionStyle?.padding || '10px 20px'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    padding: e.target.value
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <div>
                                    <label style={styles.label}>Box Shadow:</label>
                                    <input
                                        type="text"
                                        value={component.captionStyle?.boxShadow || 'none'}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    boxShadow: e.target.value
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <div>
                                    <label style={styles.label}>Opacity:</label>
                                    <input
                                        type="range"
                                        min="0"
                                        max="1"
                                        step="0.1"
                                        value={component.captionStyle?.opacity || 1}
                                        onChange={(e) => {
                                            const currentStyle = component.captionStyle || {
                                                fontSize: 24,
                                                color: '#ffffff',
                                                backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                position: 'bottom',
                                                wordWindow: 1
                                            };
                                            onChange({
                                                ...component,
                                                captionStyle: {
                                                    ...currentStyle,
                                                    opacity: parseFloat(e.target.value)
                                                }
                                            });
                                        }}
                                        style={styles.input}
                                    />
                                </div>

                                <button
                                    onClick={() => setShowPositioningScreen(true)}
                                    style={styles.button}
                                >
                                    Open Positioning Screen
                                </button>

                                {showPositioningScreen && (
                                    <div style={styles.modal}>
                                        <div style={styles.modalContent}>
                                            <CaptionPositioningScreen
                                                style={component.captionStyle || {
                                                    fontSize: 24,
                                                    color: '#ffffff',
                                                    backgroundColor: 'rgba(0, 0, 0, 0.7)',
                                                    position: 'bottom',
                                                    wordWindow: 1
                                                }}
                                                onChange={(newStyle) => {
                                                    onChange({
                                                        ...component,
                                                        captionStyle: newStyle
                                                    });
                                                }}
                                            />
                                            <button
                                                onClick={() => setShowPositioningScreen(false)}
                                                style={styles.button}
                                            >
                                                Close
                                            </button>
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}
                    </div>
                )}
            </div>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\ScriptEditor\VoiceOverEditor.tsx ---

import React, { useState } from 'react';
import { ScriptComponent } from '../../types/script';
import { generateSpeech } from '../../services/elevenLabs';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';

interface VoiceOverEditorProps {
    component: ScriptComponent;
    onChange: (updated: ScriptComponent) => void;
}

type VoiceStatus = 'none' | 'generating' | 'success' | 'error';

const styles = {
    section: {
        backgroundColor: theme.colors.background.secondary,
        padding: theme.spacing.lg,
        borderRadius: theme.borderRadius.md,
        border: `1px solid ${theme.colors.border}`,
    },
    label: {
        ...commonStyles.label,
        color: theme.colors.text.primary,
        display: 'block',
        marginBottom: theme.spacing.xs,
    },
    input: {
        ...commonStyles.input,
        backgroundColor: theme.colors.background.tertiary,
        border: `1px solid ${theme.colors.border}`,
        color: theme.colors.text.primary,
        padding: theme.spacing.sm,
        borderRadius: theme.borderRadius.sm,
        width: '100%',
    },
    button: {
        ...commonStyles.button.primary,
        display: 'flex',
        alignItems: 'center',
        gap: theme.spacing.sm,
        padding: `${theme.spacing.sm} ${theme.spacing.md}`,
    },
};

export const VoiceOverEditor: React.FC<VoiceOverEditorProps> = ({
    component,
    onChange,
}) => {
    const [voiceStatus, setVoiceStatus] = useState<VoiceStatus>(
        component.voiceOver?.audioUrl ? 'success' : 'none'
    );
    const [errorMessage, setErrorMessage] = useState<string>('');

    const getComponentText = (comp: ScriptComponent): string => {
        switch (comp.type) {
            case 'comparison':
                return comp.question;
            case 'text':
            case 'title':
                return comp.text;
            default:
                return '';
        }
    };

    const handleVoiceGeneration = async () => {
        try {
            const text = getComponentText(component);
            if (!text) {
                setErrorMessage('No text available for voice generation');
                return;
            }

            setVoiceStatus('generating');
            setErrorMessage('');
            
            const { audioUrl, wordTimings } = await generateSpeech({
                text,
                voiceId: component.voiceOver?.voiceId || 'default',
                settings: {
                    stability: 0.75,
                    similarity_boost: 0.75,
                },
            });

            onChange({
                ...component,
                voiceOver: {
                    text,
                    audioUrl,
                    wordTimings,
                    voiceId: component.voiceOver?.voiceId || 'default',
                    settings: {
                        stability: 0.75,
                        similarity_boost: 0.75,
                    },
                },
            });
            setVoiceStatus('success');
        } catch (error) {
            console.error('Voice generation failed:', error);
            setVoiceStatus('error');
            setErrorMessage(error instanceof Error ? error.message : 'Voice generation failed');
        }
    };

    const getStatusColor = () => {
        switch (voiceStatus) {
            case 'generating': return '#ffd700';
            case 'success': return '#4caf50';
            case 'error': return '#f44336';
            default: return '#007bff';
        }
    };

    return (
        <div style={styles.section}>
            <div style={{
                display: 'flex',
                alignItems: 'center',
                gap: theme.spacing.md,
                marginBottom: theme.spacing.md,
            }}>
                <h3 style={{ margin: 0 }}>Voice Over</h3>
                <button
                    onClick={handleVoiceGeneration}
                    disabled={voiceStatus === 'generating'}
                    style={{
                        ...styles.button,
                        backgroundColor: getStatusColor(),
                    }}
                >
                    {voiceStatus === 'generating' && (
                        <div style={{
                            width: '16px',
                            height: '16px',
                            border: '2px solid white',
                            borderTop: '2px solid transparent',
                            borderRadius: '50%',
                            animation: 'spin 1s linear infinite',
                        }}>
                            <style>
                                {`
                                    @keyframes spin {
                                        0% { transform: rotate(0deg); }
                                        100% { transform: rotate(360deg); }
                                    }
                                `}
                            </style>
                        </div>
                    )}
                    {voiceStatus === 'generating' ? 'Generating...' : 
                     voiceStatus === 'success' ? 'Regenerate Voice' : 
                     voiceStatus === 'error' ? 'Try Again' : 
                     'Generate Voice'}
                </button>
                {voiceStatus === 'success' && (
                    <span style={{ color: '#4caf50' }}>‚úì Voice generated successfully</span>
                )}
                {voiceStatus === 'error' && (
                    <span style={{ color: '#f44336' }}>‚ö†Ô∏è {errorMessage}</span>
                )}
            </div>

            {/* Caption Settings */}
            <div style={{ marginBottom: theme.spacing.md }}>
                <label style={{
                    ...styles.label,
                    display: 'flex',
                    alignItems: 'center',
                    gap: theme.spacing.sm,
                }}>
                    <input
                        type="checkbox"
                        checked={component.captions?.enabled ?? false}
                        onChange={(e) => onChange({
                            ...component,
                            captions: e.target.checked ? {
                                enabled: true,
                                displayMode: 'sync',
                                style: {
                                    fontSize: 24,
                                    color: 'white',
                                    textAlign: 'center',
                                },
                            } : undefined,
                        })}
                    />
                    Enable Captions
                </label>
            </div>

            {/* Audio Preview */}
            {component.voiceOver?.audioUrl && (
                <div style={{
                    marginTop: theme.spacing.md,
                    padding: theme.spacing.md,
                    backgroundColor: theme.colors.background.tertiary,
                    borderRadius: theme.borderRadius.md,
                }}>
                    <label style={styles.label}>Preview Audio:</label>
                    <audio
                        controls
                        src={component.voiceOver.audioUrl}
                        style={{ width: '100%' }}
                    />
                </div>
            )}
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Settings\BackgroundManager.tsx ---

import React, { useState, useEffect } from 'react';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';

interface BackgroundHistory {
    name: string;
    url: string;
    addedAt: string;
    type: 'image' | 'video' | 'none';
}

interface BackgroundManagerProps {
    onSelectBackground: (background: { 
        type: 'image' | 'video' | 'none'; 
        url?: string; 
        filePath?: string;
        durationInFrames?: number;
    }) => void;
}

export const BackgroundManager: React.FC<BackgroundManagerProps> = ({ onSelectBackground }) => {
    const [backgrounds, setBackgrounds] = useState<BackgroundHistory[]>([]);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);

    const loadBackgrounds = async () => {
        try {
            setLoading(true);
            const response = await fetch('http://localhost:3002/backgrounds/history');
            if (!response.ok) throw new Error('Failed to load backgrounds');
            const data = await response.json();
            setBackgrounds(data);
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to load backgrounds');
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        loadBackgrounds();
    }, []);

    const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (!file) return;

        const formData = new FormData();
        formData.append('file', file);

        try {
            setLoading(true);
            const response = await fetch('http://localhost:3002/set_background', {
                method: 'POST',
                body: formData,
            });

            if (!response.ok) throw new Error('Failed to upload background');
            
            const data = await response.json();
            await loadBackgrounds(); // Refresh the list
            
            // Select the newly uploaded background
            onSelectBackground({
                type: 'image',
                url: data.url,
                filePath: data.filePath
            });
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to upload background');
        } finally {
            setLoading(false);
        }
    };

    const handleRemoveBackground = async (name: string) => {
        try {
            setLoading(true);
            const response = await fetch('http://localhost:3002/remove_background', {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ name }),
            });

            if (!response.ok) throw new Error('Failed to remove background');
            await loadBackgrounds(); // Refresh the list
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to remove background');
        } finally {
            setLoading(false);
        }
    };

    return (
        <div style={styles.container}>
            <div style={styles.header}>
                <h3 style={styles.title}>Background Manager</h3>
                <input
                    type="file"
                    accept="image/*"
                    onChange={handleFileUpload}
                    style={{ display: 'none' }}
                    id="background-upload"
                />
                <label htmlFor="background-upload" style={styles.uploadButton}>
                    Upload New Background
                </label>
            </div>

            {error && <div style={styles.error}>{error}</div>}

            <div style={styles.grid}>
                {/* No Background Option */}
                <div 
                    style={styles.backgroundItem}
                    onClick={() => onSelectBackground({ type: 'none', url: '', filePath: '' })}
                >
                    <div style={styles.noBackgroundPreview}>
                        No Background
                    </div>
                    <div style={styles.backgroundName}>None</div>
                </div>

                {backgrounds.map((bg) => (
                    <div key={bg.name} style={styles.backgroundItem}>
                        <div 
                            style={styles.imagePreview}
                            onClick={() => onSelectBackground({
                                type: 'image',
                                url: bg.url,
                                filePath: bg.name
                            })}
                        >
                            <img src={bg.url} alt={bg.name} style={styles.previewImage} />
                        </div>
                        <div style={styles.backgroundInfo}>
                            <div style={styles.backgroundName}>{bg.name}</div>
                            <button
                                onClick={(e) => {
                                    e.stopPropagation();
                                    handleRemoveBackground(bg.name);
                                }}
                                style={styles.removeButton}
                            >
                                Remove
                            </button>
                        </div>
                    </div>
                ))}
            </div>

            {loading && <div style={styles.loading}>Loading...</div>}
        </div>
    );
};

const styles = {
    container: {
        padding: theme.spacing.md,
    },
    header: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: theme.spacing.lg,
    },
    title: {
        margin: 0,
        color: theme.colors.text.primary,
    },
    uploadButton: {
        ...commonStyles.button.primary,
        cursor: 'pointer',
    },
    grid: {
        display: 'grid',
        gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))',
        gap: theme.spacing.md,
        marginTop: theme.spacing.md,
    },
    backgroundItem: {
        border: `1px solid ${theme.colors.border}`,
        borderRadius: theme.borderRadius.md,
        overflow: 'hidden',
        backgroundColor: theme.colors.background.secondary,
    },
    imagePreview: {
        width: '100%',
        height: '150px',
        backgroundColor: theme.colors.background.tertiary,
        cursor: 'pointer',
        position: 'relative' as const,
    },
    noBackgroundPreview: {
        width: '100%',
        height: '150px',
        backgroundColor: theme.colors.background.tertiary,
        cursor: 'pointer',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        color: theme.colors.text.secondary,
    },
    previewImage: {
        width: '100%',
        height: '100%',
        objectFit: 'cover' as const,
    },
    backgroundInfo: {
        padding: theme.spacing.sm,
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
    },
    backgroundName: {
        color: theme.colors.text.primary,
        fontSize: '0.9em',
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap' as const,
    },
    removeButton: {
        ...commonStyles.button.secondary,
        color: theme.colors.error,
        padding: '4px 8px',
        fontSize: '0.8em',
    },
    error: {
        color: theme.colors.error,
        marginBottom: theme.spacing.md,
        padding: theme.spacing.sm,
        backgroundColor: 'rgba(244, 67, 54, 0.1)',
        borderRadius: theme.borderRadius.sm,
    },
    loading: {
        textAlign: 'center' as const,
        color: theme.colors.text.secondary,
        marginTop: theme.spacing.md,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Settings\FontManager.tsx ---

import React, { useState, useEffect } from 'react';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';

interface FontManagerProps {
    onClose: () => void;
}

interface CustomFont {
    name: string;
    url: string;
    format: 'truetype' | 'opentype';
}

const styles = {
    modal: {
        position: 'fixed' as const,
        top: '50%',
        left: '50%',
        transform: 'translate(-50%, -50%)',
        backgroundColor: theme.colors.background.secondary,
        padding: theme.spacing.xl,
        borderRadius: theme.borderRadius.lg,
        boxShadow: theme.shadows.lg,
        width: '90%',
        maxWidth: '600px',
        maxHeight: '80vh',
        overflow: 'auto',
        zIndex: 1000,
    },
    overlay: {
        position: 'fixed' as const,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.7)',
        zIndex: 999,
    },
    title: {
        margin: 0,
        marginBottom: theme.spacing.lg,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.xl,
    },
    fontList: {
        marginBottom: theme.spacing.lg,
    },
    fontItem: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        padding: theme.spacing.md,
        backgroundColor: theme.colors.background.tertiary,
        borderRadius: theme.borderRadius.sm,
        marginBottom: theme.spacing.sm,
    },
    button: {
        ...commonStyles.button,
        marginRight: theme.spacing.sm,
    },
    deleteButton: {
        backgroundColor: theme.colors.error,
        color: 'white',
        border: 'none',
        padding: `${theme.spacing.xs} ${theme.spacing.sm}`,
        borderRadius: theme.borderRadius.sm,
        cursor: 'pointer',
    },
    input: {
        display: 'none',
    },
};

export const FontManager: React.FC<FontManagerProps> = ({ onClose }) => {
    const [customFonts, setCustomFonts] = useState<CustomFont[]>([]);

    // Load fonts from background service
    useEffect(() => {
        const loadFonts = async () => {
            try {
                const response = await fetch('http://localhost:3003/fonts/dictionary');
                if (!response.ok) throw new Error('Failed to load fonts');
                const fontDict = await response.json();
                
                // Convert dictionary to array
                const fonts = Object.entries(fontDict).map(([name, data]: [string, any]) => ({
                    name,
                    url: data.url,
                    format: data.format
                }));
                setCustomFonts(fonts);

                // Load each font
                fonts.forEach(font => {
                    try {
                        const testFont = new FontFace(font.name, `url(${font.url})`);
                        testFont.load().then(loadedFont => {
                            document.fonts.add(loadedFont);
                        }).catch(error => {
                            console.error('Error loading font:', error);
                        });
                    } catch (error) {
                        console.error('Error creating font:', error);
                    }
                });
            } catch (error) {
                console.error('Error loading font dictionary:', error);
            }
        };

        loadFonts();
    }, []);

    const handleFileSelect = async (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (!file) return;

        // Check if it's an OTF or TTF file
        if (!file.name.match(/\.(otf|ttf)$/i)) {
            alert('Please select an OTF or TTF font file');
            return;
        }

        try {
            // Create form data
            const formData = new FormData();
            formData.append('file', file);

            // Upload font to font service
            const response = await fetch('http://localhost:3003/set_font', {
                method: 'POST',
                body: formData,
            });

            if (!response.ok) {
                throw new Error('Failed to upload font');
            }

            const result = await response.json();
            const { url, name } = result;
            const format = file.name.toLowerCase().endsWith('.otf') ? 'opentype' as const : 'truetype' as const;

            // Test if font can be loaded
            console.log('Loading font:', name, 'from URL:', url);
            const testFont = new FontFace(name, `url(${url})`);
            await testFont.load();
            document.fonts.add(testFont);
            console.log('Successfully loaded font:', name);

            // Add new font to list
            const newFont: CustomFont = { name, url, format };
            setCustomFonts(prev => [...prev, newFont]);

            // Force preview to reload fonts
            window.dispatchEvent(new Event('fontsUpdated'));

        } catch (error) {
            console.error('Error loading font:', error);
            alert('Error loading font. Please try another file.');
        }
    };

    const handleDelete = async (fontName: string) => {
        try {
            // Delete font from font service
            const response = await fetch('http://localhost:3003/delete_font', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ name: fontName }),
            });

            if (!response.ok) {
                throw new Error('Failed to delete font');
            }

            // Remove font from document.fonts
            const fontToRemove = Array.from(document.fonts).find(f => f.family === fontName);
            if (fontToRemove) {
                document.fonts.delete(fontToRemove);
                console.log('Removed font from document:', fontName);
            }

            // Update state
            setCustomFonts(prev => prev.filter(font => font.name !== fontName));

            // Force preview to reload fonts
            window.dispatchEvent(new Event('fontsUpdated'));

        } catch (error) {
            console.error('Error deleting font:', error);
            alert('Error deleting font. Please try again.');
        }
    };

    return (
        <>
            <div style={styles.overlay} onClick={onClose} />
            <div style={styles.modal}>
                <h2 style={styles.title}>Font Manager</h2>

                <div style={styles.fontList}>
                    {customFonts.map(font => (
                        <div key={font.name} style={styles.fontItem}>
                            <span style={{ 
                                fontFamily: `'${font.name}'`,
                                fontSize: '18px',
                            }}>
                                {font.name} - Sample Text
                            </span>
                            <button
                                style={styles.deleteButton}
                                onClick={() => handleDelete(font.name)}
                            >
                                Delete
                            </button>
                        </div>
                    ))}
                </div>

                <input
                    type="file"
                    accept=".otf,.ttf"
                    onChange={handleFileSelect}
                    id="font-file"
                    style={styles.input}
                />
                <label htmlFor="font-file" style={styles.button}>
                    Add Font
                </label>
                <button style={styles.button} onClick={onClose}>
                    Close
                </button>
            </div>
        </>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Settings\PositioningPopup.tsx ---

import React from 'react';
import { theme } from '../../styles/theme';
import { commonStyles } from '../../styles/commonStyles';

interface PositioningPopupProps {
    onClose: () => void;
    children: React.ReactNode;
}

const styles = {
    overlay: {
        position: 'fixed' as const,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.7)',
        zIndex: 9999,
    },
    modal: {
        position: 'fixed' as const,
        top: '50%',
        left: '50%',
        transform: 'translate(-50%, -50%)',
        backgroundColor: theme.colors.background.secondary,
        padding: theme.spacing.xl,
        borderRadius: theme.borderRadius.lg,
        boxShadow: theme.shadows.lg,
        width: '90vw',
        height: '90vh',
        display: 'flex',
        flexDirection: 'column' as const,
        zIndex: 10000,
    },
    header: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: theme.spacing.lg,
    },
    title: {
        margin: 0,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.xl,
    },
    closeButton: {
        ...commonStyles.button,
        padding: `${theme.spacing.xs} ${theme.spacing.sm}`,
    },
    content: {
        flex: 1,
        overflow: 'hidden',
        backgroundColor: theme.colors.background.tertiary,
        borderRadius: theme.borderRadius.md,
        position: 'relative' as const,
    },
    canvas: {
        width: '100%',
        height: '100%',
        position: 'relative' as const,
        overflow: 'hidden',
        transform: 'scale(2)',
        transformOrigin: 'top left',
    },
};

export const PositioningPopup: React.FC<PositioningPopupProps> = ({ onClose, children }) => {
    return (
        <>
            <div style={styles.overlay} onClick={onClose} />
            <div style={styles.modal}>
                <div style={styles.header}>
                    <h2 style={styles.title}>Precise Positioning</h2>
                    <button style={styles.closeButton} onClick={onClose}>
                        Close
                    </button>
                </div>
                <div style={styles.content}>
                    <div style={styles.canvas}>
                        {children}
                    </div>
                </div>
            </div>
        </>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Setup\ComparisonEditor.tsx ---

import React from 'react';
import {Comparison} from '../../types/quiz';
import { ImageSelector } from './ImageSelector';

interface ComparisonEditorProps {
  item: QuizItem;
  onChange: (item: QuizItem) => void;
  onDelete: () => void;
}

export const ComparisonEditor: React.FC<ComparisonEditorProps> = ({
  item,
  onChange,
  onDelete,
}) => {
  return (
    <div style={{
      border: '1px solid #ccc',
      padding: '20px',
      marginBottom: '20px',
      borderRadius: '8px',
    }}>
      <div style={{ marginBottom: '20px' }}>
        <label>
          Question:
          <input
            type="text"
            value={item.question}
            onChange={(e) => onChange({
              ...item,
              question: e.target.value,
              voiceover: e.target.value, // Auto-set voiceover to question
            })}
            style={{ width: '100%', padding: '8px' }}
          />
        </label>
      </div>

      <div style={{ display: 'flex', gap: '20px' }}>
        {/* Left Option */}
        <div style={{ flex: 1 }}>
          <h4>Left Option</h4>
          <input
            type="text"
            value={item.leftOption.text}
            onChange={(e) => onChange({
              ...item,
              leftOption: {
                ...item.leftOption,
                text: e.target.value,
              },
            })}
            placeholder="Left option text"
          />
          <ImageSelector
            currentImage={item.leftOption.image}
            searchTerm={item.leftOption.text}
            onSelect={(imageUrl) => onChange({
              ...item,
              leftOption: {
                ...item.leftOption,
                image: imageUrl,
              },
            })}
          />
        </div>

        {/* Right Option */}
        <div style={{ flex: 1 }}>
          <h4>Right Option</h4>
          <input
            type="text"
            value={item.rightOption.text}
            onChange={(e) => onChange({
              ...item,
              rightOption: {
                ...item.rightOption,
                text: e.target.value,
              },
            })}
            placeholder="Right option text"
          />
          <ImageSelector
            currentImage={item.rightOption.image}
            searchTerm={item.rightOption.text}
            onSelect={(imageUrl) => onChange({
              ...item,
              rightOption: {
                ...item.rightOption,
                image: imageUrl,
              },
            })}
          />
        </div>
      </div>

      <button onClick={onDelete} style={{ marginTop: '20px', color: 'red' }}>
        Delete Comparison
      </button>
    </div>
  );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Setup\ImagePicker.tsx ---

import React, { useState, useEffect } from 'react';
import { createClient } from 'pexels';

const client = createClient('rXEDE5m6pUxOXZPawHmzKj04Z29WlV2y0Us44ld2TmXwdZstXtHUIh2F');

interface ImagePickerProps {
  currentImage: string;
  searchTerm: string;
  onSelect: (imageUrl: string) => void;
}

export const ImagePicker: React.FC<ImagePickerProps> = ({
  currentImage,
  searchTerm,
  onSelect,
}) => {
  const [images, setImages] = useState<Array<{ url: string }>>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (searchTerm) {
      setLoading(true);
      client.photos.search({ query: searchTerm, per_page: 10 })
        .then(result => {
          if ('photos' in result) {
            setImages(result.photos.map(photo => ({
              url: photo.src.large
            })));
          }
          setLoading(false);
        })
        .catch(err => {
          console.error('Error fetching images:', err);
          setLoading(false);
        });
    }
  }, [searchTerm]);

  return (
    <div>
      {loading ? (
        <div>Loading images...</div>
      ) : (
        <div style={{
          display: 'grid',
          gridTemplateColumns: 'repeat(auto-fill, minmax(100px, 1fr))',
          gap: '10px',
          marginTop: '10px',
        }}>
          {images.map((image, index) => (
            <img
              key={index}
              src={image.url}
              alt={`Option ${index + 1}`}
              style={{
                width: '100%',
                height: '100px',
                objectFit: 'cover',
                cursor: 'pointer',
                border: currentImage === image.url ? '3px solid blue' : '1px solid #ccc',
              }}
              onClick={() => onSelect(image.url)}
            />
          ))}
        </div>
      )}
    </div>
  );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Setup\ImageSelector.tsx ---

import React, { useState, useEffect } from 'react';
import { createClient } from 'pexels';

const client = createClient('rXEDE5m6pUxOXZPawHmzKj04Z29WlV2y0Us44ld2TmXwdZstXtHUIh2F');

interface ImageSelectorProps {
    searchTerm: string;
    onSelect: (imageUrl: string) => void;
    currentImageUrl?: string;
}

export const ImageSelector: React.FC<ImageSelectorProps> = ({
    searchTerm,
    onSelect,
    currentImageUrl,
}) => {
    // ... rest of the component stays the same, just update property names
    // from currentImage to currentImageUrl
    // and image.url to photo.src.medium
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Setup\Setup.tsx ---

import React, { useState } from 'react';
import { Player } from '@remotion/player';
import { QuizVideo } from '../../QuizVideo';
import { QuizItem } from '../../data/quizData';
import { ComparisonEditor } from './ComparisonEditor';

export const Setup: React.FC = () => {
  const [quizItems, setQuizItems] = useState<QuizItem[]>([]);
  
  const addComparison = () => {
    setQuizItems([
      ...quizItems,
      {
        question: '',
        leftOption: {
          image: '',
          text: '',
        },
        rightOption: {
          image: '',
          text: '',
        },
        voiceover: '',
      },
    ]);
  };

  return (
    <div style={{ display: 'flex', gap: '20px', padding: '20px' }}>
      {/* Editor Section */}
      <div style={{ flex: 1 }}>
        <button onClick={addComparison}>Add Comparison</button>
        
        {quizItems.map((item, index) => (
          <ComparisonEditor
            key={index}
            item={item}
            onChange={(updatedItem) => {
              const newItems = [...quizItems];
              newItems[index] = updatedItem;
              setQuizItems(newItems);
            }}
            onDelete={() => {
              const newItems = quizItems.filter((_, i) => i !== index);
              setQuizItems(newItems);
            }}
          />
        ))}
      </div>

      {/* Preview Section */}
      <div style={{ flex: 1 }}>
        <Player
          component={QuizVideo}
          durationInFrames={1800}
          fps={30}
          compositionWidth={1080}
          compositionHeight={1920}
          style={{
            width: '100%',
            height: 'auto',
          }}
          inputProps={{
            quizConfig: {
              comparisons: quizItems
            }
          }}
        />
      </div>
    </div>
  );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\SetupPage.tsx ---

import React, {useState} from 'react';
import {Player} from '@remotion/player';
import {QuizConfig, Comparison} from '../types/quiz';
import {ComparisonEditor} from './ComparisonEditor';
import {QuizVideo} from './Video/QuizVideo';

export const SetupPage: React.FC = () => {
	const [quizConfig, setQuizConfig] = useState<QuizConfig>({
		comparisons: [],
	});

	// Calculate duration, minimum 1 second (30 frames)
	const videoDuration = Math.max(30, quizConfig.comparisons.length * 150);

	return (
		<div style={{
			display: 'grid',
			gridTemplateColumns: '1fr 1fr',
			gap: '20px',
			padding: '20px',
			height: '100vh',
			overflow: 'hidden',
		}}>
			{/* Left side - Editor Section */}
			<div style={{
				overflowY: 'auto',
				padding: '20px',
			}}>
				<h1>Quiz Video Setup</h1>
				<button
					onClick={() => {
						const newComparison: Comparison = {
							id: Date.now().toString(),
							question: '',
							leftOption: {
								text: '',
								imageUrl: '',
							},
							rightOption: {
								text: '',
								imageUrl: '',
							},
						};
						setQuizConfig(prev => ({
							...prev,
							comparisons: [...prev.comparisons, newComparison],
						}));
					}}
					style={{
						padding: '12px 24px',
						fontSize: '16px',
						cursor: 'pointer',
						backgroundColor: '#007bff',
						color: 'white',
						border: 'none',
						borderRadius: '4px',
						marginBottom: '20px',
					}}
				>
					Add New Comparison
				</button>

				<div style={{
					display: 'flex',
					flexDirection: 'column',
					gap: '20px',
				}}>
					{quizConfig.comparisons.map((comparison) => (
						<ComparisonEditor
							key={comparison.id}
							comparison={comparison}
							onChange={(updatedComparison) => {
								setQuizConfig(prev => ({
									...prev,
									comparisons: prev.comparisons.map(c => 
										c.id === updatedComparison.id ? updatedComparison : c
									),
								}));
							}}
							onDelete={() => {
								setQuizConfig(prev => ({
									...prev,
									comparisons: prev.comparisons.filter(c => c.id !== comparison.id),
								}));
							}}
						/>
					))}
				</div>
			</div>

			{/* Right side - Preview Section */}
			<div style={{
				backgroundColor: '#f8f9fa',
				padding: '20px',
				borderRadius: '8px',
				display: 'flex',
				flexDirection: 'column',
				height: '100%',
				overflowY: 'auto',
			}}>
				<h2 style={{marginBottom: '20px'}}>Preview</h2>
				
				{/* Debug Info */}
				<div style={{ 
					marginBottom: '20px', 
					padding: '10px', 
					backgroundColor: '#eee', 
					borderRadius: '4px' 
				}}>
					<h3>Debug Info:</h3>
					<pre style={{ whiteSpace: 'pre-wrap', wordBreak: 'break-word' }}>
						{JSON.stringify({
							comparisonsCount: quizConfig.comparisons.length,
							videoDuration,
							firstComparison: quizConfig.comparisons[0],
						}, null, 2)}
					</pre>
				</div>

				{/* Player Container */}
				<div style={{
					position: 'relative',
					width: '100%',
					paddingTop: '177.78%', // 16:9 aspect ratio
					backgroundColor: '#000',
					borderRadius: '8px',
					overflow: 'hidden',
				}}>
					<div style={{
						position: 'absolute',
						top: 0,
						left: 0,
						right: 0,
						bottom: 0,
					}}>
						<Player
							component={QuizVideo}
							inputProps={{
								quizConfig: quizConfig,
							}}
							durationInFrames={videoDuration}
							fps={30}
							compositionWidth={1080}
							compositionHeight={1920}
							style={{
								width: '100%',
								height: '100%',
							}}
							controls
							autoPlay
							loop
						/>
					</div>
				</div>
			</div>
		</div>
	);
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\TemplateManager\TemplateManager.tsx ---

import React, { useState, useEffect } from 'react';
import {
    Box,
    Button,
    Dialog,
    DialogTitle,
    DialogContent,
    DialogActions,
    TextField,
    List,
    ListItem,
    ListItemText,
    ListItemSecondaryAction,
    IconButton,
    Typography,
    Tooltip,
} from '@mui/material';
import DeleteIcon from '@mui/icons-material/Delete';
import DownloadIcon from '@mui/icons-material/Download';
import AddIcon from '@mui/icons-material/Add';
import { Template } from '../../types/template';
import { Script } from '../../types/script';
import {
    getTemplates,
    saveTemplate,
    deleteTemplate,
    scriptToTemplate,
    templateToScript,
} from '../../services/templateService';

interface TemplateManagerProps {
    currentScript?: Script;
    onTemplateSelect?: (script: Script) => void;
}

export const TemplateManager: React.FC<TemplateManagerProps> = ({
    currentScript,
    onTemplateSelect,
}) => {
    const [templates, setTemplates] = useState<Template[]>([]);
    const [isAddDialogOpen, setIsAddDialogOpen] = useState(false);
    const [newTemplateName, setNewTemplateName] = useState('');
    const [newTemplateDescription, setNewTemplateDescription] = useState('');

    useEffect(() => {
        loadTemplates();
    }, []);

    const loadTemplates = () => {
        const loadedTemplates = getTemplates();
        setTemplates(loadedTemplates);
    };

    const handleSaveTemplate = () => {
        if (!currentScript || !newTemplateName) return;

        const template = scriptToTemplate(
            currentScript,
            newTemplateName,
            newTemplateDescription
        );
        saveTemplate(template);
        setIsAddDialogOpen(false);
        setNewTemplateName('');
        setNewTemplateDescription('');
        loadTemplates();
    };

    const handleDeleteTemplate = (templateId: string) => {
        deleteTemplate(templateId);
        loadTemplates();
    };

    const handleTemplateSelect = (template: Template) => {
        if (onTemplateSelect) {
            const script = templateToScript(template);
            onTemplateSelect(script);
        }
    };

    const handleDownloadTemplate = (template: Template) => {
        const templateJson = JSON.stringify(template, null, 2);
        const blob = new Blob([templateJson], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${template.name.toLowerCase().replace(/\s+/g, '_')}_template.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    };

    return (
        <Box>
            <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
                <Typography variant="h6">Templates</Typography>
                <Button
                    variant="contained"
                    color="primary"
                    startIcon={<AddIcon />}
                    onClick={() => setIsAddDialogOpen(true)}
                    disabled={!currentScript}
                >
                    Save as Template
                </Button>
            </Box>

            <List>
                {templates.map((template) => (
                    <ListItem
                        key={template.id}
                        button
                        onClick={() => handleTemplateSelect(template)}
                    >
                        <ListItemText
                            primary={template.name}
                            secondary={template.description || 'No description'}
                        />
                        <ListItemSecondaryAction>
                            <Tooltip title="Download Template">
                                <IconButton
                                    edge="end"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        handleDownloadTemplate(template);
                                    }}
                                >
                                    <DownloadIcon />
                                </IconButton>
                            </Tooltip>
                            <Tooltip title="Delete Template">
                                <IconButton
                                    edge="end"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        handleDeleteTemplate(template.id);
                                    }}
                                >
                                    <DeleteIcon />
                                </IconButton>
                            </Tooltip>
                        </ListItemSecondaryAction>
                    </ListItem>
                ))}
                {templates.length === 0 && (
                    <Typography color="textSecondary" align="center" py={2}>
                        No templates saved yet
                    </Typography>
                )}
            </List>

            <Dialog
                open={isAddDialogOpen}
                onClose={() => setIsAddDialogOpen(false)}
                maxWidth="sm"
                fullWidth
            >
                <DialogTitle>Save as Template</DialogTitle>
                <DialogContent>
                    <TextField
                        autoFocus
                        margin="dense"
                        label="Template Name"
                        fullWidth
                        value={newTemplateName}
                        onChange={(e) => setNewTemplateName(e.target.value)}
                    />
                    <TextField
                        margin="dense"
                        label="Description (optional)"
                        fullWidth
                        multiline
                        rows={3}
                        value={newTemplateDescription}
                        onChange={(e) => setNewTemplateDescription(e.target.value)}
                    />
                </DialogContent>
                <DialogActions>
                    <Button onClick={() => setIsAddDialogOpen(false)}>Cancel</Button>
                    <Button
                        onClick={handleSaveTemplate}
                        color="primary"
                        disabled={!newTemplateName}
                    >
                        Save
                    </Button>
                </DialogActions>
            </Dialog>
        </Box>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Timer.tsx ---

import {useCurrentFrame, Video} from 'remotion';
import clockVideo from '../@Assets/clock.mp4';

interface TimerProps {
	startFrame: number;
}

export const Timer: React.FC<TimerProps> = ({startFrame}) => {
	const frame = useCurrentFrame();
	const relativeFrame = frame - startFrame;

	return (
		<div style={{
			position: 'absolute',
			bottom: 100,
			left: '50%',
			transform: 'translateX(-50%)',
			width: '200px', // Adjust size as needed
			height: '200px',
		}}>
			<Video
				src={clockVideo}
				startFrom={relativeFrame}
				endAt={relativeFrame + 150} // 5 seconds at 30fps
				style={{
					width: '100%',
					height: '100%',
				}}
			/>
		</div>
	);
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\AudioComponent.tsx ---

import React, { useEffect, useRef } from 'react';
import { useCurrentFrame, useVideoConfig } from 'remotion';
import { AudioComponent as AudioComponentType } from '../../types/script';

interface AudioComponentProps {
    component: AudioComponentType;
}

export const AudioComponent: React.FC<AudioComponentProps> = ({ component }) => {
    const frame = useCurrentFrame();
    const { fps } = useVideoConfig();
    const audioRef = useRef<HTMLAudioElement>(null);
    const audioContextRef = useRef<AudioContext | null>(null);
    const sourceNodeRef = useRef<MediaElementAudioSourceNode | null>(null);
    const gainNodeRef = useRef<GainNode | null>(null);

    useEffect(() => {
        if (!audioRef.current) return;

        // Initialize Web Audio API context and nodes
        if (!audioContextRef.current) {
            const AudioContextClass = window.AudioContext || (window as any).webkitAudioContext;
            audioContextRef.current = new AudioContextClass();
            sourceNodeRef.current = audioContextRef.current.createMediaElementSource(audioRef.current);
            gainNodeRef.current = audioContextRef.current.createGain();
            sourceNodeRef.current.connect(gainNodeRef.current);
            gainNodeRef.current.connect(audioContextRef.current.destination);
        }

        const audio = audioRef.current;
        const gainNode = gainNodeRef.current;
        const startTime = component.style?.startTime ?? 0;
        const currentTime = frame / fps;

        // Set volume using gain node
        if (gainNode) {
            gainNode.gain.value = component.style?.volume ?? 1;
        }

        // Set loop
        audio.loop = component.style?.loop ?? false;

        // Calculate and set current time
        const audioTime = currentTime - startTime;
        if (audioTime >= 0) {
            audio.currentTime = audioTime;
            audio.play().catch(console.error);
        } else {
            audio.pause();
        }

        // Handle duration limit
        if (component.style?.duration) {
            const duration = component.style.duration;
            if (audioTime > duration) {
                audio.pause();
            }
        }

        // Cleanup
        return () => {
            audio.pause();
            if (audioContextRef.current) {
                audioContextRef.current.close();
                audioContextRef.current = null;
                sourceNodeRef.current = null;
                gainNodeRef.current = null;
            }
        };
    }, [frame, fps, component.style?.startTime, component.style?.volume, component.style?.loop, component.style?.duration]);

    const audioUrl = typeof component.audioUrl === 'string' ? component.audioUrl : component.audioUrl.url;

    return (
        <audio
            ref={audioRef}
            src={audioUrl}
            preload="auto"
            crossOrigin="anonymous"
        />
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\CaptionRenderer.tsx ---

import React from 'react';
import { useCurrentFrame } from 'remotion';
import { WordTiming, CaptionStyle } from '../../types/script';

interface CaptionRendererProps {
    wordTimings: WordTiming[];
    style: CaptionStyle;
}

export const CaptionRenderer: React.FC<CaptionRendererProps> = ({ wordTimings, style }) => {
    const frame = useCurrentFrame();
    const fps = 30; // Standard frame rate
    const currentTime = frame / fps;

    // Find words that should be visible based on the current time and word window
    const visibleWords = wordTimings.filter(timing => {
        const isWithinTime = currentTime >= timing.start && currentTime <= timing.end;
        if (!isWithinTime) return false;

        // Find the index of the current word
        const currentIndex = wordTimings.findIndex(w => w === timing);
        const windowStart = Math.max(0, currentIndex - Math.floor(style.wordWindow / 2));
        const windowEnd = Math.min(wordTimings.length - 1, currentIndex + Math.floor(style.wordWindow / 2));

        // Check if the word is within the window
        return currentIndex >= windowStart && currentIndex <= windowEnd;
    });

    if (visibleWords.length === 0) return null;

    return (
        <div style={{
            position: 'absolute',
            bottom: style.position === 'top' ? 'auto' : '10%',
            top: style.position === 'top' ? '10%' : 'auto',
            left: '50%',
            transform: 'translateX(-50%)',
            textAlign: 'center',
            fontSize: style.fontSize,
            color: style.color,
            backgroundColor: style.backgroundColor,
            padding: '10px 20px',
            borderRadius: '5px',
            maxWidth: '80%',
            transition: 'all 0.2s ease-in-out'
        }}>
            {visibleWords.map(word => word.word).join(' ')}
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\ComparisonComponent.tsx ---

import React from 'react';
import { ComparisonComponent as ComparisonComponentType } from '../../types/script';
import { AbsoluteFill, useCurrentFrame, interpolate, spring } from 'remotion';
import { theme } from '../../styles/theme';

interface ComparisonComponentProps {
    component: ComparisonComponentType;
}

const getAnimationStyle = (
    frame: number,
    animation: ComparisonComponentType['style']['animation'],
    isSecondImage: boolean = false,
    durationInFrames: number
) => {
    if (!animation || animation.type === 'none') {
        return {};
    }

    const delay = (animation.delay || 0) + (isSecondImage ? (animation.stagger || 0) : 0);
    const duration = animation.duration || 30;
    const currentFrame = Math.max(0, frame - delay);
    const progress = interpolate(
        currentFrame,
        [0, duration, durationInFrames - duration, durationInFrames],
        [0, 1, 1, 0],
        {
            extrapolateLeft: 'clamp',
            extrapolateRight: 'clamp',
            easing: animation.easing === 'linear' ? (t) => t :
                   animation.easing === 'ease-in' ? (t) => t * t :
                   animation.easing === 'ease-out' ? (t) => 1 - Math.pow(1 - t, 2) :
                   (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2
        }
    );

    switch (animation.type) {
        case 'fade':
            return { opacity: progress };
        case 'scale':
            return { transform: `scale(${progress})` };
        case 'rotate':
            return { transform: `rotate(${interpolate(progress, [0, 1], [0, 360])}deg)` };
        case 'slide':
            const offset = 100;
            const x = animation.direction === 'left' ? -offset : 
                     animation.direction === 'right' ? offset : 0;
            const y = animation.direction === 'top' ? -offset :
                     animation.direction === 'bottom' ? offset : 0;
            return {
                transform: `translate(${interpolate(progress, [0, 1], [x, 0])}%, ${interpolate(progress, [0, 1], [y, 0])}%)`
            };
        default:
            return {};
    }
};

export const ComparisonComponent: React.FC<ComparisonComponentProps> = ({ component }) => {
    const frame = useCurrentFrame();
    const { 
        fontSize = 32, 
        fontFamily = 'Arial', 
        textColor = '#ffffff', 
        backgroundColor = 'rgba(0, 0, 0, 0.7)', 
        spacing = 20, 
        borderRadius = 8, 
        shadow = true,
        showText = true,
        imageSize = 100,
        imageGap = 20,
        forceSameSize = true,
        imagePosition = { x: 0, y: 0 },
        imageBorder,
        imageDropShadow,
        animation
    } = component.style || {};

    // Base fade animation
    const opacity = interpolate(
        frame,
        [0, 15, component.durationInFrames - 15, component.durationInFrames],
        [0, 1, 1, 0]
    );

    const imageContainerStyle = {
        display: 'flex',
        flexDirection: component.orientation === 'horizontal' ? 'row' as const : 'column' as const,
        gap: `${imageGap}px`,
        justifyContent: 'center',
        alignItems: 'center',
        transform: `translate(${imagePosition.x}%, ${imagePosition.y}%)`,
        width: '100%',
        height: '100%',
        padding: '10% 5%',
    };

    const commonImageStyle = {
        width: forceSameSize ? `${imageSize}%` : 'auto',
        height: forceSameSize ? `${imageSize}%` : 'auto',
        maxWidth: forceSameSize ? `${imageSize}%` : '100%',
        maxHeight: forceSameSize ? `${imageSize}%` : '100%',
        objectFit: forceSameSize ? 'contain' : 'cover',
        borderRadius: `${borderRadius}px`,
        border: imageBorder?.enabled ? `${imageBorder.width}px solid ${imageBorder.color}` : undefined,
        boxShadow: imageDropShadow?.enabled ? 
            `${imageDropShadow.x}px ${imageDropShadow.y}px ${imageDropShadow.blur}px ${imageDropShadow.spread}px ${imageDropShadow.color}` : 
            undefined,
    };

    return (
        <AbsoluteFill style={{ opacity }}>
            {/* Question */}
            {showText && (
                <div style={{
                    position: 'absolute',
                    top: '5%',
                    left: '50%',
                    transform: 'translateX(-50%)',
                    backgroundColor,
                    padding: '10px 20px',
                    borderRadius: borderRadius,
                    boxShadow: shadow ? '0 2px 4px rgba(0,0,0,0.2)' : undefined,
                    fontSize: `${fontSize}px`,
                    fontFamily,
                    color: textColor,
                    textAlign: 'center',
                    zIndex: 10,
                }}>
                    {component.question}
                </div>
            )}

            {/* Images Container */}
            <div style={imageContainerStyle}>
                {/* Left/Top Image */}
                <div style={{
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    gap: '10px',
                    ...getAnimationStyle(frame, animation, false, component.durationInFrames),
                }}>
                    <img
                        src={component.leftOption.imageUrl}
                        style={commonImageStyle}
                        alt={component.leftOption.text}
                    />
                    {showText && (
                        <div style={{
                            backgroundColor,
                            padding: '5px 10px',
                            borderRadius: borderRadius,
                            boxShadow: shadow ? '0 2px 4px rgba(0,0,0,0.2)' : undefined,
                            fontSize: `${fontSize * 0.8}px`,
                            fontFamily,
                            color: textColor,
                            textAlign: 'center',
                        }}>
                            {component.leftOption.text}
                        </div>
                    )}
                </div>

                {/* Right/Bottom Image */}
                <div style={{
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    gap: '10px',
                    ...getAnimationStyle(frame, animation, true, component.durationInFrames),
                }}>
                    <img
                        src={component.rightOption.imageUrl}
                        style={commonImageStyle}
                        alt={component.rightOption.text}
                    />
                    {showText && (
                        <div style={{
                            backgroundColor,
                            padding: '5px 10px',
                            borderRadius: borderRadius,
                            boxShadow: shadow ? '0 2px 4px rgba(0,0,0,0.2)' : undefined,
                            fontSize: `${fontSize * 0.8}px`,
                            fontFamily,
                            color: textColor,
                            textAlign: 'center',
                        }}>
                            {component.rightOption.text}
                        </div>
                    )}
                </div>
            </div>
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\ComparisonSequence.tsx ---

import React from 'react';
import { AbsoluteFill } from 'remotion';
import { Comparison } from '../../types/quiz';

interface ComparisonSequenceProps {
    comparison: Comparison;
}

export const ComparisonSequence: React.FC<ComparisonSequenceProps> = ({ comparison }) => {
    return (
        <AbsoluteFill>
            {/* Component content */}
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\CountdownSequence.tsx ---

import React from 'react';
import { AbsoluteFill, useCurrentFrame } from 'remotion';
import { CountdownComponent } from '../../types/script';

interface CountdownSequenceProps {
    component: CountdownComponent;
}

export const CountdownSequence: React.FC<CountdownSequenceProps> = ({ component }) => {
    const frame = useCurrentFrame();
    const style = component.style || {};
    const position = style.position || { x: 0, y: 0 };

    // Calculate current number based on frame
    const from = component.from || 10;
    const framePerNumber = component.durationInFrames ? component.durationInFrames / from : 30;
    const currentNumber = Math.max(0, Math.ceil(from - frame / framePerNumber));

    return (
        <AbsoluteFill>
            <div style={{
                position: 'absolute',
                left: position.x,
                top: position.y,
                fontSize: style.fontSize || 80,
                fontFamily: style.fontFamily || 'Arial',
                color: style.color || 'white',
                textAlign: style.textAlign || 'center',
                width: style.position?.width || 300,
                fontWeight: 'bold',
                transform: 'translate(0, 0)', // Prevent any transform issues
            }}>
                {currentNumber}
            </div>
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\ImageComponent.tsx ---

import React from 'react';
import { AbsoluteFill } from 'remotion';
import { ImageComponent as ImageComponentType } from '../../types/script';

interface ImageComponentProps {
    component: ImageComponentType;
}

export const ImageComponent: React.FC<ImageComponentProps> = ({ component }) => {
    const {
        imageUrl,
        style = {}
    } = component;

    const {
        width = 400,
        height = 400,
        position = { x: 0, y: 0 },
        scale = 1,
        rotation = 0,
        opacity = 1,
        border = { enabled: false, color: '#000000', width: 2 },
        dropShadow = { enabled: false, color: '#000000', blur: 10, spread: 0, x: 5, y: 5 }
    } = style;

    // Calculate shadow styles if enabled
    const shadowStyle = dropShadow.enabled ? {
        filter: `drop-shadow(${dropShadow.x}px ${dropShadow.y}px ${dropShadow.blur}px ${dropShadow.color})`
    } : {};

    // Calculate border styles if enabled
    const borderStyle = border.enabled ? {
        border: `${border.width}px solid ${border.color}`
    } : {};

    return (
        <AbsoluteFill>
            <div
                style={{
                    position: 'absolute',
                    left: `${position.x}px`,
                    top: `${position.y}px`,
                    width: `${width}px`,
                    height: `${height}px`,
                    transform: `scale(${scale}) rotate(${rotation}deg)`,
                    opacity,
                    ...shadowStyle,
                    ...borderStyle,
                    overflow: 'hidden',
                }}
            >
                <img
                    src={imageUrl}
                    alt="Video component"
                    style={{
                        width: '100%',
                        height: '100%',
                        objectFit: 'cover',
                    }}
                />
            </div>
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\QuizVideo.tsx ---

import React from 'react';
import {
    AbsoluteFill,
    Audio,
    Sequence,
    useVideoConfig,
} from 'remotion';
import {QuizConfig} from '../../types/quiz';
import {ComparisonSequence} from './ComparisonSequence';

interface QuizVideoProps {
    quizConfig: QuizConfig;
}

export const QuizVideo: React.FC<QuizVideoProps> = ({quizConfig}) => {
    const {fps} = useVideoConfig();
    const SEQUENCE_DURATION = 5 * fps;

    // Handle empty state
    if (!quizConfig.comparisons.length) {
        return (
            <AbsoluteFill style={{
                backgroundColor: '#1a1a1a',
                display: 'flex',
                justifyContent: 'center',
                alignItems: 'center',
            }}>
                <h1 style={{color: 'white'}}>Add a comparison to start</h1>
            </AbsoluteFill>
        );
    }

    return (
        <AbsoluteFill style={{backgroundColor: '#1a1a1a'}}>
            {quizConfig.comparisons.map((comparison, index) => (
                <Sequence
                    key={comparison.id}
                    from={index * SEQUENCE_DURATION}
                    durationInFrames={SEQUENCE_DURATION}
                >
                    <ComparisonSequence comparison={comparison} />
                </Sequence>
            ))}
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\RemotionSubtitleCaption.tsx ---

import React, { useEffect } from 'react';
import { useCurrentFrame, useVideoConfig } from 'remotion';
import { SubtitleSequence } from 'remotion-subtitle';
import {
    BounceCaption,
    ColorfulCaption,
    ExplosiveCaption,
    FadeCaption,
    FireCaption,
    GlitchCaption,
    GlowingCaption,
    LightningCaption,
    NeonCaption,
    RotatingCaption,
    ShakeCaption,
    ThreeDishCaption,
    TiltShiftCaption,
    TypewriterCaption,
    WavingCaption,
    ZoomCaption,
} from 'remotion-subtitle';
import { TextStyle, WordTiming } from '../../types/script';

interface RemotionSubtitleCaptionProps {
    wordTimings: WordTiming[];
    style: TextStyle;
    startFrame: number;
}

const CAPTION_COMPONENTS = {
    bounce: BounceCaption,
    colorful: ColorfulCaption,
    explosive: ExplosiveCaption,
    fade: FadeCaption,
    fire: FireCaption,
    glitch: GlitchCaption,
    glowing: GlowingCaption,
    lightning: LightningCaption,
    neon: NeonCaption,
    rotating: RotatingCaption,
    shake: ShakeCaption,
    threeDish: ThreeDishCaption,
    tiltShift: TiltShiftCaption,
    typewriter: TypewriterCaption,
    waving: WavingCaption,
    zoom: ZoomCaption,
};

export const RemotionSubtitleCaption: React.FC<RemotionSubtitleCaptionProps> = (props) => {
    const { wordTimings, style, startFrame } = props;
    const frame = useCurrentFrame();
    const { fps } = useVideoConfig();
    const currentTime = frame / fps;
    const componentStartTime = startFrame / fps;

    // Enhanced debug logging
    const debugLog = (message: string, data?: any, trace: boolean = false, level: 'info' | 'warn' | 'error' = 'info') => {
        const timestamp = new Date().toISOString();
        const frameInfo = `[Frame: ${frame}]`;
        const componentInfo = `[RemotionSubtitleCaption]`;
        const propsSnapshot = JSON.stringify(props, null, 2);
        const callStack = new Error().stack;

        console.group(`${timestamp} ${frameInfo} ${componentInfo} ${message}`);
        console.log('Props Snapshot:', propsSnapshot);
        console.log('Current Frame:', frame);
        console.log('FPS:', fps);
        console.log('Current Time:', currentTime);
        console.log('Component Start Time:', componentStartTime);
        console.log('Data:', data);
        console.log('Call Stack:', callStack);
        if (trace) {
            console.trace('Detailed Stack Trace');
        }
        console.groupEnd();
    };

    // Log initial render
    debugLog('Component Initial Render', {
        hasWordTimings: !!wordTimings,
        wordTimingsCount: wordTimings.length,
        style,
        startFrame,
        currentTime,
        componentStartTime
    }, true);

    // Log component mount
    useEffect(() => {
        debugLog('Component Mounted', {
            wordTimingsCount: wordTimings.length,
            style,
            startFrame,
            currentTime,
            componentStartTime,
            mountTime: new Date().toISOString(),
        }, true);

        return () => {
            debugLog('Component Unmounting', {
                unmountTime: new Date().toISOString(),
                lastFrame: frame,
            }, true);
        };
    }, []);

    // Log every frame update
    useEffect(() => {
        const frameStartTime = performance.now();
        debugLog('Frame Update', {
            currentFrame: frame,
            currentTime,
            componentStartTime,
            activeWords: wordTimings.filter(timing => {
                const start = timing.start - componentStartTime;
                const end = timing.end - componentStartTime;
                return currentTime >= start && currentTime <= end;
            }).map(w => w.word)
        });
        const frameEndTime = performance.now();
        debugLog('Frame Update Complete', {
            frameDuration: frameEndTime - frameStartTime,
            frame,
        });
    }, [frame]);

    // Convert word timings to SRT format with logging
    debugLog('Converting word timings to SRT format', {
        wordTimings,
        componentStartTime
    });

    const srtContent = wordTimings
        .map((timing, index) => {
            const start = timing.start - componentStartTime;
            const end = timing.end - componentStartTime;
            const srtEntry = `${index + 1}\n${formatTime(start)} --> ${formatTime(end)}\n${timing.word}\n\n`;
            
            debugLog('Generated SRT entry:', {
                index,
                word: timing.word,
                originalStart: timing.start,
                originalEnd: timing.end,
                adjustedStart: start,
                adjustedEnd: end,
                srtEntry
            });

            return srtEntry;
        })
        .join('');

    // Get the appropriate caption component
    const CaptionComponent = style.captionStyle && CAPTION_COMPONENTS[style.captionStyle as keyof typeof CAPTION_COMPONENTS];
    
    debugLog('Caption component selection:', {
        requestedStyle: style.captionStyle,
        foundComponent: !!CaptionComponent,
        availableStyles: Object.keys(CAPTION_COMPONENTS)
    });

    if (!CaptionComponent) {
        debugLog('No caption component found for style', {
            style: style.captionStyle
        }, true);
        return null;
    }

    // Create subtitle sequence with logging
    debugLog('Creating subtitle sequence', {
        srtContent,
        style
    });

    const subtitles = new SubtitleSequence(srtContent);

    debugLog('Rendering subtitles', {
        currentFrame: frame,
        currentTime,
        style: {
            fontSize: style.fontSize || '24px',
            color: style.color || 'white',
            ...style,
        }
    }, true);

    return (
        <div style={{
            position: 'absolute',
            left: '50%',
            bottom: '10%',
            transform: 'translateX(-50%)',
            width: '80%',
            textAlign: 'center',
        }}>
            {debugLog('Rendering Subtitles', {
                currentTime,
                componentStartTime,
                activeWords: wordTimings.filter(timing => {
                    const start = timing.start - componentStartTime;
                    const end = timing.end - componentStartTime;
                    return currentTime >= start && currentTime <= end;
                }).map(w => w.word)
            })}
            {subtitles.getSequences(
                <CaptionComponent style={{
                    fontSize: style.fontSize || '24px',
                    color: style.color || 'white',
                    ...style,
                }} />,
                fps
            )}
        </div>
    );
};

// Helper function to format time in SRT format (HH:MM:SS,mmm)
function formatTime(seconds: number): string {
    const pad = (n: number, width: number) => String(n).padStart(width, '0');
    
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    const ms = Math.floor((seconds % 1) * 1000);
    
    return `${pad(hours, 2)}:${pad(minutes, 2)}:${pad(secs, 2)},${pad(ms, 3)}`;
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\ScriptVideo.tsx ---

import React, { useEffect, useState, useMemo } from 'react';
import { AbsoluteFill, Sequence, spring, useCurrentFrame, useVideoConfig, Audio } from 'remotion';
import { Script, TextComponent as TextComponentType, VoiceComponent as VoiceComponentType, AudioComponent as AudioComponentType } from '../../types/script';
import { CaptionRenderer } from './CaptionRenderer';
import { ComparisonComponent } from './ComparisonComponent';
import { VideoComponent } from './VideoComponent';
import { TextComponent } from './TextComponent';

interface ScriptVideoProps {
    script: Script;
}

const getAnimationStyle = (frame: number, fps: number, animation: string, direction: 'in' | 'out', timing: { start: number; end: number }) => {
    if (!animation) return {};

    const isOut = direction === 'out';
    const durationInFrames = timing.end - timing.start;
    const adjustedFrame = frame - timing.start;

    console.log(`Animation ${direction}:`, {
        frame,
        adjustedFrame,
        timing,
        durationInFrames,
    });

    // If we're not within the animation timeframe, return the final state
    if (adjustedFrame < 0) return isOut ? {} : { opacity: 0, transform: getInitialTransform(animation) };
    if (adjustedFrame > durationInFrames) return isOut ? { opacity: 0, transform: getFinalTransform(animation) } : {};

    switch (animation) {
        case 'slide-left': {
            const opacity = spring({
                frame: adjustedFrame,
                fps,
                from: isOut ? 1 : 0,
                to: isOut ? 0 : 1,
                durationInFrames,
            });

            const slideX = spring({
                frame: adjustedFrame,
                fps,
                from: isOut ? 0 : -200,
                to: isOut ? -200 : 0,
                durationInFrames,
                config: {
                    damping: 12,
                    mass: 0.5,
                },
            });

            return {
                opacity,
                transform: `translateX(${slideX}px)`,
            };
        }
        case 'slide-right': {
            const opacity = spring({
                frame: adjustedFrame,
                fps,
                from: isOut ? 1 : 0,
                to: isOut ? 0 : 1,
                durationInFrames,
            });

            const slideX = spring({
                frame: adjustedFrame,
                fps,
                from: isOut ? 0 : 200,
                to: isOut ? 200 : 0,
                durationInFrames,
                config: {
                    damping: 12,
                    mass: 0.5,
                },
            });

            return {
                opacity,
                transform: `translateX(${slideX}px)`,
            };
        }
        default:
            return {};
    }
};

// Helper functions to get initial and final transform states
const getInitialTransform = (animation: string) => {
    switch (animation) {
        case 'slide-left':
            return 'translateX(-200px)';
        case 'slide-right':
            return 'translateX(200px)';
        default:
            return 'none';
    }
};

const getFinalTransform = (animation: string) => {
    switch (animation) {
        case 'slide-left':
            return 'translateX(-200px)';
        case 'slide-right':
            return 'translateX(200px)';
        default:
            return 'none';
    }
};

const BACKGROUND_SERVICE_URL = 'http://localhost:3002';

export const ScriptVideo: React.FC<ScriptVideoProps> = ({ script }) => {
    // Store the background URL in state to prevent re-fetching
    const [bgUrl, setBgUrl] = useState<string | null>(null);

    useEffect(() => {
        if (script.settings?.background?.type === 'image' && script.settings.background.url) {
            // If it's already a full URL, or we want to prefix a local service
            let finalUrl = script.settings.background.url;
            if (!/^https?:\/\//.test(finalUrl)) {
                // Not a fully qualified URL, prefix the background service
                finalUrl = `${BACKGROUND_SERVICE_URL}/backgrounds/${encodeURIComponent(finalUrl)}`;
            }
            setBgUrl(finalUrl);
        } else if (script.settings?.background?.type === 'video' && script.settings.background.url) {
            // Handle video backgrounds similarly
            let finalUrl = script.settings.background.url;
            if (!/^https?:\/\//.test(finalUrl)) {
                finalUrl = `${BACKGROUND_SERVICE_URL}/backgrounds/${encodeURIComponent(finalUrl)}`;
            }
            setBgUrl(finalUrl);
        } else {
            setBgUrl(null);
        }
    }, [script.settings?.background]);

    // Memoize the background style to prevent unnecessary re-renders
    const backgroundStyle = useMemo(() => {
        if (!bgUrl) {
            return {
                backgroundColor: 'black',
            };
        }

        if (script.settings?.background?.type === 'video') {
            return {
                backgroundColor: 'black',
            };
        }

        return {
            backgroundImage: `url("${bgUrl}")`,
            backgroundSize: 'cover',
            backgroundPosition: 'center',
            backgroundRepeat: 'no-repeat',
        };
    }, [bgUrl, script.settings?.background?.type]);

    useEffect(() => {
        const loadFonts = async () => {
            try {
                // Get font dictionary from font service
                const response = await fetch('http://localhost:3003/fonts/dictionary');
                if (!response.ok) throw new Error('Failed to load font dictionary');
                const fontDict = await response.json();
                console.log('ScriptVideo: Font dictionary:', fontDict);

                // Get unique font families used in components
                const usedFonts = new Set<string>();
                script.components.forEach(comp => {
                    if (comp.type === 'text' || comp.type === 'title') {
                        const textComp = comp as { style?: { fontFamily?: string } };
                        if (textComp.style?.fontFamily) {
                            usedFonts.add(textComp.style.fontFamily);
                            console.log('ScriptVideo: Found font:', textComp.style.fontFamily);
                        }
                    }
                });

                // Load each used font
                const fontLoadPromises = Array.from(usedFonts).map(async fontName => {
                    const fontData = fontDict[fontName];
                    if (fontData?.url) {
                        try {
                            console.log('ScriptVideo: Loading font:', fontName, 'from URL:', fontData.url);
                            const font = new FontFace(fontName, `url(${fontData.url})`);
                            const loadedFont = await font.load();
                            document.fonts.add(loadedFont);
                            console.log('ScriptVideo: Successfully loaded font:', fontName);
                            return true;
                        } catch (error) {
                            console.error('ScriptVideo: Error loading font:', fontName, error);
                            return false;
                        }
                    }
                    return false;
                });

                await Promise.all(fontLoadPromises);
                console.log('ScriptVideo: All fonts loaded');
            } catch (error) {
                console.error('ScriptVideo: Error loading fonts:', error);
            }
        };

        loadFonts();
    }, [script]);

    return (
        <AbsoluteFill style={backgroundStyle}>
            {script.settings?.background?.type === 'video' && bgUrl && (
                <video
                    src={bgUrl}
                    style={{
                        position: 'absolute',
                        width: '100%',
                        height: '100%',
                        objectFit: 'cover',
                    }}
                    autoPlay
                    loop
                    muted
                />
            )}
            {script.components.map((component) => {
                const key = `${component.id}-${component.startFrame}-${component.durationInFrames}`;
                return (
                    <Sequence
                        key={key}
                        from={component.startFrame || 0}
                        durationInFrames={component.durationInFrames || 150}
                    >
                        {component.type === 'text' && (
                            <TextComponent component={component as TextComponentType} />
                        )}
                        {component.type === 'comparison' && (
                            <ComparisonComponent component={component as any} />
                        )}
                        {component.type === 'video' && (
                            <VideoComponent component={component as any} />
                        )}
                        {component.type === 'voice' && (
                            <VoiceComponent component={component as VoiceComponentType} />
                        )}
                        {component.type === 'audio' && (
                            <AudioEffectComponent component={component as AudioComponentType} />
                        )}
                    </Sequence>
                );
            })}
        </AbsoluteFill>
    );
};

const TextComponent: React.FC<{ component: TextComponentType }> = ({ component }) => {
    const frame = useCurrentFrame();
    const { fps } = useVideoConfig();
    
    const animationIn = component.style?.animation?.in?.type || '';
    const animationOut = component.style?.animation?.out?.type || '';
    
    // Calculate animation timings
    const totalDuration = component.durationInFrames || 150;
    
    // For entrance animation
    const inStartFrame = component.style?.animation?.in?.startFrame || 0;
    const inEndFrame = component.style?.animation?.in?.endFrame || 30;
    const inTiming = {
        start: inStartFrame,
        end: inEndFrame,
    };
    
    // For exit animation
    const outStartFrame = totalDuration - (component.style?.animation?.out?.startFrame || 30);
    const outEndFrame = totalDuration - (component.style?.animation?.out?.endFrame || 0);
    const outTiming = {
        start: outStartFrame,
        end: outEndFrame,
    };
    
    console.log('Animation frames:', {
        frame,
        totalDuration,
        in: { start: inStartFrame, end: inEndFrame },
        out: { start: outStartFrame, end: outEndFrame },
    });
    
    const animationStyleIn = getAnimationStyle(frame, fps, animationIn, 'in', inTiming);
    const animationStyleOut = getAnimationStyle(frame, fps, animationOut, 'out', outTiming);
    
    return (
        <div style={{
            position: 'absolute',
            left: component.style?.position?.x || 0,
            top: component.style?.position?.y || 0,
            width: 'auto',
            display: 'inline-block',
            ...(component.style?.blockStyle?.enabled ? {
                backgroundColor: component.style.backgroundColor || '#FFFFFF',
                padding: '20px 40px',
                borderRadius: '15px',
                boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
                minWidth: '33%',
            } : {}),
            textAlign: component.style?.textAlign || 'center',
            color: component.style?.color || 'white',
            fontSize: component.style?.fontSize || 40,
            fontFamily: component.style?.fontFamily || 'Arial',
            fontWeight: component.style?.fontWeight || 'normal',
            textTransform: component.style?.textTransform || 'none',
            ...animationStyleIn,
            ...animationStyleOut,
            ...(component.style?.outline?.enabled ? {
                textShadow: `
                    -${component.style.outline.width}px -${component.style.outline.width}px 0 ${component.style.outline.color},
                    ${component.style.outline.width}px -${component.style.outline.width}px 0 ${component.style.outline.color},
                    -${component.style.outline.width}px ${component.style.outline.width}px 0 ${component.style.outline.color},
                    ${component.style.outline.width}px ${component.style.outline.width}px 0 ${component.style.outline.color}
                `
            } : {})
        }}>
            {component.text}
        </div>
    );
};

const VoiceComponent: React.FC<{ component: VoiceComponentType }> = ({ component }) => {
    if (!component.audioUrl) {
        console.warn('VoiceComponent: No audio URL provided');
        return null;
    }

    // Calculate volume based on style settings
    const volume = component.style?.volume ?? 1;

    // Calculate start and end times if specified
    const startTime = component.style?.startTime ?? 0;
    const duration = component.style?.duration;

    return (
        <>
            <Audio
                src={component.audioUrl}
                volume={volume}
                startFrom={startTime}
                endAt={duration ? startTime + duration : undefined}
            />
            {component.showCaptions && component.wordTimings && (
                <CaptionRenderer
                    wordTimings={component.wordTimings}
                    style={component.captionStyle || {
                        fontSize: 24,
                        color: '#ffffff',
                        backgroundColor: 'rgba(0, 0, 0, 0.7)',
                        position: 'bottom',
                        wordWindow: 1
                    }}
                />
            )}
        </>
    );
};

const AudioEffectComponent: React.FC<{ component: AudioComponentType }> = ({ component }) => {
    if (!component.audioUrl) {
        console.warn('AudioEffectComponent: No audio URL provided');
        return null;
    }

    // Get audio settings from style
    const volume = component.style?.volume ?? 1;
    const startTime = component.style?.startTime ?? 0;
    const duration = component.style?.duration;
    const loop = component.style?.loop ?? false;

    // Handle both string URLs and audio object URLs
    const audioSrc = typeof component.audioUrl === 'string' 
        ? component.audioUrl 
        : component.audioUrl.url;

    return (
        <Audio
            src={audioSrc}
            volume={volume}
            startFrom={startTime}
            endAt={duration ? startTime + duration : undefined}
            loop={loop}
        />
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\TextComponent.tsx ---

import React from 'react';
import { useCurrentFrame, useVideoConfig } from 'remotion';
import { TextComponent as TextComponentType } from '../../types/script';
import { getAnimationStyle } from '../../utils/animation';

interface TextComponentProps {
    component: TextComponentType;
}

export const TextComponent: React.FC<TextComponentProps> = ({ component }) => {
    const frame = useCurrentFrame();
    const { fps } = useVideoConfig();

    const style = component.style || {};
    const animationStyle = getAnimationStyle(frame, fps, style.animation);

    return (
        <div
            style={{
                position: 'absolute',
                left: '50%',
                top: '50%',
                transform: `translate(-50%, -50%)`,
                fontSize: style.fontSize || 32,
                fontFamily: style.fontFamily || 'Arial',
                color: style.color || '#ffffff',
                textAlign: style.textAlign || 'center',
                fontWeight: style.fontWeight || 'normal',
                lineHeight: style.lineHeight || 1.5,
                backgroundColor: style.backgroundColor,
                padding: style.padding,
                borderRadius: style.borderRadius,
                ...animationStyle,
            }}
        >
            {component.text}
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\TextSequence.tsx ---

import React from 'react';
import { AbsoluteFill } from 'remotion';
import { TextComponent } from '../../types/script';

interface TextSequenceProps {
    component: TextComponent;
}

export const TextSequence: React.FC<TextSequenceProps> = ({ component }) => {
    const style = component.style || {};
    const position = style.position || { x: 0, y: 0 };

    // Format text based on wordsPerLine
    const formatText = (text: string) => {
        if (!text || !style.wordsPerLine || style.wordsPerLine <= 0) {
            return text;
        }

        // Remove existing line breaks and extra spaces
        const cleanText = text.replace(/[\n\r]+/g, ' ').replace(/\s+/g, ' ').trim();
        const words = cleanText.split(' ');
        const lines = [];
        
        // Group words into lines
        for (let i = 0; i < words.length; i += style.wordsPerLine) {
            const line = words.slice(i, i + style.wordsPerLine).join(' ');
            if (line) lines.push(line);
        }
        
        // Join lines with newlines
        return lines.join('\n');
    };

    // Create text shadow for outline effect
    const getTextShadow = () => {
        if (!style.outline?.enabled) return 'none';

        const width = style.outline.width || 2;
        const color = style.outline.color || '#000000';
        const shadows = [];

        // Generate outline effect using multiple text shadows
        for (let x = -width; x <= width; x++) {
            for (let y = -width; y <= width; y++) {
                if (Math.abs(x) === width || Math.abs(y) === width) {
                    shadows.push(`${x}px ${y}px 0 ${color}`);
                }
            }
        }

        return shadows.join(', ');
    };

    return (
        <AbsoluteFill>
            <div style={{
                position: 'absolute',
                left: position.x,
                top: position.y,
                fontSize: style.fontSize || 40,
                fontFamily: style.fontFamily || 'Arial',
                color: style.color || 'white',
                textAlign: style.textAlign || 'center',
                width: '100%',
                maxWidth: '80%',
                margin: '0 auto',
                transform: 'translate(0, 0)', // Prevent any transform issues
                whiteSpace: 'pre-wrap', // Preserve line breaks
                fontWeight: style.fontWeight || 'normal',
                lineHeight: style.lineHeight || 1.5,
                textShadow: getTextShadow(),
            }}>
                {formatText(component.text)}
            </div>
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\TikTokCaptions.tsx ---

import React from 'react';
import {
    AbsoluteFill,
    useCurrentFrame,
    useVideoConfig,
    spring,
    interpolate,
} from 'remotion';
import { TikTokPage } from '../../types/script';

interface TikTokCaptionsProps {
    pages: TikTokPage[];
    style?: {
        backgroundColor?: string;
        textColor?: string;
        position?: 'top' | 'bottom' | 'middle';
    };
}

export const TikTokCaptions: React.FC<TikTokCaptionsProps> = ({
    pages,
    style = {},
}) => {
    const frame = useCurrentFrame();
    const { fps } = useVideoConfig();
    const currentTimeMs = (frame / fps) * 1000;

    const currentPage = pages.find((page, index) => {
        const nextPage = pages[index + 1];
        return (
            currentTimeMs >= page.startMs &&
            (!nextPage || currentTimeMs < nextPage.startMs)
        );
    });

    if (!currentPage) return null;

    const pageProgress = spring({
        frame,
        fps,
        config: {
            damping: 200,
        },
    });

    const getTokenOpacity = (token: TikTokPage['tokens'][0]) => {
        return interpolate(
            currentTimeMs,
            [token.fromMs, token.fromMs + 100, token.toMs - 100, token.toMs],
            [0, 1, 1, 0],
            {
                extrapolateLeft: 'clamp',
                extrapolateRight: 'clamp',
            }
        );
    };

    return (
        <AbsoluteFill
            style={{
                justifyContent: style.position === 'top' ? 'flex-start' : 
                    style.position === 'bottom' ? 'flex-end' : 'center',
                padding: '40px',
            }}
        >
            <div
                style={{
                    backgroundColor: style.backgroundColor || 'rgba(0, 0, 0, 0.8)',
                    color: style.textColor || 'white',
                    padding: '20px',
                    borderRadius: '12px',
                    fontSize: '32px',
                    fontWeight: 'bold',
                    textAlign: 'center',
                    opacity: pageProgress,
                    whiteSpace: 'pre',
                    display: 'inline-block',
                    margin: '0 auto',
                }}
            >
                {currentPage.tokens.map((token, i) => (
                    <span
                        key={i}
                        style={{
                            opacity: getTokenOpacity(token),
                            display: 'inline-block',
                        }}
                    >
                        {token.text}
                    </span>
                ))}
            </div>
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\TitleSequence.tsx ---

import React from 'react';
import { AbsoluteFill } from 'remotion';
import { TitleComponent } from '../../types/script';

interface TitleSequenceProps {
    component: TitleComponent;
}

export const TitleSequence: React.FC<TitleSequenceProps> = ({ component }) => {
    const style = component.style || {};
    const position = style.position || { x: 0, y: 0 };

    return (
        <AbsoluteFill>
            <div style={{
                position: 'absolute',
                left: position.x,
                top: position.y,
                fontSize: style.fontSize || 60,
                fontFamily: style.fontFamily || 'Arial',
                color: style.color || 'white',
                textAlign: style.textAlign || 'center',
                width: style.position?.width || 300,
                fontWeight: 'bold',
                transform: 'translate(0, 0)', // Prevent any transform issues
            }}>
                {component.text}
            </div>
        </AbsoluteFill>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\TransitionSequence.tsx ---

import React from 'react';
import { AbsoluteFill } from 'remotion';
import { TransitionComponent } from '../../types/script';

interface TransitionSequenceProps {
    component: TransitionComponent;
}

export const TransitionSequence: React.FC<TransitionSequenceProps> = ({ component }) => {
    return (
        <AbsoluteFill style={{
            backgroundColor: 'black',
        }} />
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\VideoComponent.tsx ---

import React, { useEffect, useRef, useState } from 'react';
import { useCurrentFrame, useVideoConfig } from 'remotion';
import { VideoComponent as VideoComponentType } from '../../types/script';
import { getAnimationStyle } from '../../utils/animation';

interface VideoComponentProps {
    component: VideoComponentType;
}

export const VideoComponent: React.FC<VideoComponentProps> = ({ component }) => {
    const frame = useCurrentFrame();
    const { fps } = useVideoConfig();
    const videoRef = useRef<HTMLVideoElement>(null);
    const canvasRef = useRef<HTMLCanvasElement>(null);
    const animationFrameRef = useRef<number | undefined>(undefined);
    const [proxyUrl, setProxyUrl] = useState<string | null>(null);
    const [videoLoaded, setVideoLoaded] = useState(false);
    const [videoDuration, setVideoDuration] = useState(0);

    const style = component.style || {};
    const animationStyle = getAnimationStyle(frame, fps, style.animation);

    // Calculate current video time based on frame
    const videoTime = (frame / fps) + (style.startTime || 0);

    useEffect(() => {
        const proxyVideo = async () => {
            try {
                console.log('Proxying video:', component.videoUrl);
                const response = await fetch('http://localhost:3005/proxy_video', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ url: component.videoUrl }),
                });

                if (!response.ok) {
                    throw new Error('Failed to proxy video');
                }

                const data = await response.json();
                console.log('Received proxy URL:', data.url);
                setProxyUrl(data.url);
            } catch (error) {
                console.error('Error proxying video:', error);
            }
        };

        if (component.videoUrl) {
            proxyVideo();
        }

        return () => {
            setProxyUrl(null);
            setVideoLoaded(false);
        };
    }, [component.videoUrl]);

    // Sync video time with timeline
    useEffect(() => {
        const video = videoRef.current;
        if (!video || !videoLoaded) return;

        // Update video time
        if (Math.abs(video.currentTime - videoTime) > 0.1) {
            video.currentTime = videoTime;
        }

        // Update component duration when video metadata is loaded
        if (videoDuration === 0 && video.duration) {
            setVideoDuration(video.duration);
            // If this is a new video, update the component's duration
            if (!component.style?.duration) {
                const durationInFrames = Math.ceil(video.duration * fps);
                // You'll need to implement this update function in your state management
                // updateComponentDuration(component.id, durationInFrames);
            }
        }
    }, [frame, fps, videoLoaded, videoTime, videoDuration]);

    useEffect(() => {
        if (!videoRef.current || !canvasRef.current || !style.chromakey?.enabled || !proxyUrl || !videoLoaded) {
            console.log('Skipping chromakey setup. Conditions:', {
                hasVideoRef: !!videoRef.current,
                hasCanvasRef: !!canvasRef.current,
                chromakeyEnabled: style.chromakey?.enabled,
                hasProxyUrl: !!proxyUrl,
                videoLoaded
            });
            return;
        }

        console.log('Setting up chromakey effect with settings:', style.chromakey);

        const video = videoRef.current;
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        if (!ctx) {
            console.error('Failed to get canvas context');
            return;
        }

        const updateCanvasSize = () => {
            const newWidth = video.videoWidth || video.clientWidth;
            const newHeight = video.videoHeight || video.clientHeight;
            console.log('Updating canvas size:', { width: newWidth, height: newHeight });
            canvas.width = newWidth;
            canvas.height = newHeight;
        };

        const processFrame = () => {
            try {
                // Only process frame if video is at the correct time
                if (Math.abs(video.currentTime - videoTime) <= 0.1) {
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    
                    if (style.chromakey?.enabled) {
                        try {
                            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            const data = imageData.data;

                            const keyColor = style.chromakey.color || '#00ff00';
                            const r = parseInt(keyColor.slice(1, 3), 16);
                            const g = parseInt(keyColor.slice(3, 5), 16);
                            const b = parseInt(keyColor.slice(5, 7), 16);

                            const similarity = (style.chromakey.similarity || 0.4) * 255;
                            const smoothness = style.chromakey.smoothness || 0.1;

                            for (let i = 0; i < data.length; i += 4) {
                                const pixelR = data[i];
                                const pixelG = data[i + 1];
                                const pixelB = data[i + 2];

                                const diff = Math.sqrt(
                                    Math.pow(pixelR - r, 2) * 0.3 +
                                    Math.pow(pixelG - g, 2) * 0.59 +
                                    Math.pow(pixelB - b, 2) * 0.11
                                );

                                if (diff < similarity) {
                                    const alpha = Math.max(0, diff / (similarity * smoothness));
                                    data[i + 3] = Math.min(255, alpha * 255);
                                }
                            }

                            ctx.putImageData(imageData, 0, 0);
                        } catch (error) {
                            console.error('Error processing chromakey:', error);
                        }
                    }
                }

                // Request next frame
                animationFrameRef.current = requestAnimationFrame(processFrame);
            } catch (error) {
                console.error('Error processing frame:', error);
            }
        };

        updateCanvasSize();
        processFrame();

        return () => {
            if (animationFrameRef.current) {
                cancelAnimationFrame(animationFrameRef.current);
            }
        };
    }, [style.chromakey, proxyUrl, videoLoaded, videoTime]);

    const containerStyle: React.CSSProperties = {
        position: 'absolute',
        width: `${style.width || 100}%`,
        height: `${style.height || 100}%`,
        left: `${style.position?.x || 0}%`,
        top: `${style.position?.y || 0}%`,
        transform: `translate(-50%, -50%) scale(${style.scale || 1}) rotate(${style.rotation || 0}deg)`,
        opacity: style.opacity ?? 1,
        ...animationStyle,
    };

    if (!proxyUrl) {
        return <div style={containerStyle}>Loading video...</div>;
    }

    if (style.chromakey?.enabled) {
        return (
            <div style={containerStyle}>
                <video
                    ref={videoRef}
                    src={proxyUrl}
                    style={{ display: 'none' }}
                    autoPlay={false}
                    loop={false}
                    muted
                    playsInline
                    crossOrigin="anonymous"
                    onLoadedData={() => {
                        console.log('Video loaded');
                        setVideoLoaded(true);
                    }}
                />
                <canvas
                    ref={canvasRef}
                    style={{
                        width: '100%',
                        height: '100%',
                        objectFit: 'contain',
                    }}
                />
            </div>
        );
    }

    return (
        <div style={containerStyle}>
            <video
                ref={videoRef}
                src={proxyUrl}
                style={{
                    width: '100%',
                    height: '100%',
                    objectFit: 'contain',
                }}
                autoPlay={false}
                loop={false}
                muted
                playsInline
                crossOrigin="anonymous"
                onLoadedData={() => setVideoLoaded(true)}
            />
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\Video\VideoPositioningScreen.tsx ---

import React from 'react';
import { VideoComponent } from '../../types/script';
import { theme } from '../../styles/theme';

interface VideoPositioningScreenProps {
    component: VideoComponent;
    onChange: (component: VideoComponent) => void;
}

export const VideoPositioningScreen: React.FC<VideoPositioningScreenProps> = ({ component, onChange }) => {
    const handlePositionChange = (x: number, y: number) => {
        onChange({
            ...component,
            style: {
                ...component.style,
                position: { x, y }
            }
        });
    };

    const handleSizeChange = (width: number, height: number) => {
        onChange({
            ...component,
            style: {
                ...component.style,
                width,
                height
            }
        });
    };

    const handleTimeChange = (startTime: number, duration: number) => {
        onChange({
            ...component,
            style: {
                ...component.style,
                startTime,
                duration
            }
        });
    };

    return (
        <div style={styles.container}>
            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Position</h3>
                <div style={styles.inputGroup}>
                    <label style={styles.label}>X Position (%)</label>
                    <input
                        type="number"
                        value={component.style?.position?.x || 0}
                        onChange={(e) => handlePositionChange(Number(e.target.value), component.style?.position?.y || 0)}
                        style={styles.input}
                        min={-100}
                        max={100}
                        step={1}
                    />
                </div>
                <div style={styles.inputGroup}>
                    <label style={styles.label}>Y Position (%)</label>
                    <input
                        type="number"
                        value={component.style?.position?.y || 0}
                        onChange={(e) => handlePositionChange(component.style?.position?.x || 0, Number(e.target.value))}
                        style={styles.input}
                        min={-100}
                        max={100}
                        step={1}
                    />
                </div>
            </div>

            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Size</h3>
                <div style={styles.inputGroup}>
                    <label style={styles.label}>Width (%)</label>
                    <input
                        type="number"
                        value={component.style?.width || 100}
                        onChange={(e) => handleSizeChange(Number(e.target.value), component.style?.height || 100)}
                        style={styles.input}
                        min={1}
                        max={500}
                        step={1}
                    />
                </div>
                <div style={styles.inputGroup}>
                    <label style={styles.label}>Height (%)</label>
                    <input
                        type="number"
                        value={component.style?.height || 100}
                        onChange={(e) => handleSizeChange(component.style?.width || 100, Number(e.target.value))}
                        style={styles.input}
                        min={1}
                        max={500}
                        step={1}
                    />
                </div>
            </div>

            <div style={styles.section}>
                <h3 style={styles.sectionTitle}>Time Control</h3>
                <div style={styles.inputGroup}>
                    <label style={styles.label}>Start Time (seconds)</label>
                    <input
                        type="number"
                        value={component.style?.startTime || 0}
                        onChange={(e) => handleTimeChange(Number(e.target.value), component.style?.duration || 0)}
                        style={styles.input}
                        min={0}
                        step={0.1}
                    />
                </div>
                <div style={styles.inputGroup}>
                    <label style={styles.label}>Duration (seconds)</label>
                    <input
                        type="number"
                        value={component.style?.duration || 0}
                        onChange={(e) => handleTimeChange(component.style?.startTime || 0, Number(e.target.value))}
                        style={styles.input}
                        min={0.1}
                        step={0.1}
                    />
                </div>
            </div>
        </div>
    );
};

const styles = {
    container: {
        padding: '1rem',
        backgroundColor: theme.backgroundLight,
        borderRadius: '8px',
        display: 'flex',
        flexDirection: 'column' as const,
        gap: '1rem',
    },
    section: {
        display: 'flex',
        flexDirection: 'column' as const,
        gap: '0.5rem',
    },
    sectionTitle: {
        margin: 0,
        color: theme.textPrimary,
        fontSize: '1rem',
        fontWeight: 600,
    },
    inputGroup: {
        display: 'flex',
        alignItems: 'center',
        gap: '0.5rem',
    },
    label: {
        color: theme.textSecondary,
        fontSize: '0.9rem',
        minWidth: '120px',
    },
    input: {
        padding: '0.25rem 0.5rem',
        borderRadius: '4px',
        border: `1px solid ${theme.borderColor}`,
        backgroundColor: theme.backgroundDark,
        color: theme.textPrimary,
        width: '80px',
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\common\ColorPicker.tsx ---

import React from 'react';
import { theme } from '../../styles/theme';

interface ColorPickerProps {
    label: string;
    color: string;
    onChange: (color: string) => void;
}

export const ColorPicker: React.FC<ColorPickerProps> = ({
    label,
    color,
    onChange,
}) => {
    return (
        <div style={styles.container}>
            <label style={styles.label}>{label}</label>
            <div style={styles.inputContainer}>
                <input
                    type="color"
                    value={color}
                    onChange={(e) => onChange(e.target.value)}
                    style={styles.colorInput}
                />
                <input
                    type="text"
                    value={color}
                    onChange={(e) => onChange(e.target.value)}
                    style={styles.textInput}
                />
            </div>
        </div>
    );
};

const styles = {
    container: {
        marginBottom: theme.spacing.sm,
    },
    label: {
        display: 'block',
        marginBottom: theme.spacing.xs,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
    },
    inputContainer: {
        display: 'flex',
        gap: theme.spacing.sm,
        alignItems: 'center',
    },
    colorInput: {
        width: '40px',
        height: '40px',
        padding: 0,
        border: `1px solid ${theme.colors.border}`,
        borderRadius: theme.borderRadius.sm,
        cursor: 'pointer',
    },
    textInput: {
        flex: 1,
        padding: theme.spacing.sm,
        backgroundColor: theme.colors.background.tertiary,
        border: `1px solid ${theme.colors.border}`,
        borderRadius: theme.borderRadius.sm,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\common\IconButton.tsx ---

import React, { useState } from 'react';
import { theme } from '../../styles/theme';

interface IconButtonProps {
    icon: string;
    onClick: () => void;
    tooltip?: string;
    disabled?: boolean;
    size?: 'sm' | 'md' | 'lg';
    variant?: 'primary' | 'secondary' | 'ghost';
}

export const IconButton: React.FC<IconButtonProps> = ({
    icon,
    onClick,
    tooltip,
    disabled = false,
    size = 'md',
    variant = 'ghost',
}) => {
    const [isHovered, setIsHovered] = useState(false);

    const sizeMap = {
        sm: {
            padding: theme.spacing.xs,
            fontSize: theme.fontSizes.sm,
        },
        md: {
            padding: theme.spacing.sm,
            fontSize: theme.fontSizes.md,
        },
        lg: {
            padding: theme.spacing.md,
            fontSize: theme.fontSizes.lg,
        },
    };

    const variantMap = {
        primary: {
            backgroundColor: theme.colors.primary,
            color: theme.colors.text.primary,
            hoverBg: theme.colors.accent.red,
        },
        secondary: {
            backgroundColor: theme.colors.background.tertiary,
            color: theme.colors.text.primary,
            hoverBg: theme.colors.background.secondary,
        },
        ghost: {
            backgroundColor: 'transparent',
            color: theme.colors.text.primary,
            hoverBg: theme.colors.background.tertiary,
        },
    };

    const currentVariant = variantMap[variant];

    return (
        <button
            onClick={onClick}
            disabled={disabled}
            title={tooltip}
            onMouseEnter={() => setIsHovered(true)}
            onMouseLeave={() => setIsHovered(false)}
            style={{
                border: 'none',
                borderRadius: theme.borderRadius.md,
                cursor: disabled ? 'not-allowed' : 'pointer',
                opacity: disabled ? 0.5 : 1,
                transition: theme.transitions.fast,
                backgroundColor: isHovered && !disabled ? currentVariant.hoverBg : currentVariant.backgroundColor,
                color: currentVariant.color,
                ...sizeMap[size],
                display: 'inline-flex',
                alignItems: 'center',
                justifyContent: 'center',
                minWidth: sizeMap[size].fontSize,
                minHeight: sizeMap[size].fontSize,
                padding: sizeMap[size].padding,
                outline: 'none',
                boxShadow: isHovered && !disabled ? theme.shadows.sm : 'none',
            }}
        >
            {icon}
        </button>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\common\Modal.tsx ---

import React from 'react';
import { theme } from '../../styles/theme';

interface ModalProps {
    isOpen: boolean;
    onClose: () => void;
    title: React.ReactNode;
    children: React.ReactNode;
}

export const Modal: React.FC<ModalProps> = ({ isOpen, onClose, title, children }) => {
    if (!isOpen) return null;

    return (
        <div style={{
            position: 'fixed',
            top: '48px', // Header height
            left: 0,
            width: '75%', // Match the timeline section width
            height: 'calc(100vh - 48px)',
            backgroundColor: 'rgba(0, 0, 0, 0.75)',
            display: 'flex',
            justifyContent: 'flex-start',
            alignItems: 'center',
            zIndex: 1000,
            backdropFilter: 'blur(4px)',
            padding: theme.spacing.xl,
        }}>
            <div style={{
                backgroundColor: theme.colors.background.primary,
                borderRadius: theme.borderRadius.lg,
                border: `1px solid ${theme.colors.border}`,
                boxShadow: '0 8px 32px rgba(0, 0, 0, 0.4)',
                width: '90%',
                maxWidth: '800px',
                maxHeight: '90vh',
                display: 'flex',
                flexDirection: 'column',
                overflow: 'hidden',
                marginLeft: theme.spacing.xl,
            }}>
                {/* Header */}
                <div style={{
                    padding: theme.spacing.lg,
                    borderBottom: `1px solid ${theme.colors.border}`,
                    backgroundColor: theme.colors.background.secondary,
                    position: 'relative',
                }}>
                    <button
                        onClick={onClose}
                        style={{
                            position: 'absolute',
                            top: '50%',
                            right: theme.spacing.md,
                            transform: 'translateY(-50%)',
                            background: 'none',
                            border: 'none',
                            color: theme.colors.text.secondary,
                            fontSize: '24px',
                            cursor: 'pointer',
                            width: '32px',
                            height: '32px',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            borderRadius: theme.borderRadius.sm,
                            transition: 'all 0.2s ease',
                        }}
                        onMouseEnter={(e) => {
                            e.currentTarget.style.backgroundColor = theme.colors.background.tertiary;
                            e.currentTarget.style.color = theme.colors.text.primary;
                        }}
                        onMouseLeave={(e) => {
                            e.currentTarget.style.backgroundColor = 'transparent';
                            e.currentTarget.style.color = theme.colors.text.secondary;
                        }}
                    >
                        √ó
                    </button>
                    <div style={{ paddingRight: '32px' }}>
                        {title}
                    </div>
                </div>

                {/* Content */}
                <div style={{
                    flex: 1,
                    overflow: 'auto',
                    padding: theme.spacing.lg,
                }}>
                    {children}
                </div>
            </div>
        </div>
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\common\Slider.tsx ---

import React from 'react';
import { theme } from '../../styles/theme';

interface SliderProps {
    label: string;
    value: number;
    onChange: (value: number) => void;
    min: number;
    max: number;
    step?: number;
}

export const Slider: React.FC<SliderProps> = ({
    label,
    value,
    onChange,
    min,
    max,
    step = 1,
}) => {
    return (
        <div style={styles.container}>
            <div style={styles.header}>
                <label style={styles.label}>{label}</label>
                <input
                    type="number"
                    value={value}
                    onChange={(e) => onChange(Number(e.target.value))}
                    min={min}
                    max={max}
                    step={step}
                    style={styles.numberInput}
                />
            </div>
            <input
                type="range"
                value={value}
                onChange={(e) => onChange(Number(e.target.value))}
                min={min}
                max={max}
                step={step}
                style={styles.slider}
            />
        </div>
    );
};

const styles = {
    container: {
        marginBottom: theme.spacing.sm,
    },
    header: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: theme.spacing.xs,
    },
    label: {
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
    },
    numberInput: {
        width: '60px',
        padding: theme.spacing.xs,
        backgroundColor: theme.colors.background.tertiary,
        border: `1px solid ${theme.colors.border}`,
        borderRadius: theme.borderRadius.sm,
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
        textAlign: 'right' as const,
    },
    slider: {
        width: '100%',
        height: '2px',
        WebkitAppearance: 'none',
        background: theme.colors.primary,
        outline: 'none',
        opacity: 0.7,
        transition: 'opacity 0.2s',
        cursor: 'pointer',
        '&:hover': {
            opacity: 1,
        },
        '&::-webkit-slider-thumb': {
            WebkitAppearance: 'none',
            appearance: 'none',
            width: '16px',
            height: '16px',
            background: theme.colors.primary,
            borderRadius: '50%',
            cursor: 'pointer',
        },
        '&::-moz-range-thumb': {
            width: '16px',
            height: '16px',
            background: theme.colors.primary,
            borderRadius: '50%',
            cursor: 'pointer',
        },
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\components\common\Switch.tsx ---

import React from 'react';
import { theme } from '../../styles/theme';

interface SwitchProps {
    label: string;
    checked: boolean;
    onChange: (checked: boolean) => void;
}

export const Switch: React.FC<SwitchProps> = ({
    label,
    checked,
    onChange,
}) => {
    return (
        <div style={styles.container}>
            <label style={styles.label}>
                <input
                    type="checkbox"
                    checked={checked}
                    onChange={(e) => onChange(e.target.checked)}
                    style={styles.input}
                />
                <span style={styles.switch}>
                    <span style={{
                        ...styles.slider,
                        transform: checked ? 'translateX(20px)' : 'translateX(0)',
                        backgroundColor: checked ? theme.colors.primary : theme.colors.background.tertiary,
                    }} />
                </span>
                <span style={styles.text}>{label}</span>
            </label>
        </div>
    );
};

const styles = {
    container: {
        marginBottom: theme.spacing.sm,
    },
    label: {
        display: 'flex',
        alignItems: 'center',
        cursor: 'pointer',
        userSelect: 'none' as const,
    },
    input: {
        display: 'none',
    },
    switch: {
        position: 'relative' as const,
        display: 'inline-block',
        width: '40px',
        height: '20px',
        backgroundColor: theme.colors.background.secondary,
        borderRadius: '10px',
        marginRight: theme.spacing.sm,
    },
    slider: {
        position: 'absolute' as const,
        top: '2px',
        left: '2px',
        width: '16px',
        height: '16px',
        borderRadius: '50%',
        transition: 'transform 0.2s, background-color 0.2s',
    },
    text: {
        color: theme.colors.text.primary,
        fontSize: theme.fontSizes.sm,
    },
}; 



--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\data\quizData.ts ---

import { Photo } from 'pexels';

export interface QuizItem {
	question: string;
	leftOption: {
		image: string;
		text: string;
		pexelsPhoto?: Photo;
	};
	rightOption: {
		image: string;
		text: string;
		pexelsPhoto?: Photo;
	};
	voiceover: string;
}

export const QUIZ_DATA: QuizItem[] = [
	{
		question: 'Coffee or Tea?',
		leftOption: {
			image: '',
			text: 'Coffee',
		},
		rightOption: {
			image: '',
			text: 'Tea',
		},
		voiceover: 'Coffee or Tea?',
	},
	// Add more comparison items here
]; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\font_service.py ---

from flask import Flask, send_file, jsonify, request
from flask_cors import CORS
import os
import json
from werkzeug.utils import secure_filename

app = Flask(__name__)
CORS(app, resources={
    r"/*": {
        "origins": ["http://localhost:3000", "http://localhost:3001"],
        "methods": ["GET", "POST", "OPTIONS"],
        "allow_headers": ["Content-Type"]
    }
})

# Ensure fonts directory exists
FONTS_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'public', 'fonts')
os.makedirs(FONTS_DIR, exist_ok=True)

# Load or create font dictionary
FONT_DICT_FILE = os.path.join(FONTS_DIR, 'font_dictionary.json')

def load_font_dictionary():
    if os.path.exists(FONT_DICT_FILE):
        try:
            with open(FONT_DICT_FILE, 'r') as f:
                return json.load(f)
        except:
            return {}
    return {}

def save_font_dictionary(font_dict):
    with open(FONT_DICT_FILE, 'w') as f:
        json.dump(font_dict, f, indent=2)

# Initialize font dictionary
font_dictionary = load_font_dictionary()

@app.route('/fonts/<path:filename>')
def serve_font(filename):
    return send_file(os.path.join(FONTS_DIR, filename))

@app.route('/fonts/dictionary', methods=['GET'])
def get_font_dictionary():
    print("Serving font dictionary:", font_dictionary)
    return jsonify(font_dictionary)

@app.route('/set_font', methods=['POST'])
def set_font():
    try:
        print("Received font upload request")
        if 'file' not in request.files:
            return jsonify({'error': 'No file provided'}), 400
        
        file = request.files['file']
        if file.filename == '':
            return jsonify({'error': 'No file selected'}), 400

        if not file.filename.lower().endswith(('.otf', '.ttf')):
            return jsonify({'error': 'Invalid file type. Only .otf and .ttf files are allowed'}), 400

        filename = secure_filename(file.filename)
        filepath = os.path.join(FONTS_DIR, filename)
        file.save(filepath)
        print(f"Saved font to: {filepath}")

        # Update font dictionary
        font_name = os.path.splitext(filename)[0]
        font_url = f'http://localhost:3003/fonts/{filename}'
        font_dictionary[font_name] = {
            'url': font_url,
            'path': filepath,
            'format': 'opentype' if filename.lower().endswith('.otf') else 'truetype'
        }
        save_font_dictionary(font_dictionary)
        print(f"Updated font dictionary with: {font_name}")

        return jsonify({
            'success': True,
            'message': 'Font uploaded',
            'url': font_url,
            'name': font_name
        })
    except Exception as e:
        print(f"Error uploading font: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/delete_font', methods=['POST'])
def delete_font():
    try:
        data = request.json
        if not data or 'name' not in data:
            return jsonify({'error': 'Font name not provided'}), 400

        font_name = data['name']
        if font_name not in font_dictionary:
            return jsonify({'error': 'Font not found'}), 404

        # Delete the font file
        font_path = font_dictionary[font_name]['path']
        if os.path.exists(font_path):
            os.remove(font_path)

        # Remove from dictionary
        del font_dictionary[font_name]
        save_font_dictionary(font_dictionary)

        return jsonify({
            'success': True,
            'message': 'Font deleted'
        })
    except Exception as e:
        print(f"Error deleting font: {e}")
        return jsonify({'error': str(e)}), 500

if __name__ == '__main__':
    print("Starting font service on port 3003...")
    print(f"Fonts directory: {FONTS_DIR}")
    print(f"Font dictionary: {font_dictionary}")
    app.run(port=3003, debug=True) 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\index.ts ---

import { registerRoot } from "remotion";
import "./styles/globals.css";
import { RemotionRoot } from "./Root";

registerRoot(RemotionRoot);



--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\pages\_app.tsx ---

import type { AppProps } from 'next/app';
import '../styles/globals.css';

export default function App({ Component, pageProps }: AppProps) {
  return <Component {...pageProps} />;
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\pages\api\copy-background.ts ---

import { NextApiRequest, NextApiResponse } from 'next';
import fs from 'fs';
import path from 'path';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
    if (req.method !== 'POST') {
        return res.status(405).json({ message: 'Method not allowed' });
    }

    try {
        const { name, data } = req.body;
        
        // Extract base64 data
        const base64Data = data.split(';base64,').pop();
        const buffer = Buffer.from(base64Data, 'base64');

        // Define all possible paths where we might need the file
        const paths = [
            path.join(process.cwd(), 'public', 'backgrounds'), // Next.js public
            path.join(process.cwd(), '..', 'public', 'backgrounds'), // One level up
            path.join(process.cwd(), 'backgrounds'), // Root level
            path.join(process.cwd(), '..', 'backgrounds'), // One level up root
        ];

        // Create directories and save file in all locations
        const savedPaths = [];
        for (const dir of paths) {
            try {
                if (!fs.existsSync(dir)) {
                    fs.mkdirSync(dir, { recursive: true });
                }
                const filePath = path.join(dir, name);
                fs.writeFileSync(filePath, buffer);
                savedPaths.push(filePath);
            } catch (err) {
                console.error(`Failed to save to ${dir}:`, err);
            }
        }

        // Verify files were saved
        const verification = savedPaths.map(p => ({
            path: p,
            exists: fs.existsSync(p),
            size: fs.existsSync(p) ? fs.statSync(p).size : 0
        }));

        console.log('File save verification:', verification);

        if (verification.some(v => v.exists)) {
            res.status(200).json({ 
                message: 'File copied successfully',
                verification 
            });
        } else {
            throw new Error('Failed to save file in any location');
        }
    } catch (error) {
        console.error('Error copying file:', error);
        res.status(500).json({ message: 'Failed to copy file' });
    }
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\pages\api\get-path.ts ---

import { NextApiRequest, NextApiResponse } from 'next';
import fs from 'fs';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
    if (req.method !== 'GET') {
        return res.status(405).json({ error: 'Method not allowed' });
    }

    try {
        // Read from the exact location specified
        const filePath = 'D:\\Projects\\Remotion Couples Quiz\\path.txt';
        const backgroundPath = fs.readFileSync(filePath, 'utf8');
        
        console.log('Read background path:', backgroundPath);
        
        // Return the path as plain text
        res.setHeader('Content-Type', 'text/plain');
        return res.status(200).send(backgroundPath);
    } catch (error) {
        console.error('Error reading path:', error);
        return res.status(500).json({ error: 'Failed to read path' });
    }
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\pages\api\save-path.ts ---

import { NextApiRequest, NextApiResponse } from 'next';
import fs from 'fs';
import path from 'path';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
    if (req.method !== 'POST') {
        return res.status(405).json({ error: 'Method not allowed' });
    }

    try {
        const { selectedPath } = req.body;
        if (!selectedPath) {
            return res.status(400).json({ error: 'No path provided' });
        }

        // Write to the exact location specified
        const filePath = 'D:\\Projects\\Remotion Couples Quiz\\path.txt';
        
        // Write the path to the file
        fs.writeFileSync(filePath, selectedPath, 'utf8');
        
        console.log('Saved path to:', filePath);
        console.log('Path content:', selectedPath);

        return res.status(200).json({ success: true });
    } catch (error) {
        console.error('Error saving path:', error);
        return res.status(500).json({ error: 'Failed to save path' });
    }
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\pages\index.tsx ---

import React, { useState } from 'react';
import { Player } from '@remotion/player';
import { AppLayout } from '../components/Layout/AppLayout';
import { ComponentPalette } from '../components/ScriptEditor/ComponentPalette';
import { Script, ComponentType } from '../types/script';
import { ScriptVideo } from '../components/Video/ScriptVideo';
import { theme } from '../styles/theme';

export default function Home() {
    const [script, setScript] = useState<Script>({
        id: Date.now().toString(),
        title: 'New Quiz',
        components: [],
        captionTracks: [],
        settings: {
            defaultTextStyle: {
                fontSize: 40,
                color: 'white',
                fontFamily: 'Arial',
                textAlign: 'center',
            },
            defaultCaptionStyle: {
                fontSize: 24,
                color: 'white',
                fontFamily: 'Arial',
                textAlign: 'center',
            },
            background: {
                type: 'none',
            },
        },
    });

    const handleDragStart = (type: ComponentType) => {
        // Handle component drag start
        console.log('Dragging component:', type);
    };

    return (
        <AppLayout>
            {/* Left Sidebar Content */}
            <div style={{
                display: 'flex',
                flexDirection: 'column',
                gap: theme.spacing.lg,
            }}>
                <ComponentPalette onDragStart={handleDragStart} />
            </div>

            {/* Center Content */}
            <div style={{
                display: 'flex',
                flexDirection: 'column',
                gap: theme.spacing.lg,
            }}>
                {/* Preview */}
                <div style={{
                    flex: 1,
                    position: 'relative',
                    backgroundColor: theme.colors.background.tertiary,
                    borderRadius: theme.borderRadius.lg,
                    overflow: 'hidden',
                    padding: theme.spacing.lg,
                }}>
                    <div style={{
                        position: 'relative',
                        width: '100%',
                        height: '100%',
                        backgroundColor: '#000',
                        borderRadius: theme.borderRadius.md,
                        overflow: 'hidden',
                    }}>
                        <Player
                            component={ScriptVideo}
                            durationInFrames={300}
                            fps={30}
                            compositionWidth={1080}
                            compositionHeight={1920}
                            style={{
                                width: '100%',
                                height: '100%',
                            }}
                            controls
                            autoPlay
                            loop
                            inputProps={{
                                script,
                            }}
                        />
                    </div>
                </div>

                {/* Timeline */}
                <div style={{
                    height: '200px',
                    backgroundColor: theme.colors.background.secondary,
                    borderRadius: theme.borderRadius.lg,
                    padding: theme.spacing.lg,
                    border: `1px solid ${theme.colors.border}`,
                }}>
                    <h2 style={{
                        color: theme.colors.text.primary,
                        marginBottom: theme.spacing.md,
                        fontSize: '18px',
                    }}>Timeline</h2>
                    {/* Timeline content will go here */}
                </div>
            </div>

            {/* Right Sidebar Content */}
            <div style={{
                backgroundColor: theme.colors.background.secondary,
                borderRadius: theme.borderRadius.lg,
                padding: theme.spacing.lg,
                border: `1px solid ${theme.colors.border}`,
            }}>
                <h2 style={{
                    color: theme.colors.text.primary,
                    marginBottom: theme.spacing.md,
                    fontSize: '18px',
                }}>Properties</h2>
                {/* Properties panel content will go here */}
            </div>
        </AppLayout>
    );
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\preview-entry.ts ---

import { registerRoot } from 'remotion';
import { Preview } from './Preview';

// Register the Preview component as the root
registerRoot(Preview); 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\preview-entry.tsx ---

import React from 'react';
import { registerRoot } from 'remotion';
import { Composition } from 'remotion';
import { ScriptVideo } from './components/Video/ScriptVideo';
import { Script } from './types/script';

// Preview component that uses the background path
const Preview: React.FC = () => {
  // Get script from URL params
  const params = new URLSearchParams(window.location.search);
  const propsParam = params.get('props');
  let script: Script | undefined;
  
  try {
    if (propsParam) {
      script = JSON.parse(decodeURIComponent(propsParam));
    }
  } catch (e) {
    console.error('Failed to parse script from URL:', e);
  }

  // Fallback script if none provided
  const defaultScript: Script = {
    id: 'default',
    title: 'Default Script',
    components: [],
    captionTracks: [],
    settings: {
      defaultTextStyle: {
        fontSize: 40,
        color: 'white',
        fontFamily: 'Arial',
        textAlign: 'center'
      },
      defaultCaptionStyle: {
        fontSize: 24,
        color: 'white',
        fontFamily: 'Arial',
        textAlign: 'center'
      },
      background: {
        type: 'none'
      }
    }
  };

  return (
    <Composition
      id="ScriptVideo"
      component={ScriptVideo}
      durationInFrames={300}
      fps={30}
      width={1080}
      height={1920}
      defaultProps={{
        script: script || defaultScript
      }}
    />
  );
};

registerRoot(Preview); 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\public\fonts\font_dictionary.json ---

{
  "tiktok": {
    "url": "http://localhost:3003/fonts/tiktok.otf",
    "path": "D:\\Projects\\Remotion Couples Quiz\\my-video\\src\\public\\fonts\\tiktok.otf",
    "format": "opentype"
  }
}


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\remotion\VideoRoot.tsx ---

import React from 'react';
import { Composition } from 'remotion';
import { ScriptVideo } from '../components/Video/ScriptVideo';

export const VideoRoot: React.FC = () => {
    return (
        <Composition
            id="ScriptVideo"
            component={ScriptVideo}
            durationInFrames={1800}
            fps={30}
            width={1080}
            height={1920}
            defaultProps={{
                script: {
                    id: '',
                    title: '',
                    components: [],
                    captionTracks: [],
                    settings: {
                        defaultTextStyle: {
                            fontSize: 40,
                            color: 'white',
                            fontFamily: 'Arial',
                            textAlign: 'center'
                        },
                        defaultCaptionStyle: {
                            fontSize: 24,
                            color: 'white',
                            fontFamily: 'Arial',
                            textAlign: 'center'
                        },
                        background: {
                            type: 'none'
                        }
                    }
                }
            }}
        />
    );
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\remotion\index.ts ---

import { registerRoot } from 'remotion';
import { VideoRoot } from './VideoRoot';

registerRoot(VideoRoot); 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\render.mjs ---

import { bundle } from '@remotion/bundler';
import { renderMedia, selectComposition } from '@remotion/renderer';
import path from 'path';
import fs from 'fs';
import os from 'os';

async function renderVideo(inputProps) {
    try {
        console.log('Starting video render...');
        console.log('Input props:', JSON.stringify(inputProps, null, 2));

        // Create a webpack bundle of the video
        const bundleLocation = await bundle({
            entryPoint: path.resolve('./src/remotion/index.ts'),
            webpackOverride: (config) => ({
                ...config,
                output: {
                    ...config.output,
                    filename: 'bundle.js',
                },
            }),
        });

        console.log('Bundle created at:', bundleLocation);

        // Select the composition
        const composition = await selectComposition({
            serveUrl: bundleLocation,
            id: 'ScriptVideo',
            inputProps: {
                script: inputProps.script
            },
        });

        // Generate output path
        const outputLocation = path.resolve(
            `./public/videos/video-${Date.now()}.mp4`
        );

        // Ensure output directory exists
        const outputDir = path.dirname(outputLocation);
        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true });
        }

        console.log('Rendering video...');
        console.log('Output location:', outputLocation);

        // Render the video
        await renderMedia({
            composition,
            serveUrl: bundleLocation,
            codec: 'h264',
            outputLocation,
            inputProps: {
                script: inputProps.script
            },
            chromiumOptions: {
                headless: true,
                enableAcceleratedRendering: true,
                disableWebSecurity: true,
            },
            onProgress: ({ progress }) => {
                console.log(`Rendering progress: ${Math.floor(progress * 100)}%`);
            },
        });

        const publicUrl = `/videos/${path.basename(outputLocation)}`;
        console.log('Render complete!');
        console.log(JSON.stringify({
            success: true,
            outputLocation: publicUrl
        }));

    } catch (err) {
        console.error('Render failed:', err);
        console.log(JSON.stringify({
            success: false,
            error: err.message
        }));
        process.exit(1);
    }
}

// Get input props from command line argument
const inputProps = JSON.parse(process.argv[2]);
renderVideo(inputProps); 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\services\audioService.ts ---

import axios from 'axios';
import { WordTiming } from '../types/script';

const ELEVEN_LABS_API_KEY = process.env.REACT_APP_ELEVEN_LABS_API_KEY;
const ELEVEN_LABS_VOICE_ID = process.env.REACT_APP_ELEVEN_LABS_VOICE_ID;

export async function generateSpeech(text: string): Promise<{ url: string, blob: Blob }> {
    // Generate audio with ElevenLabs
    const audioResponse = await axios.post(
        `https://api.elevenlabs.io/v1/text-to-speech/${ELEVEN_LABS_VOICE_ID}`,
        {
            text,
            voice_settings: {
                stability: 0.75,
                similarity_boost: 0.75
            }
        },
        {
            headers: {
                'Content-Type': 'application/json',
                'xi-api-key': ELEVEN_LABS_API_KEY
            },
            responseType: 'blob'
        }
    );

    // Create a blob URL for the audio
    const audioBlob = new Blob([audioResponse.data], { type: 'audio/mpeg' });
    return {
        url: URL.createObjectURL(audioBlob),
        blob: audioBlob
    };
}

export async function generateCaptions(audioBlob: Blob): Promise<WordTiming[]> {
    // Create form data for the transcription request
    const formData = new FormData();
    formData.append('audio', audioBlob, 'speech.mp3');

    // Send to Whisper service for transcription
    const transcriptionResponse = await axios.post('http://localhost:5000/transcribe', formData, {
        headers: {
            'Content-Type': 'multipart/form-data'
        }
    });

    return transcriptionResponse.data.wordTimings;
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\services\elevenLabs.ts ---

import axios, { AxiosError } from 'axios';
import { WordTiming } from '../types/script';
import { useApiKeys } from '../store/apiKeysStore';

interface GenerateSpeechParams {
    text: string;
    voiceId: string;
    settings?: {
        stability?: number;
        similarity_boost?: number;
    };
}

export async function generateSpeech({ text, voiceId, settings = {} }: GenerateSpeechParams): Promise<{ audioUrl: string, wordTimings: WordTiming[] }> {
    console.log('[generateSpeech] Starting with params:', { text, voiceId, settings });
    
    const { elevenLabsApiKey } = useApiKeys.getState();
    console.log('[generateSpeech] Got API key:', elevenLabsApiKey ? 'Present' : 'Missing');

    if (!elevenLabsApiKey) {
        console.error('[generateSpeech] API key is missing');
        throw new Error('ElevenLabs API key is not set. Please set it in the settings menu.');
    }

    // Prepare request body
    const requestBody = {
        text,
        voiceId,
        model_id: "eleven_monolingual_v1",
        voice_settings: {
            stability: settings.stability ?? 0.75,
            similarity_boost: settings.similarity_boost ?? 0.75
        },
        apiKey: elevenLabsApiKey
    };
    console.log('[generateSpeech] Prepared request body:', requestBody);

    try {
        // Generate audio with ElevenLabs
        console.log('[generateSpeech] Sending request to:', `http://localhost:3005/generate_voice`);
        const audioResponse = await axios.post(
            `http://localhost:3005/generate_voice`,
            requestBody
        );
        console.log('[generateSpeech] Received response:', audioResponse.data);

        return {
            audioUrl: audioResponse.data.url,
            wordTimings: audioResponse.data.wordTimings || []
        };
    } catch (error) {
        const axiosError = error as AxiosError;
        console.error('[generateSpeech] Error details:', {
            error: axiosError.message,
            response: axiosError.response?.data,
            status: axiosError.response?.status,
            headers: axiosError.response?.headers
        });
        throw error;
    }
}

export async function generateCaptions(audioBlob: Blob): Promise<WordTiming[]> {
    console.log('[generateCaptions] Starting with audio blob size:', audioBlob.size);
    
    // Create form data for the transcription request
    const formData = new FormData();
    formData.append('audio', audioBlob, 'speech.mp3');

    try {
        // Send to Whisper service for transcription
        console.log('[generateCaptions] Sending request to transcription service');
        const transcriptionResponse = await axios.post('http://localhost:5000/transcribe', formData, {
            headers: {
                'Content-Type': 'multipart/form-data'
            }
        });
        console.log('[generateCaptions] Received response:', transcriptionResponse.data);

        return transcriptionResponse.data.wordTimings;
    } catch (error) {
        const axiosError = error as AxiosError;
        console.error('[generateCaptions] Error:', axiosError.message);
        throw error;
    }
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\services\pexels.ts ---

import { createClient, Photo } from 'pexels';

const client = createClient('rXEDE5m6pUxOXZPawHmzKj04Z29WlV2y0Us44ld2TmXwdZstXtHUIh2F');

export const searchImages = async (query: string): Promise<Photo[]> => {
  try {
    const response = await client.photos.search({
      query,
      per_page: 10,
    });
    return response.photos;
  } catch (error) {
    console.error('Error fetching images:', error);
    return [];
  }
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\services\templateService.ts ---

import { Template, TemplateComponent } from '../types/template';
import { Script, ScriptComponent } from '../types/script';

// Convert a script to a template
export const scriptToTemplate = (script: Script, name: string, description?: string): Template => {
    const templateComponents: TemplateComponent[] = script.components.map(component => {
        // Remove content-specific data but keep structure and styling
        const templateComponent = { ...component } as TemplateComponent;
        
        if ('text' in templateComponent) {
            delete (templateComponent as any).text;
            templateComponent.placeholderText = 'Enter your text here';
        }
        
        if ('audioUrl' in templateComponent) {
            delete (templateComponent as any).audioUrl;
        }
        
        if ('wordTimings' in templateComponent) {
            delete (templateComponent as any).wordTimings;
        }
        
        return templateComponent;
    });

    // Don't save blob URLs in templates
    const settings = { ...script.settings };
    if (settings.background?.url?.startsWith('blob:')) {
        settings.background = {
            ...settings.background,
            url: undefined
        };
    }

    return {
        id: `template_${Date.now()}`,
        name,
        description,
        components: templateComponents,
        settings
    };
};

// Convert a template to a script
export const templateToScript = (template: Template): Script => {
    const scriptComponents: ScriptComponent[] = template.components.map(component => {
        const scriptComponent = { ...component } as ScriptComponent;
        
        if (component.placeholderText) {
            (scriptComponent as any).text = component.placeholderText;
        }
        
        return scriptComponent;
    });

    return {
        id: `script_${Date.now()}`,
        title: `Script from ${template.name}`,
        components: scriptComponents,
        settings: template.settings
    };
};

// Save template to localStorage
export const saveTemplate = (template: Template): void => {
    const templates = getTemplates();
    templates.push(template);
    localStorage.setItem('video_templates', JSON.stringify(templates));
};

// Get all saved templates
export const getTemplates = (): Template[] => {
    const templatesJson = localStorage.getItem('video_templates');
    return templatesJson ? JSON.parse(templatesJson) : [];
};

// Get template by ID
export const getTemplateById = (id: string): Template | undefined => {
    const templates = getTemplates();
    return templates.find(t => t.id === id);
};

// Delete template
export const deleteTemplate = (id: string): void => {
    const templates = getTemplates();
    const filteredTemplates = templates.filter(t => t.id !== id);
    localStorage.setItem('video_templates', JSON.stringify(filteredTemplates));
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\services\videoService.ts ---

import { Script } from '../types/script';
import axios from 'axios';

const RENDER_SERVICE_URL = 'http://localhost:29382';

interface ExportSettings {
    fps: number;
    width: number;
    height: number;
    codec: 'h264' | 'h265' | 'vp8' | 'vp9';
    quality: number;
}

export const addBackgroundToHistory = (script: Script, background: Script['settings']['background']) => {
    if (!background) return script;

    const newScript = { ...script };
    if (!newScript.settings.backgroundHistory) {
        newScript.settings.backgroundHistory = [];
    }

    // Add current background to history
    newScript.settings.backgroundHistory.push({
        ...background,
        timestamp: Date.now(),
        title: `Background ${newScript.settings.backgroundHistory.length + 1}`,
    });

    // Keep only the last 10 backgrounds
    if (newScript.settings.backgroundHistory.length > 10) {
        newScript.settings.backgroundHistory = newScript.settings.backgroundHistory.slice(-10);
    }

    return newScript;
};

export async function exportVideo(script: Script, settings: ExportSettings): Promise<{ success: boolean; outputPath: string }> {
    try {
        console.log('Starting video export process...', { script, settings });
        
        // Use our Python proxy service
        const response = await axios.post(`${RENDER_SERVICE_URL}/render`, {
            script,
            settings,
        }, {
            headers: {
                'Content-Type': 'application/json',
            },
        });

        console.log('Render API Response:', response.data);

        if (!response.data.success) {
            console.error('API Error:', response.data);
            throw new Error(response.data.error || 'Failed to render video');
        }

        const outputPath = response.data.outputPath;
        if (!outputPath) {
            console.error('API Response:', response.data);
            throw new Error('No output path received from render service');
        }

        return {
            success: true,
            outputPath,
        };
    } catch (error) {
        if (axios.isAxiosError(error)) {
            console.error('API Error Details:', {
                status: error.response?.status,
                statusText: error.response?.statusText,
                data: error.response?.data,
                headers: error.response?.headers,
            });
            throw new Error(error.response?.data?.error || error.message);
        }
        console.error('Error in video export:', error instanceof Error ? error.message : 'Unknown error');
        throw error;
    }
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\store\apiKeysStore.ts ---

import { create } from 'zustand';

interface ApiKeysState {
    elevenLabsApiKey: string;
    pexelsApiKey: string;
    setElevenLabsApiKey: (key: string) => void;
    setPexelsApiKey: (key: string) => void;
}

export const useApiKeys = create<ApiKeysState>((set) => ({
    elevenLabsApiKey: '',
    pexelsApiKey: '',
    setElevenLabsApiKey: (key) => set({ elevenLabsApiKey: key }),
    setPexelsApiKey: (key) => set({ pexelsApiKey: key }),
})); 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\store\configStore.ts ---

import { create } from 'zustand';
import { persist, PersistOptions } from 'zustand/middleware';

interface ConfigState {
    elevenLabsApiKey: string;
    pexelsApiKey: string;
    setElevenLabsApiKey: (key: string) => void;
    setPexelsApiKey: (key: string) => void;
}

type ConfigPersist = (
    config: (
        set: (state: Partial<ConfigState>) => void,
        get: () => ConfigState,
    ) => ConfigState,
    options: PersistOptions<ConfigState>
) => any;

export const useConfigStore = create<ConfigState>(
    (persist as ConfigPersist)(
        (set) => ({
            elevenLabsApiKey: '',
            pexelsApiKey: '',
            setElevenLabsApiKey: (key: string) => set({ elevenLabsApiKey: key }),
            setPexelsApiKey: (key: string) => set({ pexelsApiKey: key }),
        }),
        {
            name: 'video-maker-config',
        }
    )
); 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\styles\commonStyles.ts ---

import { theme } from './theme';

export const commonStyles = {
    card: {
        backgroundColor: theme.colors.background.secondary,
        borderRadius: theme.borderRadius.lg,
        padding: theme.spacing.lg,
        boxShadow: theme.shadows.md,
        border: `1px solid ${theme.colors.border}`,
    },
    input: {
        backgroundColor: theme.colors.background.tertiary,
        border: `1px solid ${theme.colors.border}`,
        borderRadius: theme.borderRadius.md,
        padding: theme.spacing.md,
        color: theme.colors.text.primary,
        fontSize: '14px',
        width: '100%',
        outline: 'none',
        transition: 'all 0.2s ease',
        '&:focus': {
            borderColor: theme.colors.primary,
            boxShadow: `0 0 0 2px ${theme.colors.primary}25`,
        },
    },
    button: {
        primary: {
            backgroundColor: theme.colors.primary,
            color: theme.colors.text.primary,
            border: 'none',
            borderRadius: theme.borderRadius.md,
            padding: `${theme.spacing.sm} ${theme.spacing.lg}`,
            cursor: 'pointer',
            transition: 'all 0.2s ease',
            '&:hover': {
                backgroundColor: `${theme.colors.primary}E6`,
            },
            '&:disabled': {
                opacity: 0.5,
                cursor: 'not-allowed',
            },
        },
        secondary: {
            backgroundColor: 'transparent',
            color: theme.colors.text.primary,
            border: `1px solid ${theme.colors.border}`,
            borderRadius: theme.borderRadius.md,
            padding: `${theme.spacing.sm} ${theme.spacing.lg}`,
            cursor: 'pointer',
            transition: 'all 0.2s ease',
            '&:hover': {
                backgroundColor: theme.colors.background.tertiary,
            },
        },
    },
    label: {
        color: theme.colors.text.secondary,
        fontSize: '14px',
        marginBottom: theme.spacing.xs,
        display: 'block',
    },
    heading: {
        color: theme.colors.text.primary,
        margin: `${theme.spacing.md} 0`,
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\styles\globals.css ---

/* Reset and base styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html,
body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    overflow: hidden;
}

/* Scrollbar styling */
::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.1);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.2);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.3);
}

/* Button hover effects */
button {
    position: relative;
    overflow: hidden;
}

button::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 50%;
    transform: translate(-50%, -50%);
    transition: width 0.3s ease-out, height 0.3s ease-out;
}

button:hover::after {
    width: 300%;
    height: 300%;
}

/* Card hover effects */
[class*="card"] {
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

[class*="card"]:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
}

/* Input focus styles */
input:focus,
select:focus,
textarea:focus {
    outline: none;
    box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.4);
}

/* Gradient text */
.gradient-text {
    background: linear-gradient(135deg, #6366F1, #8B5CF6);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

/* Glass morphism effect */
.glass {
    background: rgba(255, 255, 255, 0.05);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
}

/* Animation classes */
.fade-in {
    animation: fadeIn 0.3s ease-in-out;
}

.slide-up {
    animation: slideUp 0.3s ease-out;
}

.scale-in {
    animation: scaleIn 0.3s ease-out;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes slideUp {
    from { transform: translateY(20px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
}

@keyframes scaleIn {
    from { transform: scale(0.95); opacity: 0; }
    to { transform: scale(1); opacity: 1; }
}

/* Tooltip styles */
[data-tooltip] {
    position: relative;
}

[data-tooltip]::before {
    content: attr(data-tooltip);
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    padding: 4px 8px;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    font-size: 12px;
    border-radius: 4px;
    white-space: nowrap;
    opacity: 0;
    visibility: hidden;
    transition: all 0.2s ease;
}

[data-tooltip]:hover::before {
    opacity: 1;
    visibility: visible;
    transform: translateX(-50%) translateY(-8px);
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\styles\theme.ts ---

export const theme = {
    colors: {
        primary: '#FF4B4B',
        secondary: '#2D2D2D',
        accent: {
            red: '#FF4B4B',
            orange: '#FF8F00',
            yellow: '#FFD600',
            green: '#00C853',
            blue: '#2196F3',
            purple: '#7C4DFF',
        },
        background: {
            primary: '#121212',
            secondary: '#1E1E1E',
            tertiary: '#252525',
            overlay: 'rgba(0, 0, 0, 0.8)',
        },
        text: {
            primary: '#FFFFFF',
            secondary: '#B3B3B3',
            accent: '#808080',
        },
        border: '#333333',
        error: '#FF4B4B',
        success: '#00C853',
        warning: '#FF8F00',
    },
    spacing: {
        xs: '4px',
        sm: '8px',
        md: '16px',
        lg: '24px',
        xl: '32px',
        xxl: '48px',
    },
    borderRadius: {
        sm: '4px',
        md: '6px',
        lg: '8px',
        xl: '12px',
        full: '9999px',
    },
    shadows: {
        sm: '0 2px 4px rgba(0, 0, 0, 0.2)',
        md: '0 4px 8px rgba(0, 0, 0, 0.3)',
        lg: '0 8px 16px rgba(0, 0, 0, 0.4)',
        xl: '0 12px 24px rgba(0, 0, 0, 0.5)',
        highlight: '0 0 0 1px rgba(255, 75, 75, 0.3)',
    },
    transitions: {
        fast: 'all 0.15s cubic-bezier(0.4, 0, 0.2, 1)',
        normal: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
        slow: 'all 0.5s cubic-bezier(0.4, 0, 0.2, 1)',
    },
    fonts: {
        heading: '"SF Pro Display", -apple-system, BlinkMacSystemFont, sans-serif',
        body: '"SF Pro Text", -apple-system, BlinkMacSystemFont, sans-serif',
        mono: '"SF Mono", "Fira Code", monospace',
    },
    fontSizes: {
        xs: '11px',
        sm: '13px',
        md: '14px',
        lg: '16px',
        xl: '18px',
        '2xl': '20px',
        '3xl': '24px',
    },
    componentColors: {
        text: '#2196F3',
        title: '#7C4DFF',
        voice: '#FF4B4B',
        comparison: '#00C853',
        countdown: '#FF8F00',
        transition: '#FFD600',
    },
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\styles\timeline.css ---

.timeline-item {
    position: relative;
}

.timeline-item.drag-over::before {
    content: '';
    position: absolute;
    top: -2px;
    left: 0;
    right: 0;
    height: 4px;
    background-color: #007bff;
    border-radius: 2px;
}

.timeline-item.drop-zone.drag-over {
    border-color: #007bff;
    background-color: rgba(0, 123, 255, 0.1);
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\types\media.d.ts ---

declare module '*.mp4' {
    const src: string;
    export default src;
}

declare module '*.mp3' {
    const src: string;
    export default src;
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\types\quiz.ts ---

export interface ComparisonOption {
    text: string;
    imageUrl: string;
}

export interface Comparison {
    id: string;
    question: string;
    leftOption: ComparisonOption;
    rightOption: ComparisonOption;
}

export interface QuizConfig {
    comparisons: Comparison[];
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\types\script.ts ---

export interface WordTiming {
    word: string;
    start: number;
    end: number;
}

export interface CaptionStyleOptions {
    fontSize: number;
    color: string;
    backgroundColor: string;
    position: 'top' | 'bottom';
    wordWindow: number;
    // Font options
    fontFamily?: string;
    fontWeight?: number | string;
    fontStyle?: 'normal' | 'italic';
    textDecoration?: string;
    // Block style options
    padding?: string;
    margin?: string;
    borderRadius?: string;
    border?: string;
    boxShadow?: string;
    opacity?: number;
    // Positioning
    x?: number;
    y?: number;
    scale?: number;
    rotation?: number;
}

export type CaptionPreset = 
    | 'default' 
    | 'tiktok' 
    | 'subtitle' 
    | 'remotion-subtitles'
    | 'bounce'
    | 'colorful'
    | 'explosive'
    | 'fade'
    | 'fire'
    | 'glitch'
    | 'glowing'
    | 'lightning'
    | 'neon'
    | 'rotating'
    | 'shake'
    | 'threeDish'
    | 'tiltShift'
    | 'typewriter'
    | 'waving'
    | 'zoom';

export type CaptionStyle = CaptionStyleOptions | CaptionPreset;

export type TikTokToken = {
    text: string;
    fromMs: number;
    toMs: number;
};

export type TikTokPage = {
    text: string;
    startMs: number;
    tokens: TikTokToken[];
};

export type AnimationType = 'fade' | 'scale' | 'slide' | 'typewriter' | 'bounce' | 'wave';

export interface AnimationConfig {
    type: AnimationType;
    duration: number;
    delay?: number;
    direction?: 'left' | 'right' | 'up' | 'down';
    easing?: 'linear' | 'ease-in' | 'ease-out' | 'ease-in-out';
    springConfig?: {
        damping: number;
        mass?: number;
        stiffness?: number;
    };
}

export interface TextStyleBase {
    fontSize?: number;
    fontFamily?: string;
    color?: string;
    textAlign?: 'left' | 'center' | 'right';
    fontWeight?: string | number;
    textTransform?: 'none' | 'uppercase' | 'lowercase' | 'capitalize';
    letterSpacing?: number;
    lineHeight?: number;
    strokeWidth?: number;
    strokeColor?: string;
    backgroundColor?: string;
    padding?: string | number;
    borderRadius?: string | number;
    shadow?: {
        color: string;
        blur: number;
        offset?: { x: number; y: number };
    };
}

export interface TextStyle {
    fontSize?: number;
    fontFamily?: string;
    color?: string;
    textAlign?: 'left' | 'center' | 'right' | 'justify';
    fontWeight?: string | number;
    lineHeight?: string | number;
    wordsPerLine?: number;
    textTransform?: 'none' | 'uppercase' | 'lowercase' | 'capitalize';
    position?: {
        x: number;
        y: number;
    };
    blockStyle?: {
        enabled: boolean;
    };
    backgroundColor?: string;
    padding?: string;
    borderRadius?: string;
    outline?: {
        enabled: boolean;
        color: string;
        width: number;
    };
    animation?: AnimationOptions;
}

export type TextDisplayMode = 'sync' | 'instant';

export type ComponentType = 
    | 'text'
    | 'comparison'
    | 'image'
    | 'transition'
    | 'title'
    | 'question'
    | 'splitScreen'
    | 'countdown'
    | 'voice'
    | 'video'
    | 'audio';

export interface BaseScriptComponent {
    id: string;
    type: ComponentType;
    startFrame: number;
    durationInFrames: number;
    track?: number;
}

export interface AnimationOptions {
    type: 'none' | 'fade' | 'scale' | 'rotate' | 'slide';
    in?: {
        type: 'none' | 'fade' | 'scale' | 'rotate' | 'slide';
        startFrame?: number;
        endFrame?: number;
    };
    out?: {
        type: 'none' | 'fade' | 'scale' | 'rotate' | 'slide';
        startFrame?: number;
        endFrame?: number;
    };
    direction?: 'in' | 'out' | 'left' | 'right' | 'up' | 'down';
    easing?: 'linear' | 'easeIn' | 'easeOut' | 'easeInOut';
    duration: number;
    delay?: number;
    stagger?: number;
}

export interface ComparisonComponentStyle {
    fontSize?: number;
    fontFamily?: string;
    textColor?: string;
    backgroundColor?: string;
    spacing?: number;
    borderRadius?: number;
    shadow?: string;
    showText?: boolean;
    orientation?: 'horizontal' | 'vertical';
    imageSize?: number;
    imageGap?: number;
    forceSameSize?: boolean;
    imagePosition?: Partial<{
        x: number;
        y: number;
    }>;
    imageBorder?: {
        enabled: boolean;
        color: string;
        width: number;
    };
    imageDropShadow?: {
        enabled: boolean;
        color: string;
        blur: number;
        spread: number;
        x: number;
        y: number;
    };
    animation?: AnimationOptions;
}

export type ComparisonComponent = BaseScriptComponent & {
    type: 'comparison';
    question: string;
    orientation: 'horizontal' | 'vertical';
    leftOption: {
        text: string;
        imageUrl: string;
    };
    rightOption: {
        text: string;
        imageUrl: string;
    };
    style?: ComparisonComponentStyle;
};

export interface TextComponent extends BaseScriptComponent {
    type: 'text';
    text: string;
    style?: TextStyle;
}

export interface TitleComponent extends BaseScriptComponent {
    type: 'title';
    text: string;
    subtitle?: string;
    style?: TextStyle;
    background?: {
        type: 'color' | 'image';
        value: string;
    };
}

export interface CountdownComponent extends BaseScriptComponent {
    type: 'countdown';
    from: number;
    style: TextStyle;
    sound?: boolean;
}

export interface TransitionComponent extends BaseScriptComponent {
    type: 'transition';
    transitionType: 'fade' | 'slide' | 'whoosh';
    direction?: 'left' | 'right' | 'up' | 'down';
}

export interface VideoComponentStyle {
    width?: number;
    height?: number;
    position?: {
        x: number;
        y: number;
    };
    scale?: number;
    rotation?: number;
    opacity?: number;
    border?: {
        enabled: boolean;
        color: string;
        width: number;
    };
    dropShadow?: {
        enabled: boolean;
        color: string;
        blur: number;
        spread: number;
        x: number;
        y: number;
    };
    volume?: number;
    playbackRate?: number;
    loop?: boolean;
    muted?: boolean;
    chromakey?: {
        enabled: boolean;
        color: string;
        similarity: number;  // 0-1, how close colors need to be to be removed
        smoothness: number;  // 0-1, edge smoothness
    };
    animation?: AnimationOptions;
    // Add time control properties
    startTime?: number;  // Start time in seconds from the source video
    duration?: number;   // Duration in seconds to use from the source video
}

export type VideoComponent = BaseScriptComponent & {
    type: 'video';
    videoUrl: string;
    style?: VideoComponentStyle;
};

export interface AudioComponentStyle {
    volume?: number;
    loop?: boolean;
    startTime?: number;
    duration?: number;
}

export interface AudioFile {
    url: string;
    name: string;
    format: string;
    addedAt: string;
}

export interface AudioComponent extends BaseScriptComponent {
    type: 'audio';
    audioUrl: string | AudioFile;
    style?: AudioComponentStyle;
}

export interface VoiceSettings {
    voiceId: string;
    stability: number;
    similarity_boost: number;
}

export interface VoiceComponent extends BaseScriptComponent {
    type: 'voice';
    text: string;
    audioUrl?: string;
    voiceSettings?: VoiceSettings;
    wordTimings?: WordTiming[];
    showCaptions?: boolean;
    captionStyle?: CaptionStyleOptions;
    style?: VoiceStyle;
}

export interface CaptionTrack {
    id: string;
    originalComponentId?: string;  // ID of the original voice component
    isLinked: boolean;
    wordTimings: WordTiming[];
    startFrame: number;
    text: string;
}

export interface ImageComponentStyle {
    width?: number;
    height?: number;
    position?: {
        x: number;
        y: number;
    };
    scale?: number;
    rotation?: number;
    opacity?: number;
    border?: {
        enabled: boolean;
        color: string;
        width: number;
    };
    dropShadow?: {
        enabled: boolean;
        color: string;
        blur: number;
        spread: number;
        x: number;
        y: number;
    };
}

export interface ImageComponent extends BaseScriptComponent {
    type: 'image';
    imageUrl: string;
    style?: ImageComponentStyle;
}

export type Component = TextComponent | ComparisonComponent | TitleComponent | CountdownComponent | TransitionComponent | VoiceComponent | VideoComponent | AudioComponent | ImageComponent;

export interface Script {
    id: string;
    title: string;
    components: Component[];
    captionTracks: CaptionTrack[];
    settings: {
        defaultTextStyle: TextStyle;
        defaultCaptionStyle: TextStyle;
        background?: {
            type: 'none' | 'image' | 'video';
            url?: string;
            filePath?: string;
            durationInFrames?: number;
        };
        backgroundHistory?: Array<{
            type: 'none' | 'image' | 'video';
            url?: string;
            filePath?: string;
            durationInFrames?: number;
            timestamp: number;  // When this background was used
            title?: string;    // Optional user-provided title
        }>;
    };
}

export interface VoiceComponentStyle extends TextStyle {
    wordWindow?: number; // Number of words to show at once
}

export interface VoiceStyle {
    volume?: number;
    loop?: boolean;
    startTime?: number;
    duration?: number;
    animation?: AnimationOptions;
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\types\template.ts ---

import { Script, ScriptComponent, TextStyle } from './script';

export interface TemplateComponent extends Omit<ScriptComponent, 'text' | 'audioUrl' | 'wordTimings'> {
    placeholderText?: string;
    defaultStyle?: TextStyle;
}

export interface Template {
    id: string;
    name: string;
    description?: string;
    components: TemplateComponent[];
    settings: {
        defaultTextStyle: TextStyle;
        defaultCaptionStyle: TextStyle;
        background?: {
            type: 'none' | 'image' | 'video';
            placeholderUrl?: string;
            durationInFrames?: number;
        };
    };
} 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\utils\animation.ts ---

import { spring } from 'remotion';
import { AnimationOptions } from '../types/script';

export const getAnimationStyle = (frame: number, fps: number, animation?: AnimationOptions) => {
    if (!animation || animation.type === 'none') {
        return {};
    }

    const progress = spring({
        frame,
        fps,
        config: {
            damping: 10,
            mass: 0.5,
            stiffness: 100,
        },
        durationInFrames: animation.duration,
        delay: animation.delay || 0,
    });

    const reverseProgress = 1 - progress;
    const direction = animation.direction || 'in';
    const isIn = direction === 'in';
    const currentProgress = isIn ? progress : reverseProgress;

    switch (animation.type) {
        case 'fade':
            return {
                opacity: currentProgress,
            };
        case 'scale':
            return {
                transform: `translate(-50%, -50%) scale(${isIn ? currentProgress : 1 + (currentProgress * 0.5)})`,
            };
        case 'rotate':
            return {
                transform: `translate(-50%, -50%) rotate(${currentProgress * (isIn ? 360 : -360)}deg)`,
            };
        case 'slide':
            const offset = 100;
            const x = animation.direction === 'left' ? -offset : animation.direction === 'right' ? offset : 0;
            const y = animation.direction === 'up' ? -offset : animation.direction === 'down' ? offset : 0;
            return {
                transform: `translate(calc(-50% + ${x * currentProgress}px), calc(-50% + ${y * currentProgress}px))`,
            };
        default:
            return {};
    }
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\utils\componentFactory.ts ---

import { 
    ComponentType, 
    Component,
    BaseScriptComponent,
    TextStyle,
    TextComponent,
    ComparisonComponent,
    TitleComponent,
    CountdownComponent,
    TransitionComponent,
    VoiceComponent,
    VideoComponent,
    AudioComponent
} from '../types/script';

const DEFAULT_TEXT_STYLE: TextStyle = {
    fontSize: 40,
    color: 'white',
    fontFamily: 'Arial',
    textAlign: 'center',
    fontWeight: 'normal',
};

export const createComponent = (
    type: ComponentType,
    defaultTextStyle: TextStyle = DEFAULT_TEXT_STYLE,
    defaultCaptionStyle: TextStyle = DEFAULT_TEXT_STYLE
): Component => {
    const baseProps = {
        id: Date.now().toString(),
        durationInFrames: 150, // 5 seconds default
        startFrame: 0,
    };

    switch (type) {
        case 'title':
            return {
                ...baseProps,
                type: 'title',
                text: 'New Title',
                subtitle: '',
                style: { ...defaultTextStyle },
                background: {
                    type: 'color',
                    value: '#000000',
                },
            } as TitleComponent;

        case 'text':
            return {
                ...baseProps,
                type: 'text',
                text: 'Enter your text here',
                style: { ...defaultTextStyle },
            } as TextComponent;

        case 'comparison':
            return {
                ...baseProps,
                type: 'comparison',
                question: 'Enter your question',
                leftOption: {
                    text: 'Left Option',
                    imageUrl: '',
                },
                rightOption: {
                    text: 'Right Option',
                    imageUrl: '',
                },
            } as ComparisonComponent;

        case 'countdown':
            return {
                ...baseProps,
                type: 'countdown',
                from: 5,
                style: { ...defaultTextStyle },
                sound: true,
                durationInFrames: 150,
            } as CountdownComponent;

        case 'transition':
            return {
                ...baseProps,
                type: 'transition',
                transitionType: 'fade',
                direction: 'left',
                durationInFrames: 30,
            } as TransitionComponent;

        case 'voice':
            return {
                ...baseProps,
                type: 'voice',
                text: 'Enter text for voice generation',
                voiceSettings: {
                    voiceId: 'GhJYgP4Lrji0pwS3kQwv',
                    stability: 0.75,
                    similarity_boost: 0.75,
                },
                captionStyle: {
                    fontSize: 24,
                    color: '#ffffff',
                    backgroundColor: 'rgba(0, 0, 0, 0.7)',
                    position: 'bottom',
                    wordWindow: 1,
                },
                showCaptions: false,
                style: { ...defaultTextStyle },
            } as VoiceComponent;

        case 'video':
            return {
                ...baseProps,
                type: 'video',
                videoUrl: '',
                style: {
                    width: 100,
                    height: 100,
                    position: { x: 0, y: 0 },
                    scale: 1,
                    rotation: 0,
                    opacity: 1,
                    borderRadius: 0,
                    border: {
                        enabled: false,
                        color: '#000000',
                        width: 1,
                    },
                    dropShadow: {
                        enabled: false,
                        color: 'rgba(0,0,0,0.5)',
                        blur: 10,
                        spread: 0,
                        x: 0,
                        y: 4,
                    },
                    volume: 1,
                    playbackRate: 1,
                    loop: false,
                    muted: false,
                    animation: {
                        type: 'none',
                        duration: 30,
                        delay: 0,
                        direction: 'left',
                        easing: 'easeInOut',
                    },
                },
            } as VideoComponent;

        case 'audio':
            return {
                ...baseProps,
                type: 'audio',
                audioUrl: '',
                style: {
                    volume: 1,
                    loop: false,
                    startTime: 0,
                    duration: undefined,
                },
            } as AudioComponent;

        default:
            throw new Error(`Unknown component type: ${type}`);
    }
}; 


--- Path: D:\Projects\Remotion Couples Quiz\my-video\src\utils\fileUtils.ts ---

export async function checkFileAccessibility(url: string): Promise<boolean> {
    console.log(`=== Checking accessibility for URL: ${url} ===`);
    try {
        console.log('Sending HEAD request...');
        const response = await fetch(url, { method: 'HEAD' });
        console.log('Response status:', response.status);
        console.log('Response headers:', Object.fromEntries(response.headers.entries()));
        console.log('Response ok:', response.ok);
        return response.ok;
    } catch (error: any) {
        console.error(`Error checking accessibility for ${url}:`, error);
        console.error('Error details:', {
            name: error?.name || 'Unknown',
            message: error?.message || 'No message available',
            stack: error?.stack || 'No stack trace available'
        });
        return false;
    }
}

export async function findAccessibleUrl(urls: string[]): Promise<string | null> {
    console.log('=== Finding accessible URL ===');
    console.log('Checking URLs:', urls);
    
    for (const url of urls) {
        console.log(`\nTesting URL: ${url}`);
        if (await checkFileAccessibility(url)) {
            console.log('‚úÖ URL is accessible:', url);
            return url;
        } else {
            console.log('‚ùå URL is not accessible:', url);
        }
    }
    
    console.error('No accessible URLs found among:', urls);
    return null;
} 
